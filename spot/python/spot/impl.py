# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.10
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_impl')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_impl')
    _impl = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_impl', [dirname(__file__)])
        except ImportError:
            import _impl
            return _impl
        if fp is not None:
            try:
                _mod = imp.load_module('_impl', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _impl = swig_import_helper()
    del swig_import_helper
else:
    import _impl
del _swig_python_version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


SHARED_PTR_DISOWN = _impl.SHARED_PTR_DISOWN
class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _impl.delete_SwigPyIterator

    def value(self) -> "PyObject *":
        return _impl.SwigPyIterator_value(self)

    def incr(self, n: 'size_t'=1) -> "swig::SwigPyIterator *":
        return _impl.SwigPyIterator_incr(self, n)

    def decr(self, n: 'size_t'=1) -> "swig::SwigPyIterator *":
        return _impl.SwigPyIterator_decr(self, n)

    def distance(self, x: 'SwigPyIterator') -> "ptrdiff_t":
        return _impl.SwigPyIterator_distance(self, x)

    def equal(self, x: 'SwigPyIterator') -> "bool":
        return _impl.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        return _impl.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *":
        return _impl.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *":
        return _impl.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *":
        return _impl.SwigPyIterator_previous(self)

    def advance(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator *":
        return _impl.SwigPyIterator_advance(self, n)

    def __eq__(self, x: 'SwigPyIterator') -> "bool":
        return _impl.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: 'SwigPyIterator') -> "bool":
        return _impl.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator &":
        return _impl.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator &":
        return _impl.SwigPyIterator___isub__(self, n)

    def __add__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator *":
        return _impl.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        return _impl.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _impl.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

import buddy
class parse_error(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, s: 'std::string const &'):
        _impl.parse_error_swiginit(self, _impl.new_parse_error(s))
    __swig_destroy__ = _impl.delete_parse_error
parse_error_swigregister = _impl.parse_error_swigregister
parse_error_swigregister(parse_error)


def version() -> "char const *":
    return _impl.version()
version = _impl.version
class minato_isop(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _impl.minato_isop_swiginit(self, _impl.new_minato_isop(*args))

    def next(self) -> "bdd":
        return _impl.minato_isop_next(self)
    __swig_destroy__ = _impl.delete_minato_isop
minato_isop_swigregister = _impl.minato_isop_swigregister
minato_isop_swigregister(minato_isop)

class option_map(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def parse_options(self, options: 'char const *') -> "char const *":
        return _impl.option_map_parse_options(self, options)

    def get(self, option: 'char const *', arg3: 'int'=0) -> "int":
        return _impl.option_map_get(self, option, arg3)

    def get_str(self, *args) -> "std::string":
        return _impl.option_map_get_str(self, *args)

    def set_str(self, *args) -> "std::string":
        return _impl.option_map_set_str(self, *args)

    def report_unused_options(self) -> "void":
        return _impl.option_map_report_unused_options(self)

    def set(self, *args) -> "void":
        return _impl.option_map_set(self, *args)

    def __init__(self):
        _impl.option_map_swiginit(self, _impl.new_option_map())
    __swig_destroy__ = _impl.delete_option_map
option_map_swigregister = _impl.option_map_swigregister
option_map_swigregister(option_map)


def srand(seed: 'unsigned int') -> "void":
    return _impl.srand(seed)
srand = _impl.srand

def rrand(min: 'int', max: 'int') -> "int":
    return _impl.rrand(min, max)
rrand = _impl.rrand

def mrand(max: 'int') -> "int":
    return _impl.mrand(max)
mrand = _impl.mrand

def drand() -> "double":
    return _impl.drand()
drand = _impl.drand

def nrand() -> "double":
    return _impl.nrand()
nrand = _impl.nrand

def escape_rfc4180(os: 'ostream', str: 'std::string const &') -> "std::ostream &":
    return _impl.escape_rfc4180(os, str)
escape_rfc4180 = _impl.escape_rfc4180

def escape_latex(os: 'ostream', str: 'std::string const &') -> "std::ostream &":
    return _impl.escape_latex(os, str)
escape_latex = _impl.escape_latex

def escape_html(os: 'ostream', str: 'std::string const &') -> "std::ostream &":
    return _impl.escape_html(os, str)
escape_html = _impl.escape_html

def escape_str(*args) -> "std::string":
    return _impl.escape_str(*args)
escape_str = _impl.escape_str

def quote_shell_string(os: 'ostream', str: 'char const *') -> "std::ostream &":
    return _impl.quote_shell_string(os, str)
quote_shell_string = _impl.quote_shell_string
class trival(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    no_value = _impl.trival_no_value
    maybe_value = _impl.trival_maybe_value
    yes_value = _impl.trival_yes_value

    def __init__(self, *args):
        _impl.trival_swiginit(self, _impl.new_trival(*args))
    maybe = staticmethod(_impl.trival_maybe)

    def is_known(self) -> "bool":
        return _impl.trival_is_known(self)

    def is_maybe(self) -> "bool":
        return _impl.trival_is_maybe(self)

    def is_true(self) -> "bool":
        return _impl.trival_is_true(self)

    def is_false(self) -> "bool":
        return _impl.trival_is_false(self)

    def __eq__(self, o: 'trival') -> "bool":
        return _impl.trival___eq__(self, o)

    def __ne__(self, o: 'trival') -> "bool":
        return _impl.trival___ne__(self, o)

    def val(self) -> "spot::trival::value_t":
        return _impl.trival_val(self)

    def __nonzero__(self):
        return _impl.trival___nonzero__(self)
    __bool__ = __nonzero__



    def __repr__(self) -> "std::string":
        return _impl.trival___repr__(self)

    def __str__(self) -> "std::string":
        return _impl.trival___str__(self)

    def __neg__(self) -> "spot::trival":
        return _impl.trival___neg__(self)

    def __and__(self, other: 'trival') -> "spot::trival":
        return _impl.trival___and__(self, other)

    def __or__(self, other: 'trival') -> "spot::trival":
        return _impl.trival___or__(self, other)
    __swig_destroy__ = _impl.delete_trival
trival_swigregister = _impl.trival_swigregister
trival_swigregister(trival)

def trival_maybe() -> "spot::trival":
    return _impl.trival_maybe()
trival_maybe = _impl.trival_maybe


def __eq__(a: 'bool', b: 'trival') -> "bool":
    return _impl.__eq__(a, b)
__eq__ = _impl.__eq__

def __ne__(a: 'bool', b: 'trival') -> "bool":
    return _impl.__ne__(a, b)
__ne__ = _impl.__ne__
op_ff = _impl.op_ff
op_tt = _impl.op_tt
op_eword = _impl.op_eword
op_ap = _impl.op_ap
op_Not = _impl.op_Not
op_X = _impl.op_X
op_F = _impl.op_F
op_G = _impl.op_G
op_Closure = _impl.op_Closure
op_NegClosure = _impl.op_NegClosure
op_NegClosureMarked = _impl.op_NegClosureMarked
op_Xor = _impl.op_Xor
op_Implies = _impl.op_Implies
op_Equiv = _impl.op_Equiv
op_U = _impl.op_U
op_R = _impl.op_R
op_W = _impl.op_W
op_M = _impl.op_M
op_EConcat = _impl.op_EConcat
op_EConcatMarked = _impl.op_EConcatMarked
op_UConcat = _impl.op_UConcat
op_Or = _impl.op_Or
op_OrRat = _impl.op_OrRat
op_And = _impl.op_And
op_AndRat = _impl.op_AndRat
op_AndNLM = _impl.op_AndNLM
op_Concat = _impl.op_Concat
op_Fusion = _impl.op_Fusion
op_Star = _impl.op_Star
op_FStar = _impl.op_FStar
class formula(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args):
        _impl.formula_swiginit(self, _impl.new_formula(*args))
    __swig_destroy__ = _impl.delete_formula

    def __lt__(self, other: 'formula') -> "bool":
        return _impl.formula___lt__(self, other)

    def __le__(self, other: 'formula') -> "bool":
        return _impl.formula___le__(self, other)

    def __gt__(self, other: 'formula') -> "bool":
        return _impl.formula___gt__(self, other)

    def __ge__(self, other: 'formula') -> "bool":
        return _impl.formula___ge__(self, other)

    def __eq__(self, *args) -> "bool":
        return _impl.formula___eq__(self, *args)

    def __ne__(self, *args) -> "bool":
        return _impl.formula___ne__(self, *args)

    def __nonzero__(self):
        return _impl.formula___nonzero__(self)
    __bool__ = __nonzero__


    unbounded = staticmethod(_impl.formula_unbounded)
    ap = staticmethod(_impl.formula_ap)
    unop = staticmethod(_impl.formula_unop)
    Not = staticmethod(_impl.formula_Not)
    X = staticmethod(_impl.formula_X)
    F = staticmethod(_impl.formula_F)
    G = staticmethod(_impl.formula_G)
    Closure = staticmethod(_impl.formula_Closure)
    NegClosure = staticmethod(_impl.formula_NegClosure)
    NegClosureMarked = staticmethod(_impl.formula_NegClosureMarked)
    binop = staticmethod(_impl.formula_binop)
    Xor = staticmethod(_impl.formula_Xor)
    Implies = staticmethod(_impl.formula_Implies)
    Equiv = staticmethod(_impl.formula_Equiv)
    U = staticmethod(_impl.formula_U)
    R = staticmethod(_impl.formula_R)
    W = staticmethod(_impl.formula_W)
    M = staticmethod(_impl.formula_M)
    EConcat = staticmethod(_impl.formula_EConcat)
    EConcatMarked = staticmethod(_impl.formula_EConcatMarked)
    UConcat = staticmethod(_impl.formula_UConcat)
    multop = staticmethod(_impl.formula_multop)
    Or = staticmethod(_impl.formula_Or)
    OrRat = staticmethod(_impl.formula_OrRat)
    And = staticmethod(_impl.formula_And)
    AndRat = staticmethod(_impl.formula_AndRat)
    AndNLM = staticmethod(_impl.formula_AndNLM)
    Concat = staticmethod(_impl.formula_Concat)
    Fusion = staticmethod(_impl.formula_Fusion)
    bunop = staticmethod(_impl.formula_bunop)
    Star = staticmethod(_impl.formula_Star)
    FStar = staticmethod(_impl.formula_FStar)
    sugar_goto = staticmethod(_impl.formula_sugar_goto)
    sugar_equal = staticmethod(_impl.formula_sugar_equal)

    def kind(self) -> "spot::op":
        return _impl.formula_kind(self)

    def kindstr(self) -> "std::string":
        return _impl.formula_kindstr(self)

    def _is(self, o: 'spot::op') -> "bool":
        return _impl.formula__is(self, o)

    def get_child_of(self, o: 'spot::op') -> "spot::formula":
        return _impl.formula_get_child_of(self, o)

    def min(self) -> "unsigned int":
        return _impl.formula_min(self)

    def max(self) -> "unsigned int":
        return _impl.formula_max(self)

    def size(self) -> "unsigned int":
        return _impl.formula_size(self)

    def is_leaf(self) -> "bool":
        return _impl.formula_is_leaf(self)

    def id(self) -> "size_t":
        return _impl.formula_id(self)
    ff = staticmethod(_impl.formula_ff)

    def is_ff(self) -> "bool":
        return _impl.formula_is_ff(self)
    tt = staticmethod(_impl.formula_tt)

    def is_tt(self) -> "bool":
        return _impl.formula_is_tt(self)
    eword = staticmethod(_impl.formula_eword)

    def is_eword(self) -> "bool":
        return _impl.formula_is_eword(self)

    def is_constant(self) -> "bool":
        return _impl.formula_is_constant(self)

    def is_Kleene_star(self) -> "bool":
        return _impl.formula_is_Kleene_star(self)
    one_star = staticmethod(_impl.formula_one_star)

    def is_literal(self) -> "bool":
        return _impl.formula_is_literal(self)

    def ap_name(self) -> "std::string const &":
        return _impl.formula_ap_name(self)

    def dump(self, os: 'ostream') -> "std::ostream &":
        return _impl.formula_dump(self, os)

    def all_but(self, i: 'unsigned int') -> "spot::formula":
        return _impl.formula_all_but(self, i)

    def boolean_count(self) -> "unsigned int":
        return _impl.formula_boolean_count(self)

    def boolean_operands(self, width: 'unsigned int *'=None) -> "spot::formula":
        return _impl.formula_boolean_operands(self, width)

    def is_boolean(self) -> "bool":
        return _impl.formula_is_boolean(self)

    def is_sugar_free_boolean(self) -> "bool":
        return _impl.formula_is_sugar_free_boolean(self)

    def is_in_nenoform(self) -> "bool":
        return _impl.formula_is_in_nenoform(self)

    def is_syntactic_stutter_invariant(self) -> "bool":
        return _impl.formula_is_syntactic_stutter_invariant(self)

    def is_sugar_free_ltl(self) -> "bool":
        return _impl.formula_is_sugar_free_ltl(self)

    def is_ltl_formula(self) -> "bool":
        return _impl.formula_is_ltl_formula(self)

    def is_psl_formula(self) -> "bool":
        return _impl.formula_is_psl_formula(self)

    def is_sere_formula(self) -> "bool":
        return _impl.formula_is_sere_formula(self)

    def is_finite(self) -> "bool":
        return _impl.formula_is_finite(self)

    def is_eventual(self) -> "bool":
        return _impl.formula_is_eventual(self)

    def is_universal(self) -> "bool":
        return _impl.formula_is_universal(self)

    def is_syntactic_safety(self) -> "bool":
        return _impl.formula_is_syntactic_safety(self)

    def is_syntactic_guarantee(self) -> "bool":
        return _impl.formula_is_syntactic_guarantee(self)

    def is_syntactic_obligation(self) -> "bool":
        return _impl.formula_is_syntactic_obligation(self)

    def is_syntactic_recurrence(self) -> "bool":
        return _impl.formula_is_syntactic_recurrence(self)

    def is_syntactic_persistence(self) -> "bool":
        return _impl.formula_is_syntactic_persistence(self)

    def is_marked(self) -> "bool":
        return _impl.formula_is_marked(self)

    def accepts_eword(self) -> "bool":
        return _impl.formula_accepts_eword(self)

    def has_lbt_atomic_props(self) -> "bool":
        return _impl.formula_has_lbt_atomic_props(self)

    def has_spin_atomic_props(self) -> "bool":
        return _impl.formula_has_spin_atomic_props(self)

    def __cmp__(self, b: 'formula') -> "int":
        return _impl.formula___cmp__(self, b)

    def __hash__(self) -> "size_t":
        return _impl.formula___hash__(self)

    def __len__(self) -> "unsigned int":
        return _impl.formula___len__(self)

    def __getitem__(self, pos: 'unsigned int') -> "spot::formula":
        return _impl.formula___getitem__(self, pos)

    def __repr__(self) -> "std::string":
        return _impl.formula___repr__(self)

    def _repr_latex_(self) -> "std::string":
        return _impl.formula__repr_latex_(self)

    def __str__(self) -> "std::string":
        return _impl.formula___str__(self)
formula_swigregister = _impl.formula_swigregister
formula_swigregister(formula)

def formula_unbounded() -> "uint8_t":
    return _impl.formula_unbounded()
formula_unbounded = _impl.formula_unbounded

def formula_ap(*args) -> "spot::formula":
    return _impl.formula_ap(*args)
formula_ap = _impl.formula_ap

def formula_unop(o: 'spot::op', f: 'formula') -> "spot::formula":
    return _impl.formula_unop(o, f)
formula_unop = _impl.formula_unop

def formula_Not(f: 'formula') -> "spot::formula":
    return _impl.formula_Not(f)
formula_Not = _impl.formula_Not

def formula_X(f: 'formula') -> "spot::formula":
    return _impl.formula_X(f)
formula_X = _impl.formula_X

def formula_F(f: 'formula') -> "spot::formula":
    return _impl.formula_F(f)
formula_F = _impl.formula_F

def formula_G(f: 'formula') -> "spot::formula":
    return _impl.formula_G(f)
formula_G = _impl.formula_G

def formula_Closure(f: 'formula') -> "spot::formula":
    return _impl.formula_Closure(f)
formula_Closure = _impl.formula_Closure

def formula_NegClosure(f: 'formula') -> "spot::formula":
    return _impl.formula_NegClosure(f)
formula_NegClosure = _impl.formula_NegClosure

def formula_NegClosureMarked(f: 'formula') -> "spot::formula":
    return _impl.formula_NegClosureMarked(f)
formula_NegClosureMarked = _impl.formula_NegClosureMarked

def formula_binop(o: 'spot::op', f: 'formula', g: 'formula') -> "spot::formula":
    return _impl.formula_binop(o, f, g)
formula_binop = _impl.formula_binop

def formula_Xor(f: 'formula', g: 'formula') -> "spot::formula":
    return _impl.formula_Xor(f, g)
formula_Xor = _impl.formula_Xor

def formula_Implies(f: 'formula', g: 'formula') -> "spot::formula":
    return _impl.formula_Implies(f, g)
formula_Implies = _impl.formula_Implies

def formula_Equiv(f: 'formula', g: 'formula') -> "spot::formula":
    return _impl.formula_Equiv(f, g)
formula_Equiv = _impl.formula_Equiv

def formula_U(f: 'formula', g: 'formula') -> "spot::formula":
    return _impl.formula_U(f, g)
formula_U = _impl.formula_U

def formula_R(f: 'formula', g: 'formula') -> "spot::formula":
    return _impl.formula_R(f, g)
formula_R = _impl.formula_R

def formula_W(f: 'formula', g: 'formula') -> "spot::formula":
    return _impl.formula_W(f, g)
formula_W = _impl.formula_W

def formula_M(f: 'formula', g: 'formula') -> "spot::formula":
    return _impl.formula_M(f, g)
formula_M = _impl.formula_M

def formula_EConcat(f: 'formula', g: 'formula') -> "spot::formula":
    return _impl.formula_EConcat(f, g)
formula_EConcat = _impl.formula_EConcat

def formula_EConcatMarked(f: 'formula', g: 'formula') -> "spot::formula":
    return _impl.formula_EConcatMarked(f, g)
formula_EConcatMarked = _impl.formula_EConcatMarked

def formula_UConcat(f: 'formula', g: 'formula') -> "spot::formula":
    return _impl.formula_UConcat(f, g)
formula_UConcat = _impl.formula_UConcat

def formula_multop(o: 'spot::op', l: 'vectorformula') -> "spot::formula":
    return _impl.formula_multop(o, l)
formula_multop = _impl.formula_multop

def formula_Or(l: 'vectorformula') -> "spot::formula":
    return _impl.formula_Or(l)
formula_Or = _impl.formula_Or

def formula_OrRat(l: 'vectorformula') -> "spot::formula":
    return _impl.formula_OrRat(l)
formula_OrRat = _impl.formula_OrRat

def formula_And(l: 'vectorformula') -> "spot::formula":
    return _impl.formula_And(l)
formula_And = _impl.formula_And

def formula_AndRat(l: 'vectorformula') -> "spot::formula":
    return _impl.formula_AndRat(l)
formula_AndRat = _impl.formula_AndRat

def formula_AndNLM(l: 'vectorformula') -> "spot::formula":
    return _impl.formula_AndNLM(l)
formula_AndNLM = _impl.formula_AndNLM

def formula_Concat(l: 'vectorformula') -> "spot::formula":
    return _impl.formula_Concat(l)
formula_Concat = _impl.formula_Concat

def formula_Fusion(l: 'vectorformula') -> "spot::formula":
    return _impl.formula_Fusion(l)
formula_Fusion = _impl.formula_Fusion

def formula_bunop(*args) -> "spot::formula":
    return _impl.formula_bunop(*args)
formula_bunop = _impl.formula_bunop

def formula_Star(*args) -> "spot::formula":
    return _impl.formula_Star(*args)
formula_Star = _impl.formula_Star

def formula_FStar(*args) -> "spot::formula":
    return _impl.formula_FStar(*args)
formula_FStar = _impl.formula_FStar

def formula_sugar_goto(b: 'formula', min: 'uint8_t', max: 'uint8_t') -> "spot::formula":
    return _impl.formula_sugar_goto(b, min, max)
formula_sugar_goto = _impl.formula_sugar_goto

def formula_sugar_equal(b: 'formula', min: 'uint8_t', max: 'uint8_t') -> "spot::formula":
    return _impl.formula_sugar_equal(b, min, max)
formula_sugar_equal = _impl.formula_sugar_equal

def formula_ff() -> "spot::formula":
    return _impl.formula_ff()
formula_ff = _impl.formula_ff

def formula_tt() -> "spot::formula":
    return _impl.formula_tt()
formula_tt = _impl.formula_tt

def formula_eword() -> "spot::formula":
    return _impl.formula_eword()
formula_eword = _impl.formula_eword

def formula_one_star() -> "spot::formula":
    return _impl.formula_one_star()
formula_one_star = _impl.formula_one_star


def print_formula_props(out: 'ostream', f: 'formula', abbreviated: 'bool'=False) -> "std::ostream &":
    return _impl.print_formula_props(out, f, abbreviated)
print_formula_props = _impl.print_formula_props

def list_formula_props(f: 'formula') -> "std::list< std::string,std::allocator< std::string > >":
    return _impl.list_formula_props(f)
list_formula_props = _impl.list_formula_props
class liststr(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _impl.liststr_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _impl.liststr___nonzero__(self)

    def __bool__(self) -> "bool":
        return _impl.liststr___bool__(self)

    def __len__(self) -> "std::list< std::string >::size_type":
        return _impl.liststr___len__(self)

    def __getslice__(self, i: 'std::list< std::string >::difference_type', j: 'std::list< std::string >::difference_type') -> "std::list< std::string,std::allocator< std::string > > *":
        return _impl.liststr___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _impl.liststr___setslice__(self, *args)

    def __delslice__(self, i: 'std::list< std::string >::difference_type', j: 'std::list< std::string >::difference_type') -> "void":
        return _impl.liststr___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _impl.liststr___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::list< std::string >::value_type const &":
        return _impl.liststr___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _impl.liststr___setitem__(self, *args)

    def pop(self) -> "std::list< std::string >::value_type":
        return _impl.liststr_pop(self)

    def append(self, x: 'std::list< std::string >::value_type const &') -> "void":
        return _impl.liststr_append(self, x)

    def empty(self) -> "bool":
        return _impl.liststr_empty(self)

    def size(self) -> "std::list< std::string >::size_type":
        return _impl.liststr_size(self)

    def swap(self, v: 'liststr') -> "void":
        return _impl.liststr_swap(self, v)

    def begin(self) -> "std::list< std::string >::iterator":
        return _impl.liststr_begin(self)

    def end(self) -> "std::list< std::string >::iterator":
        return _impl.liststr_end(self)

    def rbegin(self) -> "std::list< std::string >::reverse_iterator":
        return _impl.liststr_rbegin(self)

    def rend(self) -> "std::list< std::string >::reverse_iterator":
        return _impl.liststr_rend(self)

    def clear(self) -> "void":
        return _impl.liststr_clear(self)

    def get_allocator(self) -> "std::list< std::string >::allocator_type":
        return _impl.liststr_get_allocator(self)

    def pop_back(self) -> "void":
        return _impl.liststr_pop_back(self)

    def erase(self, *args) -> "std::list< std::string >::iterator":
        return _impl.liststr_erase(self, *args)

    def __init__(self, *args):
        _impl.liststr_swiginit(self, _impl.new_liststr(*args))

    def push_back(self, x: 'std::list< std::string >::value_type const &') -> "void":
        return _impl.liststr_push_back(self, x)

    def front(self) -> "std::list< std::string >::value_type const &":
        return _impl.liststr_front(self)

    def back(self) -> "std::list< std::string >::value_type const &":
        return _impl.liststr_back(self)

    def assign(self, n: 'std::list< std::string >::size_type', x: 'std::list< std::string >::value_type const &') -> "void":
        return _impl.liststr_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _impl.liststr_resize(self, *args)

    def insert(self, *args) -> "void":
        return _impl.liststr_insert(self, *args)

    def pop_front(self) -> "void":
        return _impl.liststr_pop_front(self)

    def push_front(self, x: 'std::list< std::string >::value_type const &') -> "void":
        return _impl.liststr_push_front(self, x)

    def reverse(self) -> "void":
        return _impl.liststr_reverse(self)
    __swig_destroy__ = _impl.delete_liststr
liststr_swigregister = _impl.liststr_swigregister
liststr_swigregister(liststr)

class pairunsigned(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _impl.pairunsigned_swiginit(self, _impl.new_pairunsigned(*args))
    first = _swig_property(_impl.pairunsigned_first_get, _impl.pairunsigned_first_set)
    second = _swig_property(_impl.pairunsigned_second_get, _impl.pairunsigned_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _impl.delete_pairunsigned
pairunsigned_swigregister = _impl.pairunsigned_swigregister
pairunsigned_swigregister(pairunsigned)

class vectorformula(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _impl.vectorformula_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _impl.vectorformula___nonzero__(self)

    def __bool__(self) -> "bool":
        return _impl.vectorformula___bool__(self)

    def __len__(self) -> "std::vector< spot::formula >::size_type":
        return _impl.vectorformula___len__(self)

    def __getslice__(self, i: 'std::vector< spot::formula >::difference_type', j: 'std::vector< spot::formula >::difference_type') -> "std::vector< spot::formula,std::allocator< spot::formula > > *":
        return _impl.vectorformula___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _impl.vectorformula___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< spot::formula >::difference_type', j: 'std::vector< spot::formula >::difference_type') -> "void":
        return _impl.vectorformula___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _impl.vectorformula___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< spot::formula >::value_type const &":
        return _impl.vectorformula___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _impl.vectorformula___setitem__(self, *args)

    def pop(self) -> "std::vector< spot::formula >::value_type":
        return _impl.vectorformula_pop(self)

    def append(self, x: 'formula') -> "void":
        return _impl.vectorformula_append(self, x)

    def empty(self) -> "bool":
        return _impl.vectorformula_empty(self)

    def size(self) -> "std::vector< spot::formula >::size_type":
        return _impl.vectorformula_size(self)

    def swap(self, v: 'vectorformula') -> "void":
        return _impl.vectorformula_swap(self, v)

    def begin(self) -> "std::vector< spot::formula >::iterator":
        return _impl.vectorformula_begin(self)

    def end(self) -> "std::vector< spot::formula >::iterator":
        return _impl.vectorformula_end(self)

    def rbegin(self) -> "std::vector< spot::formula >::reverse_iterator":
        return _impl.vectorformula_rbegin(self)

    def rend(self) -> "std::vector< spot::formula >::reverse_iterator":
        return _impl.vectorformula_rend(self)

    def clear(self) -> "void":
        return _impl.vectorformula_clear(self)

    def get_allocator(self) -> "std::vector< spot::formula >::allocator_type":
        return _impl.vectorformula_get_allocator(self)

    def pop_back(self) -> "void":
        return _impl.vectorformula_pop_back(self)

    def erase(self, *args) -> "std::vector< spot::formula >::iterator":
        return _impl.vectorformula_erase(self, *args)

    def __init__(self, *args):
        _impl.vectorformula_swiginit(self, _impl.new_vectorformula(*args))

    def push_back(self, x: 'formula') -> "void":
        return _impl.vectorformula_push_back(self, x)

    def front(self) -> "std::vector< spot::formula >::value_type const &":
        return _impl.vectorformula_front(self)

    def back(self) -> "std::vector< spot::formula >::value_type const &":
        return _impl.vectorformula_back(self)

    def assign(self, n: 'std::vector< spot::formula >::size_type', x: 'formula') -> "void":
        return _impl.vectorformula_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _impl.vectorformula_resize(self, *args)

    def insert(self, *args) -> "void":
        return _impl.vectorformula_insert(self, *args)

    def reserve(self, n: 'std::vector< spot::formula >::size_type') -> "void":
        return _impl.vectorformula_reserve(self, n)

    def capacity(self) -> "std::vector< spot::formula >::size_type":
        return _impl.vectorformula_capacity(self)
    __swig_destroy__ = _impl.delete_vectorformula
vectorformula_swigregister = _impl.vectorformula_swigregister
vectorformula_swigregister(vectorformula)

class vectorunsigned(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _impl.vectorunsigned_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _impl.vectorunsigned___nonzero__(self)

    def __bool__(self) -> "bool":
        return _impl.vectorunsigned___bool__(self)

    def __len__(self) -> "std::vector< unsigned int >::size_type":
        return _impl.vectorunsigned___len__(self)

    def __getslice__(self, i: 'std::vector< unsigned int >::difference_type', j: 'std::vector< unsigned int >::difference_type') -> "std::vector< unsigned int,std::allocator< unsigned int > > *":
        return _impl.vectorunsigned___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _impl.vectorunsigned___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< unsigned int >::difference_type', j: 'std::vector< unsigned int >::difference_type') -> "void":
        return _impl.vectorunsigned___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _impl.vectorunsigned___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< unsigned int >::value_type const &":
        return _impl.vectorunsigned___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _impl.vectorunsigned___setitem__(self, *args)

    def pop(self) -> "std::vector< unsigned int >::value_type":
        return _impl.vectorunsigned_pop(self)

    def append(self, x: 'std::vector< unsigned int >::value_type const &') -> "void":
        return _impl.vectorunsigned_append(self, x)

    def empty(self) -> "bool":
        return _impl.vectorunsigned_empty(self)

    def size(self) -> "std::vector< unsigned int >::size_type":
        return _impl.vectorunsigned_size(self)

    def swap(self, v: 'vectorunsigned') -> "void":
        return _impl.vectorunsigned_swap(self, v)

    def begin(self) -> "std::vector< unsigned int >::iterator":
        return _impl.vectorunsigned_begin(self)

    def end(self) -> "std::vector< unsigned int >::iterator":
        return _impl.vectorunsigned_end(self)

    def rbegin(self) -> "std::vector< unsigned int >::reverse_iterator":
        return _impl.vectorunsigned_rbegin(self)

    def rend(self) -> "std::vector< unsigned int >::reverse_iterator":
        return _impl.vectorunsigned_rend(self)

    def clear(self) -> "void":
        return _impl.vectorunsigned_clear(self)

    def get_allocator(self) -> "std::vector< unsigned int >::allocator_type":
        return _impl.vectorunsigned_get_allocator(self)

    def pop_back(self) -> "void":
        return _impl.vectorunsigned_pop_back(self)

    def erase(self, *args) -> "std::vector< unsigned int >::iterator":
        return _impl.vectorunsigned_erase(self, *args)

    def __init__(self, *args):
        _impl.vectorunsigned_swiginit(self, _impl.new_vectorunsigned(*args))

    def push_back(self, x: 'std::vector< unsigned int >::value_type const &') -> "void":
        return _impl.vectorunsigned_push_back(self, x)

    def front(self) -> "std::vector< unsigned int >::value_type const &":
        return _impl.vectorunsigned_front(self)

    def back(self) -> "std::vector< unsigned int >::value_type const &":
        return _impl.vectorunsigned_back(self)

    def assign(self, n: 'std::vector< unsigned int >::size_type', x: 'std::vector< unsigned int >::value_type const &') -> "void":
        return _impl.vectorunsigned_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _impl.vectorunsigned_resize(self, *args)

    def insert(self, *args) -> "void":
        return _impl.vectorunsigned_insert(self, *args)

    def reserve(self, n: 'std::vector< unsigned int >::size_type') -> "void":
        return _impl.vectorunsigned_reserve(self, n)

    def capacity(self) -> "std::vector< unsigned int >::size_type":
        return _impl.vectorunsigned_capacity(self)
    __swig_destroy__ = _impl.delete_vectorunsigned
vectorunsigned_swigregister = _impl.vectorunsigned_swigregister
vectorunsigned_swigregister(vectorunsigned)

class vectorpairunsigned(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _impl.vectorpairunsigned_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _impl.vectorpairunsigned___nonzero__(self)

    def __bool__(self) -> "bool":
        return _impl.vectorpairunsigned___bool__(self)

    def __len__(self) -> "std::vector< std::pair< unsigned int,unsigned int > >::size_type":
        return _impl.vectorpairunsigned___len__(self)

    def __getslice__(self, i: 'std::vector< std::pair< unsigned int,unsigned int > >::difference_type', j: 'std::vector< std::pair< unsigned int,unsigned int > >::difference_type') -> "std::vector< std::pair< unsigned int,unsigned int >,std::allocator< std::pair< unsigned int,unsigned int > > > *":
        return _impl.vectorpairunsigned___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _impl.vectorpairunsigned___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< std::pair< unsigned int,unsigned int > >::difference_type', j: 'std::vector< std::pair< unsigned int,unsigned int > >::difference_type') -> "void":
        return _impl.vectorpairunsigned___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _impl.vectorpairunsigned___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::pair< unsigned int,unsigned int > >::value_type const &":
        return _impl.vectorpairunsigned___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _impl.vectorpairunsigned___setitem__(self, *args)

    def pop(self) -> "std::vector< std::pair< unsigned int,unsigned int > >::value_type":
        return _impl.vectorpairunsigned_pop(self)

    def append(self, x: 'pairunsigned') -> "void":
        return _impl.vectorpairunsigned_append(self, x)

    def empty(self) -> "bool":
        return _impl.vectorpairunsigned_empty(self)

    def size(self) -> "std::vector< std::pair< unsigned int,unsigned int > >::size_type":
        return _impl.vectorpairunsigned_size(self)

    def swap(self, v: 'vectorpairunsigned') -> "void":
        return _impl.vectorpairunsigned_swap(self, v)

    def begin(self) -> "std::vector< std::pair< unsigned int,unsigned int > >::iterator":
        return _impl.vectorpairunsigned_begin(self)

    def end(self) -> "std::vector< std::pair< unsigned int,unsigned int > >::iterator":
        return _impl.vectorpairunsigned_end(self)

    def rbegin(self) -> "std::vector< std::pair< unsigned int,unsigned int > >::reverse_iterator":
        return _impl.vectorpairunsigned_rbegin(self)

    def rend(self) -> "std::vector< std::pair< unsigned int,unsigned int > >::reverse_iterator":
        return _impl.vectorpairunsigned_rend(self)

    def clear(self) -> "void":
        return _impl.vectorpairunsigned_clear(self)

    def get_allocator(self) -> "std::vector< std::pair< unsigned int,unsigned int > >::allocator_type":
        return _impl.vectorpairunsigned_get_allocator(self)

    def pop_back(self) -> "void":
        return _impl.vectorpairunsigned_pop_back(self)

    def erase(self, *args) -> "std::vector< std::pair< unsigned int,unsigned int > >::iterator":
        return _impl.vectorpairunsigned_erase(self, *args)

    def __init__(self, *args):
        _impl.vectorpairunsigned_swiginit(self, _impl.new_vectorpairunsigned(*args))

    def push_back(self, x: 'pairunsigned') -> "void":
        return _impl.vectorpairunsigned_push_back(self, x)

    def front(self) -> "std::vector< std::pair< unsigned int,unsigned int > >::value_type const &":
        return _impl.vectorpairunsigned_front(self)

    def back(self) -> "std::vector< std::pair< unsigned int,unsigned int > >::value_type const &":
        return _impl.vectorpairunsigned_back(self)

    def assign(self, n: 'std::vector< std::pair< unsigned int,unsigned int > >::size_type', x: 'pairunsigned') -> "void":
        return _impl.vectorpairunsigned_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _impl.vectorpairunsigned_resize(self, *args)

    def insert(self, *args) -> "void":
        return _impl.vectorpairunsigned_insert(self, *args)

    def reserve(self, n: 'std::vector< std::pair< unsigned int,unsigned int > >::size_type') -> "void":
        return _impl.vectorpairunsigned_reserve(self, n)

    def capacity(self) -> "std::vector< std::pair< unsigned int,unsigned int > >::size_type":
        return _impl.vectorpairunsigned_capacity(self)
    __swig_destroy__ = _impl.delete_vectorpairunsigned
vectorpairunsigned_swigregister = _impl.vectorpairunsigned_swigregister
vectorpairunsigned_swigregister(vectorpairunsigned)

class vectorbool(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _impl.vectorbool_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _impl.vectorbool___nonzero__(self)

    def __bool__(self) -> "bool":
        return _impl.vectorbool___bool__(self)

    def __len__(self) -> "std::vector< bool >::size_type":
        return _impl.vectorbool___len__(self)

    def __getslice__(self, i: 'std::vector< bool >::difference_type', j: 'std::vector< bool >::difference_type') -> "std::vector< bool,std::allocator< bool > > *":
        return _impl.vectorbool___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _impl.vectorbool___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< bool >::difference_type', j: 'std::vector< bool >::difference_type') -> "void":
        return _impl.vectorbool___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _impl.vectorbool___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< bool >::value_type":
        return _impl.vectorbool___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _impl.vectorbool___setitem__(self, *args)

    def pop(self) -> "std::vector< bool >::value_type":
        return _impl.vectorbool_pop(self)

    def append(self, x: 'std::vector< bool >::value_type') -> "void":
        return _impl.vectorbool_append(self, x)

    def empty(self) -> "bool":
        return _impl.vectorbool_empty(self)

    def size(self) -> "std::vector< bool >::size_type":
        return _impl.vectorbool_size(self)

    def swap(self, v: 'vectorbool') -> "void":
        return _impl.vectorbool_swap(self, v)

    def begin(self) -> "std::vector< bool >::iterator":
        return _impl.vectorbool_begin(self)

    def end(self) -> "std::vector< bool >::iterator":
        return _impl.vectorbool_end(self)

    def rbegin(self) -> "std::vector< bool >::reverse_iterator":
        return _impl.vectorbool_rbegin(self)

    def rend(self) -> "std::vector< bool >::reverse_iterator":
        return _impl.vectorbool_rend(self)

    def clear(self) -> "void":
        return _impl.vectorbool_clear(self)

    def get_allocator(self) -> "std::vector< bool >::allocator_type":
        return _impl.vectorbool_get_allocator(self)

    def pop_back(self) -> "void":
        return _impl.vectorbool_pop_back(self)

    def erase(self, *args) -> "std::vector< bool >::iterator":
        return _impl.vectorbool_erase(self, *args)

    def __init__(self, *args):
        _impl.vectorbool_swiginit(self, _impl.new_vectorbool(*args))

    def push_back(self, x: 'std::vector< bool >::value_type') -> "void":
        return _impl.vectorbool_push_back(self, x)

    def front(self) -> "std::vector< bool >::value_type":
        return _impl.vectorbool_front(self)

    def back(self) -> "std::vector< bool >::value_type":
        return _impl.vectorbool_back(self)

    def assign(self, n: 'std::vector< bool >::size_type', x: 'std::vector< bool >::value_type') -> "void":
        return _impl.vectorbool_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _impl.vectorbool_resize(self, *args)

    def insert(self, *args) -> "void":
        return _impl.vectorbool_insert(self, *args)

    def reserve(self, n: 'std::vector< bool >::size_type') -> "void":
        return _impl.vectorbool_reserve(self, n)

    def capacity(self) -> "std::vector< bool >::size_type":
        return _impl.vectorbool_capacity(self)
    __swig_destroy__ = _impl.delete_vectorbool
vectorbool_swigregister = _impl.vectorbool_swigregister
vectorbool_swigregister(vectorbool)

class vectorbdd(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _impl.vectorbdd_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _impl.vectorbdd___nonzero__(self)

    def __bool__(self) -> "bool":
        return _impl.vectorbdd___bool__(self)

    def __len__(self) -> "std::vector< bdd >::size_type":
        return _impl.vectorbdd___len__(self)

    def __getslice__(self, i: 'std::vector< bdd >::difference_type', j: 'std::vector< bdd >::difference_type') -> "std::vector< bdd,std::allocator< bdd > > *":
        return _impl.vectorbdd___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _impl.vectorbdd___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< bdd >::difference_type', j: 'std::vector< bdd >::difference_type') -> "void":
        return _impl.vectorbdd___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _impl.vectorbdd___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< bdd >::value_type const &":
        return _impl.vectorbdd___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _impl.vectorbdd___setitem__(self, *args)

    def pop(self) -> "std::vector< bdd >::value_type":
        return _impl.vectorbdd_pop(self)

    def append(self, x: 'bdd') -> "void":
        return _impl.vectorbdd_append(self, x)

    def empty(self) -> "bool":
        return _impl.vectorbdd_empty(self)

    def size(self) -> "std::vector< bdd >::size_type":
        return _impl.vectorbdd_size(self)

    def swap(self, v: 'vectorbdd') -> "void":
        return _impl.vectorbdd_swap(self, v)

    def begin(self) -> "std::vector< bdd >::iterator":
        return _impl.vectorbdd_begin(self)

    def end(self) -> "std::vector< bdd >::iterator":
        return _impl.vectorbdd_end(self)

    def rbegin(self) -> "std::vector< bdd >::reverse_iterator":
        return _impl.vectorbdd_rbegin(self)

    def rend(self) -> "std::vector< bdd >::reverse_iterator":
        return _impl.vectorbdd_rend(self)

    def clear(self) -> "void":
        return _impl.vectorbdd_clear(self)

    def get_allocator(self) -> "std::vector< bdd >::allocator_type":
        return _impl.vectorbdd_get_allocator(self)

    def pop_back(self) -> "void":
        return _impl.vectorbdd_pop_back(self)

    def erase(self, *args) -> "std::vector< bdd >::iterator":
        return _impl.vectorbdd_erase(self, *args)

    def __init__(self, *args):
        _impl.vectorbdd_swiginit(self, _impl.new_vectorbdd(*args))

    def push_back(self, x: 'bdd') -> "void":
        return _impl.vectorbdd_push_back(self, x)

    def front(self) -> "std::vector< bdd >::value_type const &":
        return _impl.vectorbdd_front(self)

    def back(self) -> "std::vector< bdd >::value_type const &":
        return _impl.vectorbdd_back(self)

    def assign(self, n: 'std::vector< bdd >::size_type', x: 'bdd') -> "void":
        return _impl.vectorbdd_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _impl.vectorbdd_resize(self, *args)

    def insert(self, *args) -> "void":
        return _impl.vectorbdd_insert(self, *args)

    def reserve(self, n: 'std::vector< bdd >::size_type') -> "void":
        return _impl.vectorbdd_reserve(self, n)

    def capacity(self) -> "std::vector< bdd >::size_type":
        return _impl.vectorbdd_capacity(self)
    __swig_destroy__ = _impl.delete_vectorbdd
vectorbdd_swigregister = _impl.vectorbdd_swigregister
vectorbdd_swigregister(vectorbdd)

class vectorstring(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _impl.vectorstring_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _impl.vectorstring___nonzero__(self)

    def __bool__(self) -> "bool":
        return _impl.vectorstring___bool__(self)

    def __len__(self) -> "std::vector< std::string >::size_type":
        return _impl.vectorstring___len__(self)

    def __getslice__(self, i: 'std::vector< std::string >::difference_type', j: 'std::vector< std::string >::difference_type') -> "std::vector< std::string,std::allocator< std::string > > *":
        return _impl.vectorstring___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _impl.vectorstring___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< std::string >::difference_type', j: 'std::vector< std::string >::difference_type') -> "void":
        return _impl.vectorstring___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _impl.vectorstring___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::string >::value_type const &":
        return _impl.vectorstring___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _impl.vectorstring___setitem__(self, *args)

    def pop(self) -> "std::vector< std::string >::value_type":
        return _impl.vectorstring_pop(self)

    def append(self, x: 'std::vector< std::string >::value_type const &') -> "void":
        return _impl.vectorstring_append(self, x)

    def empty(self) -> "bool":
        return _impl.vectorstring_empty(self)

    def size(self) -> "std::vector< std::string >::size_type":
        return _impl.vectorstring_size(self)

    def swap(self, v: 'vectorstring') -> "void":
        return _impl.vectorstring_swap(self, v)

    def begin(self) -> "std::vector< std::string >::iterator":
        return _impl.vectorstring_begin(self)

    def end(self) -> "std::vector< std::string >::iterator":
        return _impl.vectorstring_end(self)

    def rbegin(self) -> "std::vector< std::string >::reverse_iterator":
        return _impl.vectorstring_rbegin(self)

    def rend(self) -> "std::vector< std::string >::reverse_iterator":
        return _impl.vectorstring_rend(self)

    def clear(self) -> "void":
        return _impl.vectorstring_clear(self)

    def get_allocator(self) -> "std::vector< std::string >::allocator_type":
        return _impl.vectorstring_get_allocator(self)

    def pop_back(self) -> "void":
        return _impl.vectorstring_pop_back(self)

    def erase(self, *args) -> "std::vector< std::string >::iterator":
        return _impl.vectorstring_erase(self, *args)

    def __init__(self, *args):
        _impl.vectorstring_swiginit(self, _impl.new_vectorstring(*args))

    def push_back(self, x: 'std::vector< std::string >::value_type const &') -> "void":
        return _impl.vectorstring_push_back(self, x)

    def front(self) -> "std::vector< std::string >::value_type const &":
        return _impl.vectorstring_front(self)

    def back(self) -> "std::vector< std::string >::value_type const &":
        return _impl.vectorstring_back(self)

    def assign(self, n: 'std::vector< std::string >::size_type', x: 'std::vector< std::string >::value_type const &') -> "void":
        return _impl.vectorstring_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _impl.vectorstring_resize(self, *args)

    def insert(self, *args) -> "void":
        return _impl.vectorstring_insert(self, *args)

    def reserve(self, n: 'std::vector< std::string >::size_type') -> "void":
        return _impl.vectorstring_reserve(self, n)

    def capacity(self) -> "std::vector< std::string >::size_type":
        return _impl.vectorstring_capacity(self)
    __swig_destroy__ = _impl.delete_vectorstring
vectorstring_swigregister = _impl.vectorstring_swigregister
vectorstring_swigregister(vectorstring)

class atomic_prop_set(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def iterator(self) -> "swig::SwigPyIterator *":
        return _impl.atomic_prop_set_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _impl.atomic_prop_set___nonzero__(self)

    def __bool__(self) -> "bool":
        return _impl.atomic_prop_set___bool__(self)

    def __len__(self) -> "std::set< spot::formula >::size_type":
        return _impl.atomic_prop_set___len__(self)

    def append(self, x: 'formula') -> "void":
        return _impl.atomic_prop_set_append(self, x)

    def __contains__(self, x: 'formula') -> "bool":
        return _impl.atomic_prop_set___contains__(self, x)

    def __getitem__(self, i: 'std::set< spot::formula >::difference_type') -> "std::set< spot::formula >::value_type":
        return _impl.atomic_prop_set___getitem__(self, i)

    def add(self, x: 'formula') -> "void":
        return _impl.atomic_prop_set_add(self, x)

    def discard(self, x: 'formula') -> "void":
        return _impl.atomic_prop_set_discard(self, x)

    def __init__(self, *args):
        _impl.atomic_prop_set_swiginit(self, _impl.new_atomic_prop_set(*args))

    def empty(self) -> "bool":
        return _impl.atomic_prop_set_empty(self)

    def size(self) -> "std::set< spot::formula >::size_type":
        return _impl.atomic_prop_set_size(self)

    def clear(self) -> "void":
        return _impl.atomic_prop_set_clear(self)

    def swap(self, v: 'atomic_prop_set') -> "void":
        return _impl.atomic_prop_set_swap(self, v)

    def count(self, x: 'formula') -> "std::set< spot::formula >::size_type":
        return _impl.atomic_prop_set_count(self, x)

    def begin(self) -> "std::set< spot::formula >::iterator":
        return _impl.atomic_prop_set_begin(self)

    def end(self) -> "std::set< spot::formula >::iterator":
        return _impl.atomic_prop_set_end(self)

    def rbegin(self) -> "std::set< spot::formula >::reverse_iterator":
        return _impl.atomic_prop_set_rbegin(self)

    def rend(self) -> "std::set< spot::formula >::reverse_iterator":
        return _impl.atomic_prop_set_rend(self)

    def erase(self, *args) -> "void":
        return _impl.atomic_prop_set_erase(self, *args)

    def find(self, x: 'formula') -> "std::set< spot::formula >::iterator":
        return _impl.atomic_prop_set_find(self, x)

    def lower_bound(self, x: 'formula') -> "std::set< spot::formula >::iterator":
        return _impl.atomic_prop_set_lower_bound(self, x)

    def upper_bound(self, x: 'formula') -> "std::set< spot::formula >::iterator":
        return _impl.atomic_prop_set_upper_bound(self, x)

    def equal_range(self, x: 'formula') -> "std::pair< std::set< spot::formula >::iterator,std::set< spot::formula >::iterator >":
        return _impl.atomic_prop_set_equal_range(self, x)

    def insert(self, __x: 'formula') -> "std::pair< std::set< spot::formula >::iterator,bool >":
        return _impl.atomic_prop_set_insert(self, __x)

    def __str__(self) -> "std::string":
        return _impl.atomic_prop_set___str__(self)

    def __repr__(self) -> "std::string":
        return _impl.atomic_prop_set___repr__(self)

    def _repr_latex_(self) -> "std::string":
        return _impl.atomic_prop_set__repr_latex_(self)
    __swig_destroy__ = _impl.delete_atomic_prop_set
atomic_prop_set_swigregister = _impl.atomic_prop_set_swigregister
atomic_prop_set_swigregister(atomic_prop_set)

class relabeling_map(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _impl.relabeling_map_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _impl.relabeling_map___nonzero__(self)

    def __bool__(self) -> "bool":
        return _impl.relabeling_map___bool__(self)

    def __len__(self) -> "std::map< spot::formula,spot::formula >::size_type":
        return _impl.relabeling_map___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key: 'formula') -> "std::map< spot::formula,spot::formula >::mapped_type const &":
        return _impl.relabeling_map___getitem__(self, key)

    def __delitem__(self, key: 'formula') -> "void":
        return _impl.relabeling_map___delitem__(self, key)

    def has_key(self, key: 'formula') -> "bool":
        return _impl.relabeling_map_has_key(self, key)

    def keys(self) -> "PyObject *":
        return _impl.relabeling_map_keys(self)

    def values(self) -> "PyObject *":
        return _impl.relabeling_map_values(self)

    def items(self) -> "PyObject *":
        return _impl.relabeling_map_items(self)

    def __contains__(self, key: 'formula') -> "bool":
        return _impl.relabeling_map___contains__(self, key)

    def key_iterator(self) -> "swig::SwigPyIterator *":
        return _impl.relabeling_map_key_iterator(self)

    def value_iterator(self) -> "swig::SwigPyIterator *":
        return _impl.relabeling_map_value_iterator(self)

    def __setitem__(self, *args) -> "void":
        return _impl.relabeling_map___setitem__(self, *args)

    def asdict(self) -> "PyObject *":
        return _impl.relabeling_map_asdict(self)

    def __init__(self, *args):
        _impl.relabeling_map_swiginit(self, _impl.new_relabeling_map(*args))

    def empty(self) -> "bool":
        return _impl.relabeling_map_empty(self)

    def size(self) -> "std::map< spot::formula,spot::formula >::size_type":
        return _impl.relabeling_map_size(self)

    def swap(self, v: 'relabeling_map') -> "void":
        return _impl.relabeling_map_swap(self, v)

    def begin(self) -> "std::map< spot::formula,spot::formula >::iterator":
        return _impl.relabeling_map_begin(self)

    def end(self) -> "std::map< spot::formula,spot::formula >::iterator":
        return _impl.relabeling_map_end(self)

    def rbegin(self) -> "std::map< spot::formula,spot::formula >::reverse_iterator":
        return _impl.relabeling_map_rbegin(self)

    def rend(self) -> "std::map< spot::formula,spot::formula >::reverse_iterator":
        return _impl.relabeling_map_rend(self)

    def clear(self) -> "void":
        return _impl.relabeling_map_clear(self)

    def get_allocator(self) -> "std::map< spot::formula,spot::formula >::allocator_type":
        return _impl.relabeling_map_get_allocator(self)

    def count(self, x: 'formula') -> "std::map< spot::formula,spot::formula >::size_type":
        return _impl.relabeling_map_count(self, x)

    def erase(self, *args) -> "void":
        return _impl.relabeling_map_erase(self, *args)

    def find(self, x: 'formula') -> "std::map< spot::formula,spot::formula >::iterator":
        return _impl.relabeling_map_find(self, x)

    def lower_bound(self, x: 'formula') -> "std::map< spot::formula,spot::formula >::iterator":
        return _impl.relabeling_map_lower_bound(self, x)

    def upper_bound(self, x: 'formula') -> "std::map< spot::formula,spot::formula >::iterator":
        return _impl.relabeling_map_upper_bound(self, x)
    __swig_destroy__ = _impl.delete_relabeling_map
relabeling_map_swigregister = _impl.relabeling_map_swigregister
relabeling_map_swigregister(relabeling_map)

class environment(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def require(self, prop_str: 'std::string const &') -> "spot::formula":
        return _impl.environment_require(self, prop_str)

    def name(self) -> "std::string const &":
        return _impl.environment_name(self)
    __swig_destroy__ = _impl.delete_environment
environment_swigregister = _impl.environment_swigregister
environment_swigregister(environment)

class declarative_environment(environment):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        _impl.declarative_environment_swiginit(self, _impl.new_declarative_environment())
    __swig_destroy__ = _impl.delete_declarative_environment

    def declare(self, prop_str: 'std::string const &') -> "bool":
        return _impl.declarative_environment_declare(self, prop_str)

    def get_prop_map(self) -> "spot::declarative_environment::prop_map const &":
        return _impl.declarative_environment_get_prop_map(self)
declarative_environment_swigregister = _impl.declarative_environment_swigregister
declarative_environment_swigregister(declarative_environment)

class default_environment(environment):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _impl.delete_default_environment
    instance = staticmethod(_impl.default_environment_instance)
default_environment_swigregister = _impl.default_environment_swigregister
default_environment_swigregister(default_environment)

def default_environment_instance() -> "spot::default_environment &":
    return _impl.default_environment_instance()
default_environment_instance = _impl.default_environment_instance

class parse_error_list(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __nonzero__(self) -> "bool":
        return _impl.parse_error_list___nonzero__(self)

    def __bool__(self) -> "bool":
        return _impl.parse_error_list___bool__(self)

    def __init__(self):
        _impl.parse_error_list_swiginit(self, _impl.new_parse_error_list())
    __swig_destroy__ = _impl.delete_parse_error_list
parse_error_list_swigregister = _impl.parse_error_list_swigregister
parse_error_list_swigregister(parse_error_list)

class parsed_formula(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    f = _swig_property(_impl.parsed_formula_f_get, _impl.parsed_formula_f_set)
    input = _swig_property(_impl.parsed_formula_input_get, _impl.parsed_formula_input_set)
    errors = _swig_property(_impl.parsed_formula_errors_get, _impl.parsed_formula_errors_set)

    def __init__(self, *args):
        _impl.parsed_formula_swiginit(self, _impl.new_parsed_formula(*args))

    def format_errors(self, *args) -> "bool":
        return _impl.parsed_formula_format_errors(self, *args)
    __swig_destroy__ = _impl.delete_parsed_formula
parsed_formula_swigregister = _impl.parsed_formula_swigregister
parsed_formula_swigregister(parsed_formula)


def parse_infix_psl(*args) -> "spot::parsed_formula":
    return _impl.parse_infix_psl(*args)
parse_infix_psl = _impl.parse_infix_psl

def parse_infix_boolean(*args) -> "spot::parsed_formula":
    return _impl.parse_infix_boolean(*args)
parse_infix_boolean = _impl.parse_infix_boolean

def parse_prefix_ltl(*args) -> "spot::parsed_formula":
    return _impl.parse_prefix_ltl(*args)
parse_prefix_ltl = _impl.parse_prefix_ltl

def parse_formula(*args) -> "spot::formula":
    return _impl.parse_formula(*args)
parse_formula = _impl.parse_formula

def parse_infix_sere(*args) -> "spot::parsed_formula":
    return _impl.parse_infix_sere(*args)
parse_infix_sere = _impl.parse_infix_sere

def fix_utf8_locations(input_string: 'std::string const &', error_list: 'parse_error_list') -> "void":
    return _impl.fix_utf8_locations(input_string, error_list)
fix_utf8_locations = _impl.fix_utf8_locations
class bdd_dict(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        _impl.bdd_dict_swiginit(self, _impl.new_bdd_dict())
    __swig_destroy__ = _impl.delete_bdd_dict
    var_map = _swig_property(_impl.bdd_dict_var_map_get, _impl.bdd_dict_var_map_set)
    acc_map = _swig_property(_impl.bdd_dict_acc_map_get, _impl.bdd_dict_acc_map_set)
    anon = _impl.bdd_dict_anon
    var = _impl.bdd_dict_var
    acc = _impl.bdd_dict_acc
    bdd_map = _swig_property(_impl.bdd_dict_bdd_map_get, _impl.bdd_dict_bdd_map_set)

    def register_proposition(self, f: 'formula', for_me: 'void const *') -> "int":
        return _impl.bdd_dict_register_proposition(self, f, for_me)

    def has_registered_proposition(self, f: 'formula', me: 'void const *') -> "int":
        return _impl.bdd_dict_has_registered_proposition(self, f, me)

    def varnum(self, f: 'formula') -> "int":
        return _impl.bdd_dict_varnum(self, f)

    def register_acceptance_variable(self, f: 'formula', for_me: 'void const *') -> "int":
        return _impl.bdd_dict_register_acceptance_variable(self, f, for_me)

    def register_anonymous_variables(self, n: 'int', for_me: 'void const *') -> "int":
        return _impl.bdd_dict_register_anonymous_variables(self, n, for_me)

    def register_all_variables_of(self, from_other: 'void const *', for_me: 'void const *') -> "void":
        return _impl.bdd_dict_register_all_variables_of(self, from_other, for_me)

    def unregister_all_my_variables(self, me: 'void const *') -> "void":
        return _impl.bdd_dict_unregister_all_my_variables(self, me)

    def unregister_variable(self, var: 'int', me: 'void const *') -> "void":
        return _impl.bdd_dict_unregister_variable(self, var, me)

    def dump(self, os: 'ostream') -> "std::ostream &":
        return _impl.bdd_dict_dump(self, os)

    def assert_emptiness(self) -> "void":
        return _impl.bdd_dict_assert_emptiness(self)

    def __eq__(self, b: 'bdd_dict') -> "bool":
        return _impl.bdd_dict___eq__(self, b)

    def __ne__(self, b: 'bdd_dict') -> "bool":
        return _impl.bdd_dict___ne__(self, b)
bdd_dict_swigregister = _impl.bdd_dict_swigregister
bdd_dict_swigregister(bdd_dict)


def make_bdd_dict() -> "spot::bdd_dict_ptr":
    return _impl.make_bdd_dict()
make_bdd_dict = _impl.make_bdd_dict

def bdd_print_sat(os: 'ostream', dict: 'spot::bdd_dict_ptr const &', b: 'bdd') -> "std::ostream &":
    return _impl.bdd_print_sat(os, dict, b)
bdd_print_sat = _impl.bdd_print_sat

def bdd_format_sat(dict: 'spot::bdd_dict_ptr const &', b: 'bdd') -> "std::string":
    return _impl.bdd_format_sat(dict, b)
bdd_format_sat = _impl.bdd_format_sat

def bdd_print_accset(os: 'ostream', dict: 'spot::bdd_dict_ptr const &', b: 'bdd') -> "std::ostream &":
    return _impl.bdd_print_accset(os, dict, b)
bdd_print_accset = _impl.bdd_print_accset

def bdd_format_accset(dict: 'spot::bdd_dict_ptr const &', b: 'bdd') -> "std::string":
    return _impl.bdd_format_accset(dict, b)
bdd_format_accset = _impl.bdd_format_accset

def bdd_print_set(os: 'ostream', dict: 'spot::bdd_dict_ptr const &', b: 'bdd') -> "std::ostream &":
    return _impl.bdd_print_set(os, dict, b)
bdd_print_set = _impl.bdd_print_set

def bdd_format_set(dict: 'spot::bdd_dict_ptr const &', b: 'bdd') -> "std::string":
    return _impl.bdd_format_set(dict, b)
bdd_format_set = _impl.bdd_format_set

def bdd_print_formula(os: 'ostream', dict: 'spot::bdd_dict_ptr const &', b: 'bdd') -> "std::ostream &":
    return _impl.bdd_print_formula(os, dict, b)
bdd_print_formula = _impl.bdd_print_formula

def bdd_format_formula(dict: 'spot::bdd_dict_ptr const &', b: 'bdd') -> "std::string":
    return _impl.bdd_format_formula(dict, b)
bdd_format_formula = _impl.bdd_format_formula

def enable_utf8() -> "void":
    return _impl.enable_utf8()
enable_utf8 = _impl.enable_utf8

def bdd_format_isop(dict: 'spot::bdd_dict_ptr const &', b: 'bdd') -> "std::string":
    return _impl.bdd_format_isop(dict, b)
bdd_format_isop = _impl.bdd_format_isop

def bdd_print_isop(os: 'ostream', dict: 'spot::bdd_dict_ptr const &', b: 'bdd') -> "std::ostream &":
    return _impl.bdd_print_isop(os, dict, b)
bdd_print_isop = _impl.bdd_print_isop

def formula_to_bdd(f: 'formula', d: 'spot::bdd_dict_ptr const &', for_me: 'void *') -> "bdd":
    return _impl.formula_to_bdd(f, d, for_me)
formula_to_bdd = _impl.formula_to_bdd

def bdd_to_formula(f: 'bdd', d: 'spot::bdd_dict_ptr const') -> "spot::formula":
    return _impl.bdd_to_formula(f, d)
bdd_to_formula = _impl.bdd_to_formula
class vector_rs_pair(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _impl.vector_rs_pair_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _impl.vector_rs_pair___nonzero__(self)

    def __bool__(self) -> "bool":
        return _impl.vector_rs_pair___bool__(self)

    def __len__(self) -> "std::vector< spot::acc_cond::rs_pair >::size_type":
        return _impl.vector_rs_pair___len__(self)

    def __getslice__(self, i: 'std::vector< spot::acc_cond::rs_pair >::difference_type', j: 'std::vector< spot::acc_cond::rs_pair >::difference_type') -> "std::vector< spot::acc_cond::rs_pair,std::allocator< spot::acc_cond::rs_pair > > *":
        return _impl.vector_rs_pair___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _impl.vector_rs_pair___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< spot::acc_cond::rs_pair >::difference_type', j: 'std::vector< spot::acc_cond::rs_pair >::difference_type') -> "void":
        return _impl.vector_rs_pair___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _impl.vector_rs_pair___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< spot::acc_cond::rs_pair >::value_type const &":
        return _impl.vector_rs_pair___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _impl.vector_rs_pair___setitem__(self, *args)

    def pop(self) -> "std::vector< spot::acc_cond::rs_pair >::value_type":
        return _impl.vector_rs_pair_pop(self)

    def append(self, x: 'rs_pair') -> "void":
        return _impl.vector_rs_pair_append(self, x)

    def empty(self) -> "bool":
        return _impl.vector_rs_pair_empty(self)

    def size(self) -> "std::vector< spot::acc_cond::rs_pair >::size_type":
        return _impl.vector_rs_pair_size(self)

    def swap(self, v: 'vector_rs_pair') -> "void":
        return _impl.vector_rs_pair_swap(self, v)

    def begin(self) -> "std::vector< spot::acc_cond::rs_pair >::iterator":
        return _impl.vector_rs_pair_begin(self)

    def end(self) -> "std::vector< spot::acc_cond::rs_pair >::iterator":
        return _impl.vector_rs_pair_end(self)

    def rbegin(self) -> "std::vector< spot::acc_cond::rs_pair >::reverse_iterator":
        return _impl.vector_rs_pair_rbegin(self)

    def rend(self) -> "std::vector< spot::acc_cond::rs_pair >::reverse_iterator":
        return _impl.vector_rs_pair_rend(self)

    def clear(self) -> "void":
        return _impl.vector_rs_pair_clear(self)

    def get_allocator(self) -> "std::vector< spot::acc_cond::rs_pair >::allocator_type":
        return _impl.vector_rs_pair_get_allocator(self)

    def pop_back(self) -> "void":
        return _impl.vector_rs_pair_pop_back(self)

    def erase(self, *args) -> "std::vector< spot::acc_cond::rs_pair >::iterator":
        return _impl.vector_rs_pair_erase(self, *args)

    def __init__(self, *args):
        _impl.vector_rs_pair_swiginit(self, _impl.new_vector_rs_pair(*args))

    def push_back(self, x: 'rs_pair') -> "void":
        return _impl.vector_rs_pair_push_back(self, x)

    def front(self) -> "std::vector< spot::acc_cond::rs_pair >::value_type const &":
        return _impl.vector_rs_pair_front(self)

    def back(self) -> "std::vector< spot::acc_cond::rs_pair >::value_type const &":
        return _impl.vector_rs_pair_back(self)

    def assign(self, n: 'std::vector< spot::acc_cond::rs_pair >::size_type', x: 'rs_pair') -> "void":
        return _impl.vector_rs_pair_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _impl.vector_rs_pair_resize(self, *args)

    def insert(self, *args) -> "void":
        return _impl.vector_rs_pair_insert(self, *args)

    def reserve(self, n: 'std::vector< spot::acc_cond::rs_pair >::size_type') -> "void":
        return _impl.vector_rs_pair_reserve(self, n)

    def capacity(self) -> "std::vector< spot::acc_cond::rs_pair >::size_type":
        return _impl.vector_rs_pair_capacity(self)
    __swig_destroy__ = _impl.delete_vector_rs_pair
vector_rs_pair_swigregister = _impl.vector_rs_pair_swigregister
vector_rs_pair_swigregister(vector_rs_pair)

class acc_cond(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    acc_op_Inf = _impl.acc_cond_acc_op_Inf
    acc_op_Fin = _impl.acc_cond_acc_op_Fin
    acc_op_InfNeg = _impl.acc_cond_acc_op_InfNeg
    acc_op_FinNeg = _impl.acc_cond_acc_op_FinNeg
    acc_op_And = _impl.acc_cond_acc_op_And
    acc_op_Or = _impl.acc_cond_acc_op_Or

    def __init__(self, *args):
        _impl.acc_cond_swiginit(self, _impl.new_acc_cond(*args))
    __swig_destroy__ = _impl.delete_acc_cond

    def set_acceptance(self, code: 'acc_code') -> "void":
        return _impl.acc_cond_set_acceptance(self, code)

    def get_acceptance(self, *args) -> "spot::acc_cond::acc_code &":
        return _impl.acc_cond_get_acceptance(self, *args)

    def __eq__(self, other: 'acc_cond') -> "bool":
        return _impl.acc_cond___eq__(self, other)

    def __ne__(self, other: 'acc_cond') -> "bool":
        return _impl.acc_cond___ne__(self, other)

    def uses_fin_acceptance(self) -> "bool":
        return _impl.acc_cond_uses_fin_acceptance(self)

    def is_t(self) -> "bool":
        return _impl.acc_cond_is_t(self)

    def is_all(self) -> "bool":
        return _impl.acc_cond_is_all(self)

    def is_f(self) -> "bool":
        return _impl.acc_cond_is_f(self)

    def is_none(self) -> "bool":
        return _impl.acc_cond_is_none(self)

    def is_buchi(self) -> "bool":
        return _impl.acc_cond_is_buchi(self)

    def is_co_buchi(self) -> "bool":
        return _impl.acc_cond_is_co_buchi(self)

    def set_generalized_buchi(self) -> "void":
        return _impl.acc_cond_set_generalized_buchi(self)

    def set_generalized_co_buchi(self) -> "void":
        return _impl.acc_cond_set_generalized_co_buchi(self)

    def is_generalized_buchi(self) -> "bool":
        return _impl.acc_cond_is_generalized_buchi(self)

    def is_generalized_co_buchi(self) -> "bool":
        return _impl.acc_cond_is_generalized_co_buchi(self)

    def is_rabin(self) -> "int":
        return _impl.acc_cond_is_rabin(self)

    def is_streett(self) -> "int":
        return _impl.acc_cond_is_streett(self)

    def is_streett_like(self) -> "bool":
        return _impl.acc_cond_is_streett_like(self)

    def is_rabin_like(self) -> "bool":
        return _impl.acc_cond_is_rabin_like(self)

    def is_generalized_rabin(self, pairs: 'vectorunsigned') -> "bool":
        return _impl.acc_cond_is_generalized_rabin(self, pairs)

    def is_generalized_streett(self, pairs: 'vectorunsigned') -> "bool":
        return _impl.acc_cond_is_generalized_streett(self, pairs)

    def is_parity(self, *args) -> "bool":
        return _impl.acc_cond_is_parity(self, *args)

    def unsat_mark(self) -> "std::pair< bool,spot::acc_cond::mark_t >":
        return _impl.acc_cond_unsat_mark(self)
    inf = staticmethod(_impl.acc_cond_inf)
    inf_neg = staticmethod(_impl.acc_cond_inf_neg)
    fin = staticmethod(_impl.acc_cond_fin)
    fin_neg = staticmethod(_impl.acc_cond_fin_neg)

    def add_sets(self, num: 'unsigned int') -> "unsigned int":
        return _impl.acc_cond_add_sets(self, num)

    def add_set(self) -> "unsigned int":
        return _impl.acc_cond_add_set(self)

    def mark(self, u: 'unsigned int') -> "spot::acc_cond::mark_t":
        return _impl.acc_cond_mark(self, u)

    def comp(self, l: 'mark_t') -> "spot::acc_cond::mark_t":
        return _impl.acc_cond_comp(self, l)

    def all_sets(self) -> "spot::acc_cond::mark_t":
        return _impl.acc_cond_all_sets(self)

    def accepting(self, inf: 'mark_t') -> "bool":
        return _impl.acc_cond_accepting(self, inf)

    def inf_satisfiable(self, inf: 'mark_t') -> "bool":
        return _impl.acc_cond_inf_satisfiable(self, inf)

    def maybe_accepting(self, infinitely_often: 'mark_t', always_present: 'mark_t') -> "spot::trival":
        return _impl.acc_cond_maybe_accepting(self, infinitely_often, always_present)

    def accepting_sets(self, inf: 'mark_t') -> "spot::acc_cond::mark_t":
        return _impl.acc_cond_accepting_sets(self, inf)

    def format(self, *args) -> "std::string":
        return _impl.acc_cond_format(self, *args)

    def num_sets(self) -> "unsigned int":
        return _impl.acc_cond_num_sets(self)

    def remove(self, rem: 'mark_t', missing: 'bool') -> "spot::acc_cond":
        return _impl.acc_cond_remove(self, rem, missing)

    def strip(self, rem: 'mark_t', missing: 'bool') -> "spot::acc_cond":
        return _impl.acc_cond_strip(self, rem, missing)

    def restrict_to(self, rem: 'mark_t') -> "spot::acc_cond":
        return _impl.acc_cond_restrict_to(self, rem)

    def name(self, *args) -> "std::string":
        return _impl.acc_cond_name(self, *args)

    def __repr__(self) -> "std::string":
        return _impl.acc_cond___repr__(self)

    def __str__(self) -> "std::string":
        return _impl.acc_cond___str__(self)
acc_cond_swigregister = _impl.acc_cond_swigregister
acc_cond_swigregister(acc_cond)

def acc_cond_inf(*args) -> "spot::acc_cond::acc_code":
    return _impl.acc_cond_inf(*args)
acc_cond_inf = _impl.acc_cond_inf

def acc_cond_inf_neg(*args) -> "spot::acc_cond::acc_code":
    return _impl.acc_cond_inf_neg(*args)
acc_cond_inf_neg = _impl.acc_cond_inf_neg

def acc_cond_fin(*args) -> "spot::acc_cond::acc_code":
    return _impl.acc_cond_fin(*args)
acc_cond_fin = _impl.acc_cond_fin

def acc_cond_fin_neg(*args) -> "spot::acc_cond::acc_code":
    return _impl.acc_cond_fin_neg(*args)
acc_cond_fin_neg = _impl.acc_cond_fin_neg

class mark_t(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    id = _swig_property(_impl.mark_t_id_get, _impl.mark_t_id_set)

    def __eq__(self, *args) -> "bool":
        return _impl.mark_t___eq__(self, *args)

    def __ne__(self, *args) -> "bool":
        return _impl.mark_t___ne__(self, *args)

    def __lt__(self, o: 'mark_t') -> "bool":
        return _impl.mark_t___lt__(self, o)

    def __le__(self, o: 'mark_t') -> "bool":
        return _impl.mark_t___le__(self, o)

    def __gt__(self, o: 'mark_t') -> "bool":
        return _impl.mark_t___gt__(self, o)

    def __ge__(self, o: 'mark_t') -> "bool":
        return _impl.mark_t___ge__(self, o)

    def __nonzero__(self):
        return _impl.mark_t___nonzero__(self)
    __bool__ = __nonzero__



    def has(self, u: 'unsigned int') -> "bool":
        return _impl.mark_t_has(self, u)

    def set(self, u: 'unsigned int') -> "void":
        return _impl.mark_t_set(self, u)

    def clear(self, u: 'unsigned int') -> "void":
        return _impl.mark_t_clear(self, u)

    def __iand__(self, r: 'mark_t') -> "spot::acc_cond::mark_t &":
        return _impl.mark_t___iand__(self, r)

    def __ior__(self, r: 'mark_t') -> "spot::acc_cond::mark_t &":
        return _impl.mark_t___ior__(self, r)

    def __isub__(self, r: 'mark_t') -> "spot::acc_cond::mark_t &":
        return _impl.mark_t___isub__(self, r)

    def __ixor__(self, r: 'mark_t') -> "spot::acc_cond::mark_t &":
        return _impl.mark_t___ixor__(self, r)

    def __and__(self, r: 'mark_t') -> "spot::acc_cond::mark_t":
        return _impl.mark_t___and__(self, r)

    def __or__(self, r: 'mark_t') -> "spot::acc_cond::mark_t":
        return _impl.mark_t___or__(self, r)

    def __sub__(self, r: 'mark_t') -> "spot::acc_cond::mark_t":
        return _impl.mark_t___sub__(self, r)

    def __invert__(self) -> "spot::acc_cond::mark_t":
        return _impl.mark_t___invert__(self)

    def __xor__(self, r: 'mark_t') -> "spot::acc_cond::mark_t":
        return _impl.mark_t___xor__(self, r)

    def __lshift__(self, i: 'unsigned int') -> "spot::acc_cond::mark_t":
        return _impl.mark_t___lshift__(self, i)

    def __ilshift__(self, i: 'unsigned int') -> "spot::acc_cond::mark_t &":
        return _impl.mark_t___ilshift__(self, i)

    def __rshift__(self, i: 'unsigned int') -> "spot::acc_cond::mark_t":
        return _impl.mark_t___rshift__(self, i)

    def __irshift__(self, i: 'unsigned int') -> "spot::acc_cond::mark_t &":
        return _impl.mark_t___irshift__(self, i)

    def strip(self, y: 'mark_t') -> "spot::acc_cond::mark_t":
        return _impl.mark_t_strip(self, y)

    def subset(self, m: 'mark_t') -> "bool":
        return _impl.mark_t_subset(self, m)

    def proper_subset(self, m: 'mark_t') -> "bool":
        return _impl.mark_t_proper_subset(self, m)

    def count(self) -> "unsigned int":
        return _impl.mark_t_count(self)

    def max_set(self) -> "unsigned int":
        return _impl.mark_t_max_set(self)

    def min_set(self) -> "unsigned int":
        return _impl.mark_t_min_set(self)

    def lowest(self) -> "spot::acc_cond::mark_t":
        return _impl.mark_t_lowest(self)

    def remove_some(self, n: 'unsigned int') -> "spot::acc_cond::mark_t &":
        return _impl.mark_t_remove_some(self, n)

    def sets(self) -> "spot::internal::mark_container":
        return _impl.mark_t_sets(self)

    def __init__(self, *args):
        _impl.mark_t_swiginit(self, _impl.new_mark_t(*args))

    def __repr__(self) -> "std::string":
        return _impl.mark_t___repr__(self)

    def __str__(self) -> "std::string":
        return _impl.mark_t___str__(self)
    __swig_destroy__ = _impl.delete_mark_t
mark_t_swigregister = _impl.mark_t_swigregister
mark_t_swigregister(mark_t)

class acc_code(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __eq__(self, other: 'acc_code') -> "bool":
        return _impl.acc_code___eq__(self, other)

    def __lt__(self, other: 'acc_code') -> "bool":
        return _impl.acc_code___lt__(self, other)

    def __gt__(self, other: 'acc_code') -> "bool":
        return _impl.acc_code___gt__(self, other)

    def __le__(self, other: 'acc_code') -> "bool":
        return _impl.acc_code___le__(self, other)

    def __ge__(self, other: 'acc_code') -> "bool":
        return _impl.acc_code___ge__(self, other)

    def __ne__(self, other: 'acc_code') -> "bool":
        return _impl.acc_code___ne__(self, other)

    def is_t(self) -> "bool":
        return _impl.acc_code_is_t(self)

    def is_f(self) -> "bool":
        return _impl.acc_code_is_f(self)
    f = staticmethod(_impl.acc_code_f)
    t = staticmethod(_impl.acc_code_t)
    fin = staticmethod(_impl.acc_code_fin)
    fin_neg = staticmethod(_impl.acc_code_fin_neg)
    inf = staticmethod(_impl.acc_code_inf)
    inf_neg = staticmethod(_impl.acc_code_inf_neg)
    buchi = staticmethod(_impl.acc_code_buchi)
    cobuchi = staticmethod(_impl.acc_code_cobuchi)
    generalized_buchi = staticmethod(_impl.acc_code_generalized_buchi)
    generalized_co_buchi = staticmethod(_impl.acc_code_generalized_co_buchi)
    rabin = staticmethod(_impl.acc_code_rabin)
    streett = staticmethod(_impl.acc_code_streett)
    parity = staticmethod(_impl.acc_code_parity)
    random = staticmethod(_impl.acc_code_random)

    def __iand__(self, r: 'acc_code') -> "spot::acc_cond::acc_code &":
        return _impl.acc_code___iand__(self, r)

    def __and__(self, *args) -> "spot::acc_cond::acc_code":
        return _impl.acc_code___and__(self, *args)

    def __ior__(self, r: 'acc_code') -> "spot::acc_cond::acc_code &":
        return _impl.acc_code___ior__(self, r)

    def __or__(self, *args) -> "spot::acc_cond::acc_code":
        return _impl.acc_code___or__(self, *args)

    def __ilshift__(self, sets: 'unsigned int') -> "spot::acc_cond::acc_code &":
        return _impl.acc_code___ilshift__(self, sets)

    def __lshift__(self, sets: 'unsigned int') -> "spot::acc_cond::acc_code":
        return _impl.acc_code___lshift__(self, sets)

    def is_dnf(self) -> "bool":
        return _impl.acc_code_is_dnf(self)

    def is_cnf(self) -> "bool":
        return _impl.acc_code_is_cnf(self)

    def to_dnf(self) -> "spot::acc_cond::acc_code":
        return _impl.acc_code_to_dnf(self)

    def to_cnf(self) -> "spot::acc_cond::acc_code":
        return _impl.acc_code_to_cnf(self)

    def complement(self) -> "spot::acc_cond::acc_code":
        return _impl.acc_code_complement(self)

    def missing(self, inf: 'mark_t', accepting: 'bool') -> "std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > >":
        return _impl.acc_code_missing(self, inf, accepting)

    def accepting(self, inf: 'mark_t') -> "bool":
        return _impl.acc_code_accepting(self, inf)

    def inf_satisfiable(self, inf: 'mark_t') -> "bool":
        return _impl.acc_code_inf_satisfiable(self, inf)

    def maybe_accepting(self, infinitely_often: 'mark_t', always_present: 'mark_t') -> "spot::trival":
        return _impl.acc_code_maybe_accepting(self, infinitely_often, always_present)

    def remove(self, rem: 'mark_t', missing: 'bool') -> "spot::acc_cond::acc_code":
        return _impl.acc_code_remove(self, rem, missing)

    def strip(self, rem: 'mark_t', missing: 'bool') -> "spot::acc_cond::acc_code":
        return _impl.acc_code_strip(self, rem, missing)

    def used_sets(self) -> "spot::acc_cond::mark_t":
        return _impl.acc_code_used_sets(self)

    def used_inf_fin_sets(self) -> "std::pair< spot::acc_cond::mark_t,spot::acc_cond::mark_t >":
        return _impl.acc_code_used_inf_fin_sets(self)

    def to_html(self, os: 'ostream', set_printer: 'std::function< void (std::ostream &,int) >'=0) -> "std::ostream &":
        return _impl.acc_code_to_html(self, os, set_printer)

    def to_text(self, os: 'ostream', set_printer: 'std::function< void (std::ostream &,int) >'=0) -> "std::ostream &":
        return _impl.acc_code_to_text(self, os, set_printer)

    def to_latex(self, os: 'ostream', set_printer: 'std::function< void (std::ostream &,int) >'=0) -> "std::ostream &":
        return _impl.acc_code_to_latex(self, os, set_printer)

    def __init__(self, *args):
        _impl.acc_code_swiginit(self, _impl.new_acc_code(*args))

    def __repr__(self) -> "std::string":
        return _impl.acc_code___repr__(self)

    def __str__(self) -> "std::string":
        return _impl.acc_code___str__(self)
    __swig_destroy__ = _impl.delete_acc_code
acc_code_swigregister = _impl.acc_code_swigregister
acc_code_swigregister(acc_code)

def acc_code_f() -> "spot::acc_cond::acc_code":
    return _impl.acc_code_f()
acc_code_f = _impl.acc_code_f

def acc_code_t() -> "spot::acc_cond::acc_code":
    return _impl.acc_code_t()
acc_code_t = _impl.acc_code_t

def acc_code_fin(*args) -> "spot::acc_cond::acc_code":
    return _impl.acc_code_fin(*args)
acc_code_fin = _impl.acc_code_fin

def acc_code_fin_neg(*args) -> "spot::acc_cond::acc_code":
    return _impl.acc_code_fin_neg(*args)
acc_code_fin_neg = _impl.acc_code_fin_neg

def acc_code_inf(*args) -> "spot::acc_cond::acc_code":
    return _impl.acc_code_inf(*args)
acc_code_inf = _impl.acc_code_inf

def acc_code_inf_neg(*args) -> "spot::acc_cond::acc_code":
    return _impl.acc_code_inf_neg(*args)
acc_code_inf_neg = _impl.acc_code_inf_neg

def acc_code_buchi() -> "spot::acc_cond::acc_code":
    return _impl.acc_code_buchi()
acc_code_buchi = _impl.acc_code_buchi

def acc_code_cobuchi() -> "spot::acc_cond::acc_code":
    return _impl.acc_code_cobuchi()
acc_code_cobuchi = _impl.acc_code_cobuchi

def acc_code_generalized_buchi(n: 'unsigned int') -> "spot::acc_cond::acc_code":
    return _impl.acc_code_generalized_buchi(n)
acc_code_generalized_buchi = _impl.acc_code_generalized_buchi

def acc_code_generalized_co_buchi(n: 'unsigned int') -> "spot::acc_cond::acc_code":
    return _impl.acc_code_generalized_co_buchi(n)
acc_code_generalized_co_buchi = _impl.acc_code_generalized_co_buchi

def acc_code_rabin(n: 'unsigned int') -> "spot::acc_cond::acc_code":
    return _impl.acc_code_rabin(n)
acc_code_rabin = _impl.acc_code_rabin

def acc_code_streett(n: 'unsigned int') -> "spot::acc_cond::acc_code":
    return _impl.acc_code_streett(n)
acc_code_streett = _impl.acc_code_streett

def acc_code_parity(max: 'bool', odd: 'bool', sets: 'unsigned int') -> "spot::acc_cond::acc_code":
    return _impl.acc_code_parity(max, odd, sets)
acc_code_parity = _impl.acc_code_parity

def acc_code_random(n: 'unsigned int', reuse: 'double'=0.0) -> "spot::acc_cond::acc_code":
    return _impl.acc_code_random(n, reuse)
acc_code_random = _impl.acc_code_random

class rs_pair(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _impl.rs_pair_swiginit(self, _impl.new_rs_pair(*args))
    fin = _swig_property(_impl.rs_pair_fin_get, _impl.rs_pair_fin_set)
    inf = _swig_property(_impl.rs_pair_inf_get, _impl.rs_pair_inf_set)

    def __eq__(self, o: 'rs_pair') -> "bool":
        return _impl.rs_pair___eq__(self, o)

    def __ne__(self, o: 'rs_pair') -> "bool":
        return _impl.rs_pair___ne__(self, o)

    def __lt__(self, o: 'rs_pair') -> "bool":
        return _impl.rs_pair___lt__(self, o)

    def __le__(self, o: 'rs_pair') -> "bool":
        return _impl.rs_pair___le__(self, o)

    def __gt__(self, o: 'rs_pair') -> "bool":
        return _impl.rs_pair___gt__(self, o)

    def __ge__(self, o: 'rs_pair') -> "bool":
        return _impl.rs_pair___ge__(self, o)
    __swig_destroy__ = _impl.delete_rs_pair
rs_pair_swigregister = _impl.rs_pair_swigregister
rs_pair_swigregister(rs_pair)

class rs_pairs_view(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _impl.rs_pairs_view_swiginit(self, _impl.new_rs_pairs_view(*args))

    def infs(self) -> "spot::acc_cond::mark_t":
        return _impl.rs_pairs_view_infs(self)

    def fins(self) -> "spot::acc_cond::mark_t":
        return _impl.rs_pairs_view_fins(self)

    def fins_alone(self) -> "spot::acc_cond::mark_t":
        return _impl.rs_pairs_view_fins_alone(self)

    def infs_alone(self) -> "spot::acc_cond::mark_t":
        return _impl.rs_pairs_view_infs_alone(self)

    def paired_with(self, mark: 'unsigned int') -> "spot::acc_cond::mark_t":
        return _impl.rs_pairs_view_paired_with(self, mark)

    def pairs(self) -> "spot::rs_pairs_view::rs_pairs const &":
        return _impl.rs_pairs_view_pairs(self)
    __swig_destroy__ = _impl.delete_rs_pairs_view
rs_pairs_view_swigregister = _impl.rs_pairs_view_swigregister
rs_pairs_view_swigregister(rs_pairs_view)


def __lshift__(*args) -> "std::ostream &":
    return _impl.__lshift__(*args)
__lshift__ = _impl.__lshift__
class mark_iterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _impl.mark_iterator_swiginit(self, _impl.new_mark_iterator(*args))

    def __eq__(self, m: 'mark_iterator') -> "bool":
        return _impl.mark_iterator___eq__(self, m)

    def __ne__(self, m: 'mark_iterator') -> "bool":
        return _impl.mark_iterator___ne__(self, m)

    def __ref__(self) -> "spot::internal::mark_iterator::value_type":
        return _impl.mark_iterator___ref__(self)
    __swig_destroy__ = _impl.delete_mark_iterator
mark_iterator_swigregister = _impl.mark_iterator_swigregister
mark_iterator_swigregister(mark_iterator)

class mark_container(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, m: 'mark_t'):
        _impl.mark_container_swiginit(self, _impl.new_mark_container(m))

    def begin(self) -> "spot::internal::mark_iterator":
        return _impl.mark_container_begin(self)

    def end(self) -> "spot::internal::mark_iterator":
        return _impl.mark_container_end(self)

    def __iter__(self) -> "swig::SwigPyIterator *":
        return _impl.mark_container___iter__(self)
    __swig_destroy__ = _impl.delete_mark_container
mark_container_swigregister = _impl.mark_container_swigregister
mark_container_swigregister(mark_container)

class pair_bool_mark(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _impl.pair_bool_mark_swiginit(self, _impl.new_pair_bool_mark(*args))
    first = _swig_property(_impl.pair_bool_mark_first_get, _impl.pair_bool_mark_first_set)
    second = _swig_property(_impl.pair_bool_mark_second_get, _impl.pair_bool_mark_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _impl.delete_pair_bool_mark
pair_bool_mark_swigregister = _impl.pair_bool_mark_swigregister
pair_bool_mark_swigregister(pair_bool_mark)

class state(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def compare(self, other: 'state') -> "int":
        return _impl.state_compare(self, other)

    def hash(self) -> "size_t":
        return _impl.state_hash(self)

    def clone(self) -> "spot::state *":
        return _impl.state_clone(self)

    def destroy(self) -> "void":
        return _impl.state_destroy(self)
state_swigregister = _impl.state_swigregister
state_swigregister(state)

class state_ptr_less_than(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __call__(self, left: 'state', right: 'state') -> "bool":
        return _impl.state_ptr_less_than___call__(self, left, right)

    def __init__(self):
        _impl.state_ptr_less_than_swiginit(self, _impl.new_state_ptr_less_than())
    __swig_destroy__ = _impl.delete_state_ptr_less_than
state_ptr_less_than_swigregister = _impl.state_ptr_less_than_swigregister
state_ptr_less_than_swigregister(state_ptr_less_than)

class state_ptr_equal(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __call__(self, left: 'state', right: 'state') -> "bool":
        return _impl.state_ptr_equal___call__(self, left, right)

    def __init__(self):
        _impl.state_ptr_equal_swiginit(self, _impl.new_state_ptr_equal())
    __swig_destroy__ = _impl.delete_state_ptr_equal
state_ptr_equal_swigregister = _impl.state_ptr_equal_swigregister
state_ptr_equal_swigregister(state_ptr_equal)

class state_ptr_hash(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __call__(self, that: 'state') -> "size_t":
        return _impl.state_ptr_hash___call__(self, that)

    def __init__(self):
        _impl.state_ptr_hash_swiginit(self, _impl.new_state_ptr_hash())
    __swig_destroy__ = _impl.delete_state_ptr_hash
state_ptr_hash_swigregister = _impl.state_ptr_hash_swigregister
state_ptr_hash_swigregister(state_ptr_hash)

class state_unicity_table(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __call__(self, s: 'state') -> "spot::state const *":
        return _impl.state_unicity_table___call__(self, s)

    def is_new(self, s: 'state') -> "spot::state const *":
        return _impl.state_unicity_table_is_new(self, s)
    __swig_destroy__ = _impl.delete_state_unicity_table

    def size(self) -> "size_t":
        return _impl.state_unicity_table_size(self)

    def __init__(self):
        _impl.state_unicity_table_swiginit(self, _impl.new_state_unicity_table())
state_unicity_table_swigregister = _impl.state_unicity_table_swigregister
state_unicity_table_swigregister(state_unicity_table)


def shared_state_deleter(s: 'state') -> "void":
    return _impl.shared_state_deleter(s)
shared_state_deleter = _impl.shared_state_deleter
class state_shared_ptr_less_than(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __call__(self, left: 'spot::shared_state', right: 'spot::shared_state') -> "bool":
        return _impl.state_shared_ptr_less_than___call__(self, left, right)

    def __init__(self):
        _impl.state_shared_ptr_less_than_swiginit(self, _impl.new_state_shared_ptr_less_than())
    __swig_destroy__ = _impl.delete_state_shared_ptr_less_than
state_shared_ptr_less_than_swigregister = _impl.state_shared_ptr_less_than_swigregister
state_shared_ptr_less_than_swigregister(state_shared_ptr_less_than)

class state_shared_ptr_equal(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __call__(self, left: 'spot::shared_state', right: 'spot::shared_state') -> "bool":
        return _impl.state_shared_ptr_equal___call__(self, left, right)

    def __init__(self):
        _impl.state_shared_ptr_equal_swiginit(self, _impl.new_state_shared_ptr_equal())
    __swig_destroy__ = _impl.delete_state_shared_ptr_equal
state_shared_ptr_equal_swigregister = _impl.state_shared_ptr_equal_swigregister
state_shared_ptr_equal_swigregister(state_shared_ptr_equal)

class state_shared_ptr_hash(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __call__(self, that: 'spot::shared_state') -> "size_t":
        return _impl.state_shared_ptr_hash___call__(self, that)

    def __init__(self):
        _impl.state_shared_ptr_hash_swiginit(self, _impl.new_state_shared_ptr_hash())
    __swig_destroy__ = _impl.delete_state_shared_ptr_hash
state_shared_ptr_hash_swigregister = _impl.state_shared_ptr_hash_swigregister
state_shared_ptr_hash_swigregister(state_shared_ptr_hash)

class twa_succ_iterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _impl.delete_twa_succ_iterator

    def first(self) -> "bool":
        return _impl.twa_succ_iterator_first(self)

    def next(self) -> "bool":
        return _impl.twa_succ_iterator_next(self)

    def done(self) -> "bool":
        return _impl.twa_succ_iterator_done(self)

    def dst(self) -> "spot::state const *":
        return _impl.twa_succ_iterator_dst(self)

    def cond(self) -> "bdd":
        return _impl.twa_succ_iterator_cond(self)

    def acc(self) -> "spot::acc_cond::mark_t":
        return _impl.twa_succ_iterator_acc(self)
twa_succ_iterator_swigregister = _impl.twa_succ_iterator_swigregister
twa_succ_iterator_swigregister(twa_succ_iterator)

class succ_iterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, it: 'twa_succ_iterator'):
        _impl.succ_iterator_swiginit(self, _impl.new_succ_iterator(it))

    def __eq__(self, o: 'succ_iterator') -> "bool":
        return _impl.succ_iterator___eq__(self, o)

    def __ne__(self, o: 'succ_iterator') -> "bool":
        return _impl.succ_iterator___ne__(self, o)

    def __ref__(self) -> "spot::twa_succ_iterator const *":
        return _impl.succ_iterator___ref__(self)
    __swig_destroy__ = _impl.delete_succ_iterator
succ_iterator_swigregister = _impl.succ_iterator_swigregister
succ_iterator_swigregister(succ_iterator)

class twa(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _impl.delete_twa

    def get_init_state(self) -> "spot::state const *":
        return _impl.twa_get_init_state(self)

    def succ_iter(self, local_state: 'state') -> "spot::twa_succ_iterator *":
        return _impl.twa_succ_iter(self, local_state)

    def release_iter(self, i: 'twa_succ_iterator') -> "void":
        return _impl.twa_release_iter(self, i)

    def get_dict(self) -> "spot::bdd_dict_ptr":
        return _impl.twa_get_dict(self)

    def register_ap(self, *args) -> "int":
        return _impl.twa_register_ap(self, *args)

    def unregister_ap(self, num: 'int') -> "void":
        return _impl.twa_unregister_ap(self, num)

    def register_aps_from_dict(self) -> "void":
        return _impl.twa_register_aps_from_dict(self)

    def ap(self) -> "std::vector< spot::formula,std::allocator< spot::formula > > const &":
        return _impl.twa_ap(self)

    def ap_vars(self) -> "bdd":
        return _impl.twa_ap_vars(self)

    def format_state(self, s: 'state') -> "std::string":
        return _impl.twa_format_state(self, s)

    def project_state(self, s: 'state', t: 'spot::const_twa_ptr const &') -> "spot::state *":
        return _impl.twa_project_state(self, s, t)

    def acc(self, *args) -> "spot::acc_cond &":
        return _impl.twa_acc(self, *args)

    def is_empty(self) -> "bool":
        return _impl.twa_is_empty(self)

    def accepting_run(self) -> "spot::twa_run_ptr":
        return _impl.twa_accepting_run(self)

    def accepting_word(self) -> "spot::twa_word_ptr":
        return _impl.twa_accepting_word(self)

    def intersects(self, other: 'spot::const_twa_ptr') -> "bool":
        return _impl.twa_intersects(self, other)

    def intersecting_run(self, other: 'spot::const_twa_ptr', from_other: 'bool'=False) -> "spot::twa_run_ptr":
        return _impl.twa_intersecting_run(self, other, from_other)

    def intersecting_word(self, other: 'spot::const_twa_ptr') -> "spot::twa_word_ptr":
        return _impl.twa_intersecting_word(self, other)

    def num_sets(self) -> "unsigned int":
        return _impl.twa_num_sets(self)

    def get_acceptance(self) -> "spot::acc_cond::acc_code const &":
        return _impl.twa_get_acceptance(self)

    def set_acceptance(self, *args) -> "void":
        return _impl.twa_set_acceptance(self, *args)

    def copy_acceptance_of(self, a: 'spot::const_twa_ptr const &') -> "void":
        return _impl.twa_copy_acceptance_of(self, a)

    def copy_ap_of(self, a: 'spot::const_twa_ptr const &') -> "void":
        return _impl.twa_copy_ap_of(self, a)

    def set_generalized_buchi(self, num: 'unsigned int') -> "void":
        return _impl.twa_set_generalized_buchi(self, num)

    def set_generalized_co_buchi(self, num: 'unsigned int') -> "void":
        return _impl.twa_set_generalized_co_buchi(self, num)

    def set_buchi(self) -> "spot::acc_cond::mark_t":
        return _impl.twa_set_buchi(self)

    def set_co_buchi(self) -> "spot::acc_cond::mark_t":
        return _impl.twa_set_co_buchi(self)

    def release_named_properties(self) -> "void":
        return _impl.twa_release_named_properties(self)

    def prop_state_acc(self, *args) -> "void":
        return _impl.twa_prop_state_acc(self, *args)

    def is_sba(self) -> "spot::trival":
        return _impl.twa_is_sba(self)

    def prop_inherently_weak(self, *args) -> "void":
        return _impl.twa_prop_inherently_weak(self, *args)

    def prop_terminal(self, *args) -> "void":
        return _impl.twa_prop_terminal(self, *args)

    def prop_weak(self, *args) -> "void":
        return _impl.twa_prop_weak(self, *args)

    def prop_very_weak(self, *args) -> "void":
        return _impl.twa_prop_very_weak(self, *args)

    def prop_complete(self, *args) -> "void":
        return _impl.twa_prop_complete(self, *args)

    def prop_universal(self, *args) -> "void":
        return _impl.twa_prop_universal(self, *args)

    def prop_deterministic(self, *args) -> "spot::trival":

        from warnings import warn
        warn("use prop_universal() instead of prop_deterministic()",
             DeprecationWarning)


        return _impl.twa_prop_deterministic(self, *args)


    def prop_unambiguous(self, *args) -> "void":
        return _impl.twa_prop_unambiguous(self, *args)

    def prop_semi_deterministic(self, *args) -> "void":
        return _impl.twa_prop_semi_deterministic(self, *args)

    def prop_stutter_invariant(self, *args) -> "void":
        return _impl.twa_prop_stutter_invariant(self, *args)

    def prop_copy(self, other: 'spot::const_twa_ptr const &', p: 'spot::twa::prop_set') -> "void":
        return _impl.twa_prop_copy(self, other, p)

    def prop_keep(self, p: 'spot::twa::prop_set') -> "void":
        return _impl.twa_prop_keep(self, p)

    def set_name(self, name: 'std::string') -> "void":
        return _impl.twa_set_name(self, name)

    def get_name(self) -> "std::string *":
        return _impl.twa_get_name(self)

    def set_state_names(self, names: 'vectorstring') -> "void":
        return _impl.twa_set_state_names(self, names)

    def get_state_names(self) -> "std::vector< std::string,std::allocator< std::string > > *":
        return _impl.twa_get_state_names(self)

    def set_product_states(self, pairs: 'vectorpairunsigned') -> "void":
        return _impl.twa_set_product_states(self, pairs)

    def get_product_states(self) -> "std::vector< std::pair< unsigned int,unsigned int >,std::allocator< std::pair< unsigned int,unsigned int > > > *":
        return _impl.twa_get_product_states(self)

    def highlight_state(self, state: 'unsigned int', color: 'unsigned int') -> "spot::twa *":
        return _impl.twa_highlight_state(self, state, color)

    def highlight_edge(self, edge: 'unsigned int', color: 'unsigned int') -> "spot::twa *":
        return _impl.twa_highlight_edge(self, edge, color)
twa_swigregister = _impl.twa_swigregister
twa_swigregister(twa)


def create_atomic_prop_set(n: 'unsigned int') -> "spot::atomic_prop_set":
    return _impl.create_atomic_prop_set(n)
create_atomic_prop_set = _impl.create_atomic_prop_set

def atomic_prop_collect(f: 'formula', s: 'atomic_prop_set'=None) -> "spot::atomic_prop_set *":
    return _impl.atomic_prop_collect(f, s)
atomic_prop_collect = _impl.atomic_prop_collect

def atomic_prop_collect_as_bdd(f: 'formula', a: 'spot::twa_ptr const &') -> "bdd":
    return _impl.atomic_prop_collect_as_bdd(f, a)
atomic_prop_collect_as_bdd = _impl.atomic_prop_collect_as_bdd
class language_containment_checker(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _impl.language_containment_checker_swiginit(self, _impl.new_language_containment_checker(*args))
    __swig_destroy__ = _impl.delete_language_containment_checker

    def clear(self) -> "void":
        return _impl.language_containment_checker_clear(self)

    def contained(self, l: 'formula', g: 'formula') -> "bool":
        return _impl.language_containment_checker_contained(self, l, g)

    def neg_contained(self, l: 'formula', g: 'formula') -> "bool":
        return _impl.language_containment_checker_neg_contained(self, l, g)

    def contained_neg(self, l: 'formula', g: 'formula') -> "bool":
        return _impl.language_containment_checker_contained_neg(self, l, g)

    def equal(self, l: 'formula', g: 'formula') -> "bool":
        return _impl.language_containment_checker_equal(self, l, g)
language_containment_checker_swigregister = _impl.language_containment_checker_swigregister
language_containment_checker_swigregister(language_containment_checker)


def print_dot_psl(os: 'ostream', f: 'formula') -> "std::ostream &":
    return _impl.print_dot_psl(os, f)
print_dot_psl = _impl.print_dot_psl

def negative_normal_form(f: 'formula', negated: 'bool'=False) -> "spot::formula":
    return _impl.negative_normal_form(f, negated)
negative_normal_form = _impl.negative_normal_form

def print_psl(os: 'ostream', f: 'formula', full_parent: 'bool'=False) -> "std::ostream &":
    return _impl.print_psl(os, f, full_parent)
print_psl = _impl.print_psl

def str_psl(f: 'formula', full_parent: 'bool'=False) -> "std::string":
    return _impl.str_psl(f, full_parent)
str_psl = _impl.str_psl

def print_utf8_psl(os: 'ostream', f: 'formula', full_parent: 'bool'=False) -> "std::ostream &":
    return _impl.print_utf8_psl(os, f, full_parent)
print_utf8_psl = _impl.print_utf8_psl

def str_utf8_psl(f: 'formula', full_parent: 'bool'=False) -> "std::string":
    return _impl.str_utf8_psl(f, full_parent)
str_utf8_psl = _impl.str_utf8_psl

def print_sere(os: 'ostream', f: 'formula', full_parent: 'bool'=False) -> "std::ostream &":
    return _impl.print_sere(os, f, full_parent)
print_sere = _impl.print_sere

def str_sere(f: 'formula', full_parent: 'bool'=False) -> "std::string":
    return _impl.str_sere(f, full_parent)
str_sere = _impl.str_sere

def print_utf8_sere(os: 'ostream', f: 'formula', full_parent: 'bool'=False) -> "std::ostream &":
    return _impl.print_utf8_sere(os, f, full_parent)
print_utf8_sere = _impl.print_utf8_sere

def str_utf8_sere(f: 'formula', full_parent: 'bool'=False) -> "std::string":
    return _impl.str_utf8_sere(f, full_parent)
str_utf8_sere = _impl.str_utf8_sere

def print_spin_ltl(os: 'ostream', f: 'formula', full_parent: 'bool'=False) -> "std::ostream &":
    return _impl.print_spin_ltl(os, f, full_parent)
print_spin_ltl = _impl.print_spin_ltl

def str_spin_ltl(f: 'formula', full_parent: 'bool'=False) -> "std::string":
    return _impl.str_spin_ltl(f, full_parent)
str_spin_ltl = _impl.str_spin_ltl

def print_wring_ltl(os: 'ostream', f: 'formula') -> "std::ostream &":
    return _impl.print_wring_ltl(os, f)
print_wring_ltl = _impl.print_wring_ltl

def str_wring_ltl(f: 'formula') -> "std::string":
    return _impl.str_wring_ltl(f)
str_wring_ltl = _impl.str_wring_ltl

def print_latex_psl(os: 'ostream', f: 'formula', full_parent: 'bool'=False) -> "std::ostream &":
    return _impl.print_latex_psl(os, f, full_parent)
print_latex_psl = _impl.print_latex_psl

def str_latex_psl(f: 'formula', full_parent: 'bool'=False) -> "std::string":
    return _impl.str_latex_psl(f, full_parent)
str_latex_psl = _impl.str_latex_psl

def print_latex_sere(os: 'ostream', f: 'formula', full_parent: 'bool'=False) -> "std::ostream &":
    return _impl.print_latex_sere(os, f, full_parent)
print_latex_sere = _impl.print_latex_sere

def str_latex_sere(f: 'formula', full_parent: 'bool'=False) -> "std::string":
    return _impl.str_latex_sere(f, full_parent)
str_latex_sere = _impl.str_latex_sere

def print_sclatex_psl(os: 'ostream', f: 'formula', full_parent: 'bool'=False) -> "std::ostream &":
    return _impl.print_sclatex_psl(os, f, full_parent)
print_sclatex_psl = _impl.print_sclatex_psl

def str_sclatex_psl(f: 'formula', full_parent: 'bool'=False) -> "std::string":
    return _impl.str_sclatex_psl(f, full_parent)
str_sclatex_psl = _impl.str_sclatex_psl

def print_sclatex_sere(os: 'ostream', f: 'formula', full_parent: 'bool'=False) -> "std::ostream &":
    return _impl.print_sclatex_sere(os, f, full_parent)
print_sclatex_sere = _impl.print_sclatex_sere

def str_sclatex_sere(f: 'formula', full_parent: 'bool'=False) -> "std::string":
    return _impl.str_sclatex_sere(f, full_parent)
str_sclatex_sere = _impl.str_sclatex_sere

def print_lbt_ltl(os: 'ostream', f: 'formula') -> "std::ostream &":
    return _impl.print_lbt_ltl(os, f)
print_lbt_ltl = _impl.print_lbt_ltl

def str_lbt_ltl(f: 'formula') -> "std::string":
    return _impl.str_lbt_ltl(f)
str_lbt_ltl = _impl.str_lbt_ltl
class tl_simplifier_options(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _impl.tl_simplifier_options_swiginit(self, _impl.new_tl_simplifier_options(*args))
    reduce_basics = _swig_property(_impl.tl_simplifier_options_reduce_basics_get, _impl.tl_simplifier_options_reduce_basics_set)
    synt_impl = _swig_property(_impl.tl_simplifier_options_synt_impl_get, _impl.tl_simplifier_options_synt_impl_set)
    event_univ = _swig_property(_impl.tl_simplifier_options_event_univ_get, _impl.tl_simplifier_options_event_univ_set)
    containment_checks = _swig_property(_impl.tl_simplifier_options_containment_checks_get, _impl.tl_simplifier_options_containment_checks_set)
    containment_checks_stronger = _swig_property(_impl.tl_simplifier_options_containment_checks_stronger_get, _impl.tl_simplifier_options_containment_checks_stronger_set)
    nenoform_stop_on_boolean = _swig_property(_impl.tl_simplifier_options_nenoform_stop_on_boolean_get, _impl.tl_simplifier_options_nenoform_stop_on_boolean_set)
    reduce_size_strictly = _swig_property(_impl.tl_simplifier_options_reduce_size_strictly_get, _impl.tl_simplifier_options_reduce_size_strictly_set)
    boolean_to_isop = _swig_property(_impl.tl_simplifier_options_boolean_to_isop_get, _impl.tl_simplifier_options_boolean_to_isop_set)
    favor_event_univ = _swig_property(_impl.tl_simplifier_options_favor_event_univ_get, _impl.tl_simplifier_options_favor_event_univ_set)
    __swig_destroy__ = _impl.delete_tl_simplifier_options
tl_simplifier_options_swigregister = _impl.tl_simplifier_options_swigregister
tl_simplifier_options_swigregister(tl_simplifier_options)

class tl_simplifier(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _impl.tl_simplifier_swiginit(self, _impl.new_tl_simplifier(*args))
    __swig_destroy__ = _impl.delete_tl_simplifier

    def simplify(self, f: 'formula') -> "spot::formula":
        return _impl.tl_simplifier_simplify(self, f)

    def negative_normal_form(self, f: 'formula', negated: 'bool'=False) -> "spot::formula":
        return _impl.tl_simplifier_negative_normal_form(self, f, negated)

    def syntactic_implication(self, f: 'formula', g: 'formula') -> "bool":
        return _impl.tl_simplifier_syntactic_implication(self, f, g)

    def syntactic_implication_neg(self, f: 'formula', g: 'formula', right: 'bool') -> "bool":
        return _impl.tl_simplifier_syntactic_implication_neg(self, f, g, right)

    def are_equivalent(self, f: 'formula', g: 'formula') -> "bool":
        return _impl.tl_simplifier_are_equivalent(self, f, g)

    def implication(self, f: 'formula', g: 'formula') -> "bool":
        return _impl.tl_simplifier_implication(self, f, g)

    def as_bdd(self, f: 'formula') -> "bdd":
        return _impl.tl_simplifier_as_bdd(self, f)

    def clear_as_bdd_cache(self) -> "void":
        return _impl.tl_simplifier_clear_as_bdd_cache(self)

    def clear_caches(self) -> "void":
        return _impl.tl_simplifier_clear_caches(self)

    def get_dict(self) -> "spot::bdd_dict_ptr":
        return _impl.tl_simplifier_get_dict(self)

    def star_normal_form(self, f: 'formula') -> "spot::formula":
        return _impl.tl_simplifier_star_normal_form(self, f)

    def boolean_to_isop(self, f: 'formula') -> "spot::formula":
        return _impl.tl_simplifier_boolean_to_isop(self, f)

    def print_stats(self, os: 'ostream') -> "void":
        return _impl.tl_simplifier_print_stats(self, os)
tl_simplifier_swigregister = _impl.tl_simplifier_swigregister
tl_simplifier_swigregister(tl_simplifier)

class unabbreviator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _impl.unabbreviator_swiginit(self, _impl.new_unabbreviator(*args))

    def run(self, arg2: 'formula') -> "spot::formula":
        return _impl.unabbreviator_run(self, arg2)
    __swig_destroy__ = _impl.delete_unabbreviator
unabbreviator_swigregister = _impl.unabbreviator_swigregister
unabbreviator_swigregister(unabbreviator)
cvar = _impl.cvar
default_unabbrev_string = cvar.default_unabbrev_string


def unabbreviate(*args) -> "spot::formula":
    return _impl.unabbreviate(*args)
unabbreviate = _impl.unabbreviate
OUTPUTBOOL = _impl.OUTPUTBOOL
OUTPUTLTL = _impl.OUTPUTLTL
OUTPUTSERE = _impl.OUTPUTSERE
OUTPUTPSL = _impl.OUTPUTPSL
MAX_TRIALS = _impl.MAX_TRIALS
class random_formula(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, proba_size: 'unsigned int', ap: 'atomic_prop_set'):
        _impl.random_formula_swiginit(self, _impl.new_random_formula(proba_size, ap))
    __swig_destroy__ = _impl.delete_random_formula

    def ap(self) -> "spot::atomic_prop_set const *":
        return _impl.random_formula_ap(self)

    def generate(self, n: 'int') -> "spot::formula":
        return _impl.random_formula_generate(self, n)

    def dump_priorities(self, os: 'ostream') -> "std::ostream &":
        return _impl.random_formula_dump_priorities(self, os)

    def parse_options(self, options: 'char *') -> "char const *":
        return _impl.random_formula_parse_options(self, options)
random_formula_swigregister = _impl.random_formula_swigregister
random_formula_swigregister(random_formula)

class random_ltl(random_formula):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, ap: 'atomic_prop_set'):
        _impl.random_ltl_swiginit(self, _impl.new_random_ltl(ap))
    __swig_destroy__ = _impl.delete_random_ltl
random_ltl_swigregister = _impl.random_ltl_swigregister
random_ltl_swigregister(random_ltl)

class random_boolean(random_formula):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, ap: 'atomic_prop_set'):
        _impl.random_boolean_swiginit(self, _impl.new_random_boolean(ap))
    __swig_destroy__ = _impl.delete_random_boolean
random_boolean_swigregister = _impl.random_boolean_swigregister
random_boolean_swigregister(random_boolean)

class random_sere(random_formula):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, ap: 'atomic_prop_set'):
        _impl.random_sere_swiginit(self, _impl.new_random_sere(ap))
    rb = _swig_property(_impl.random_sere_rb_get, _impl.random_sere_rb_set)
    __swig_destroy__ = _impl.delete_random_sere
random_sere_swigregister = _impl.random_sere_swigregister
random_sere_swigregister(random_sere)

class random_psl(random_ltl):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, ap: 'atomic_prop_set'):
        _impl.random_psl_swiginit(self, _impl.new_random_psl(ap))
    rs = _swig_property(_impl.random_psl_rs_get, _impl.random_psl_rs_set)
    __swig_destroy__ = _impl.delete_random_psl
random_psl_swigregister = _impl.random_psl_swigregister
random_psl_swigregister(random_psl)

class randltlgenerator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _impl.randltlgenerator_swiginit(self, _impl.new_randltlgenerator(*args))
    __swig_destroy__ = _impl.delete_randltlgenerator

    def next(self) -> "spot::formula":
        return _impl.randltlgenerator_next(self)

    def dump_ltl_priorities(self, os: 'ostream') -> "void":
        return _impl.randltlgenerator_dump_ltl_priorities(self, os)

    def dump_bool_priorities(self, os: 'ostream') -> "void":
        return _impl.randltlgenerator_dump_bool_priorities(self, os)

    def dump_psl_priorities(self, os: 'ostream') -> "void":
        return _impl.randltlgenerator_dump_psl_priorities(self, os)

    def dump_sere_priorities(self, os: 'ostream') -> "void":
        return _impl.randltlgenerator_dump_sere_priorities(self, os)

    def dump_sere_bool_priorities(self, os: 'ostream') -> "void":
        return _impl.randltlgenerator_dump_sere_bool_priorities(self, os)

    def remove_some_props(self, s: 'atomic_prop_set') -> "void":
        return _impl.randltlgenerator_remove_some_props(self, s)

    def GF_n(self) -> "spot::formula":
        return _impl.randltlgenerator_GF_n(self)
randltlgenerator_swigregister = _impl.randltlgenerator_swigregister
randltlgenerator_swigregister(randltlgenerator)


def length(f: 'formula') -> "int":
    return _impl.length(f)
length = _impl.length

def length_boolone(f: 'formula') -> "int":
    return _impl.length_boolone(f)
length_boolone = _impl.length_boolone

def from_ltlf(*args) -> "spot::formula":
    return _impl.from_ltlf(*args)
from_ltlf = _impl.from_ltlf
prcheck_Auto = _impl.prcheck_Auto
prcheck_via_CoBuchi = _impl.prcheck_via_CoBuchi
prcheck_via_Rabin = _impl.prcheck_via_Rabin

def is_persistence(*args) -> "bool":
    return _impl.is_persistence(*args)
is_persistence = _impl.is_persistence

def is_recurrence(*args) -> "bool":
    return _impl.is_recurrence(*args)
is_recurrence = _impl.is_recurrence
ocheck_Auto = _impl.ocheck_Auto
ocheck_via_CoBuchi = _impl.ocheck_via_CoBuchi
ocheck_via_Rabin = _impl.ocheck_via_Rabin
ocheck_via_WDBA = _impl.ocheck_via_WDBA

def is_obligation(*args) -> "bool":
    return _impl.is_obligation(*args)
is_obligation = _impl.is_obligation

def mp_class(*args) -> "std::string":
    return _impl.mp_class(*args)
mp_class = _impl.mp_class

def nesting_depth(*args) -> "unsigned int":
    return _impl.nesting_depth(*args)
nesting_depth = _impl.nesting_depth

def remove_x(f: 'formula') -> "spot::formula":
    return _impl.remove_x(f)
remove_x = _impl.remove_x
Abc = _impl.Abc
Pnn = _impl.Pnn

def relabel(f: 'formula', style: 'spot::relabeling_style', m: 'relabeling_map'=None) -> "spot::formula":
    return _impl.relabel(f, style, m)
relabel = _impl.relabel

def relabel_bse(f: 'formula', style: 'spot::relabeling_style', m: 'relabeling_map'=None) -> "spot::formula":
    return _impl.relabel_bse(f, style, m)
relabel_bse = _impl.relabel_bse
class taa_tgba(twa):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def add_condition(self, t: 'spot::taa_tgba::transition *', f: 'formula') -> "void":
        return _impl.taa_tgba_add_condition(self, t, f)
    __swig_destroy__ = _impl.delete_taa_tgba

    def get_init_state(self) -> "spot::state *":
        return _impl.taa_tgba_get_init_state(self)
taa_tgba_swigregister = _impl.taa_tgba_swigregister
taa_tgba_swigregister(taa_tgba)

class set_state(state):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, s: 'spot::taa_tgba::state_set const *', delete_me: 'bool'=False):
        _impl.set_state_swiginit(self, _impl.new_set_state(s, delete_me))

    def clone(self) -> "spot::set_state *":
        return _impl.set_state_clone(self)
    __swig_destroy__ = _impl.delete_set_state

    def get_state(self) -> "spot::taa_tgba::state_set const *":
        return _impl.set_state_get_state(self)
set_state_swigregister = _impl.set_state_swigregister
set_state_swigregister(set_state)

class taa_succ_iterator(twa_succ_iterator):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, s: 'spot::taa_tgba::state_set const *', acc: 'acc_cond'):
        _impl.taa_succ_iterator_swiginit(self, _impl.new_taa_succ_iterator(s, acc))
    __swig_destroy__ = _impl.delete_taa_succ_iterator

    def dst(self) -> "spot::set_state *":
        return _impl.taa_succ_iterator_dst(self)
taa_succ_iterator_swigregister = _impl.taa_succ_iterator_swigregister
taa_succ_iterator_swigregister(taa_succ_iterator)

class taa_tgba_string(taa_tgba):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _impl.delete_taa_tgba_string
taa_tgba_string_swigregister = _impl.taa_tgba_string_swigregister
taa_tgba_string_swigregister(taa_tgba_string)


def make_taa_tgba_string(dict: 'spot::bdd_dict_ptr const &') -> "spot::taa_tgba_string_ptr":
    return _impl.make_taa_tgba_string(dict)
make_taa_tgba_string = _impl.make_taa_tgba_string
class taa_tgba_formula(taa_tgba):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _impl.delete_taa_tgba_formula
taa_tgba_formula_swigregister = _impl.taa_tgba_formula_swigregister
taa_tgba_formula_swigregister(taa_tgba_formula)


def make_taa_tgba_formula(dict: 'spot::bdd_dict_ptr const &') -> "spot::taa_tgba_formula_ptr":
    return _impl.make_taa_tgba_formula(dict)
make_taa_tgba_formula = _impl.make_taa_tgba_formula
class state_product(state):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, left: 'state', right: 'state', pool: 'fixed_size_pool *'):
        _impl.state_product_swiginit(self, _impl.new_state_product(left, right, pool))

    def left(self) -> "spot::state const *":
        return _impl.state_product_left(self)

    def right(self) -> "spot::state const *":
        return _impl.state_product_right(self)

    def clone(self) -> "spot::state_product *":
        return _impl.state_product_clone(self)
state_product_swigregister = _impl.state_product_swigregister
state_product_swigregister(state_product)

class twa_product(twa):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, left: 'spot::const_twa_ptr const &', right: 'spot::const_twa_ptr const &'):
        _impl.twa_product_swiginit(self, _impl.new_twa_product(left, right))
    __swig_destroy__ = _impl.delete_twa_product

    def left_acc(self) -> "spot::acc_cond const &":
        return _impl.twa_product_left_acc(self)

    def right_acc(self) -> "spot::acc_cond const &":
        return _impl.twa_product_right_acc(self)
twa_product_swigregister = _impl.twa_product_swigregister
twa_product_swigregister(twa_product)

class twa_product_init(twa_product):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, left: 'spot::const_twa_ptr const &', right: 'spot::const_twa_ptr const &', left_init: 'state', right_init: 'state'):
        _impl.twa_product_init_swiginit(self, _impl.new_twa_product_init(left, right, left_init, right_init))
    __swig_destroy__ = _impl.delete_twa_product_init
twa_product_init_swigregister = _impl.twa_product_init_swigregister
twa_product_init_swigregister(twa_product_init)


def otf_product(left: 'spot::const_twa_ptr const &', right: 'spot::const_twa_ptr const &') -> "spot::twa_product_ptr":
    return _impl.otf_product(left, right)
otf_product = _impl.otf_product

def otf_product_at(left: 'spot::const_twa_ptr const &', right: 'spot::const_twa_ptr const &', left_init: 'state', right_init: 'state') -> "spot::twa_product_ptr":
    return _impl.otf_product_at(left, right, left_init, right_init)
otf_product_at = _impl.otf_product_at
class const_universal_dests(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _impl.const_universal_dests_swiginit(self, _impl.new_const_universal_dests(*args))

    def begin(self) -> "unsigned int const *":
        return _impl.const_universal_dests_begin(self)

    def end(self) -> "unsigned int const *":
        return _impl.const_universal_dests_end(self)

    def __iter__(self) -> "swig::SwigPyIterator *":
        return _impl.const_universal_dests___iter__(self)
    __swig_destroy__ = _impl.delete_const_universal_dests
const_universal_dests_swigregister = _impl.const_universal_dests_swigregister
const_universal_dests_swigregister(const_universal_dests)

class twa_graph_state(state):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        _impl.twa_graph_state_swiginit(self, _impl.new_twa_graph_state())
    __swig_destroy__ = _impl.delete_twa_graph_state

    def clone(self) -> "spot::twa_graph_state *":
        return _impl.twa_graph_state_clone(self)
twa_graph_state_swigregister = _impl.twa_graph_state_swigregister
twa_graph_state_swigregister(twa_graph_state)

class twa_graph_edge_data(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    cond = _swig_property(_impl.twa_graph_edge_data_cond_get, _impl.twa_graph_edge_data_cond_set)
    acc = _swig_property(_impl.twa_graph_edge_data_acc_get, _impl.twa_graph_edge_data_acc_set)

    def __init__(self, *args):
        _impl.twa_graph_edge_data_swiginit(self, _impl.new_twa_graph_edge_data(*args))

    def __lt__(self, other: 'twa_graph_edge_data') -> "bool":
        return _impl.twa_graph_edge_data___lt__(self, other)

    def __eq__(self, other: 'twa_graph_edge_data') -> "bool":
        return _impl.twa_graph_edge_data___eq__(self, other)
    __swig_destroy__ = _impl.delete_twa_graph_edge_data
twa_graph_edge_data_swigregister = _impl.twa_graph_edge_data_swigregister
twa_graph_edge_data_swigregister(twa_graph_edge_data)

class twa_graph(twa):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _impl.twa_graph_swiginit(self, _impl.new_twa_graph(*args))
    __swig_destroy__ = _impl.delete_twa_graph

    def get_graph(self, *args) -> "spot::twa_graph::graph_t const &":
        return _impl.twa_graph_get_graph(self, *args)

    def num_states(self) -> "unsigned int":
        return _impl.twa_graph_num_states(self)

    def num_edges(self) -> "unsigned int":
        return _impl.twa_graph_num_edges(self)

    def set_init_state(self, s: 'spot::twa_graph::state_num') -> "void":
        return _impl.twa_graph_set_init_state(self, s)

    def get_init_state_number(self) -> "spot::twa_graph::state_num":
        return _impl.twa_graph_get_init_state_number(self)

    def get_init_state(self) -> "spot::twa_graph_state const *":
        return _impl.twa_graph_get_init_state(self)
    is_univ_dest = staticmethod(_impl.twa_graph_is_univ_dest)

    def state_number(self, st: 'state') -> "spot::twa_graph::state_num":
        return _impl.twa_graph_state_number(self, st)

    def state_from_number(self, src: 'unsigned int') -> "spot::twa_graph_state const *":
        self.report_univ_dest(src)
        return _impl.twa_graph_state_from_number(self, src)



    def format_state(self, *args) -> "std::string":
        return _impl.twa_graph_format_state(self, *args)

    def edge_number(self, *args) -> "unsigned int":
        return _impl.twa_graph_edge_number(self, *args)

    def edge_data(self, *args) -> "spot::twa_graph_edge_data const &":
        return _impl.twa_graph_edge_data(self, *args)

    def edge_storage(self, *args) -> "spot::twa_graph::edge_storage_t const":
        return _impl.twa_graph_edge_storage(self, *args)

    def new_state(self) -> "unsigned int":
        return _impl.twa_graph_new_state(self)

    def new_states(self, n: 'unsigned int') -> "unsigned int":
        return _impl.twa_graph_new_states(self, n)

    def new_edge(self, src: 'unsigned int', dst: 'unsigned int', cond: 'bdd', acc: 'mark_t'=0) -> "unsigned int":
        return _impl.twa_graph_new_edge(self, src, dst, cond, acc)

    def new_acc_edge(self, src: 'unsigned int', dst: 'unsigned int', cond: 'bdd', acc: 'bool'=True) -> "unsigned int":
        return _impl.twa_graph_new_acc_edge(self, src, dst, cond, acc)

    def out(self, src: 'unsigned int'):
        self.report_univ_dest(src)
        return _impl.twa_graph_out(self, src)



    def univ_dests(self, *args) -> "spot::internal::const_universal_dests":
        return _impl.twa_graph_univ_dests(self, *args)

    def is_existential(self) -> "bool":
        return _impl.twa_graph_is_existential(self)

    def edges(self) -> "spot::internal::all_trans< spot::twa_graph::graph_t >":
        return _impl.twa_graph_edges(self)

    def merge_edges(self) -> "void":
        return _impl.twa_graph_merge_edges(self)

    def merge_univ_dests(self) -> "void":
        return _impl.twa_graph_merge_univ_dests(self)

    def purge_dead_states(self) -> "void":
        return _impl.twa_graph_purge_dead_states(self)

    def purge_unreachable_states(self) -> "void":
        return _impl.twa_graph_purge_unreachable_states(self)

    def remove_unused_ap(self) -> "void":
        return _impl.twa_graph_remove_unused_ap(self)

    def copy_state_names_from(self, other: 'spot::const_twa_graph_ptr const &') -> "void":
        return _impl.twa_graph_copy_state_names_from(self, other)

    def state_acc_sets(self, src: 'unsigned int') -> "spot::acc_cond::mark_t":
        self.report_univ_dest(src)
        return _impl.twa_graph_state_acc_sets(self, src)



    def state_is_accepting(self, src) -> "bool":
        if type(src) == int:
            self.report_univ_dest(src)
        return _impl.twa_graph_state_is_accepting(self, src)



    def __eq__(self, aut: 'twa_graph') -> "bool":
        return _impl.twa_graph___eq__(self, aut)

    def defrag_states(self, newst: 'vectorunsigned', used_states: 'unsigned int') -> "void":
        return _impl.twa_graph_defrag_states(self, newst, used_states)

    def new_univ_edge(self, *args) -> "unsigned int":
        return _impl.twa_graph_new_univ_edge(self, *args)

    def set_univ_init_state(self, *args) -> "void":
        return _impl.twa_graph_set_univ_init_state(self, *args)

    def report_univ_dest(self, src: 'unsigned int') -> "void":
        return _impl.twa_graph_report_univ_dest(self, src)
twa_graph_swigregister = _impl.twa_graph_swigregister
twa_graph_swigregister(twa_graph)

def twa_graph_is_univ_dest(*args) -> "bool":
    return _impl.twa_graph_is_univ_dest(*args)
twa_graph_is_univ_dest = _impl.twa_graph_is_univ_dest


def make_twa_graph(*args) -> "spot::twa_graph_ptr":
    return _impl.make_twa_graph(*args)
make_twa_graph = _impl.make_twa_graph
class twa_graph_state_out(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, g: 'spot::digraph< spot::twa_graph_state,spot::twa_graph_edge_data > *', t: 'spot::internal::state_out< spot::digraph< spot::twa_graph_state,spot::twa_graph_edge_data > >::edge'):
        _impl.twa_graph_state_out_swiginit(self, _impl.new_twa_graph_state_out(g, t))

    def begin(self) -> "spot::internal::edge_iterator< spot::digraph< spot::twa_graph_state,spot::twa_graph_edge_data > >":
        return _impl.twa_graph_state_out_begin(self)

    def end(self) -> "spot::internal::edge_iterator< spot::digraph< spot::twa_graph_state,spot::twa_graph_edge_data > >":
        return _impl.twa_graph_state_out_end(self)

    def recycle(self, t: 'spot::internal::state_out< spot::digraph< spot::twa_graph_state,spot::twa_graph_edge_data > >::edge') -> "void":
        return _impl.twa_graph_state_out_recycle(self, t)

    def __iter__(self) -> "swig::SwigPyIterator *":
        return _impl.twa_graph_state_out___iter__(self)
    __swig_destroy__ = _impl.delete_twa_graph_state_out
twa_graph_state_out_swigregister = _impl.twa_graph_state_out_swigregister
twa_graph_state_out_swigregister(twa_graph_state_out)

class twa_graph_all_trans(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, tv: 'spot::internal::all_trans< spot::digraph< spot::twa_graph_state,spot::twa_graph_edge_data > >::tv_t &'):
        _impl.twa_graph_all_trans_swiginit(self, _impl.new_twa_graph_all_trans(tv))

    def begin(self) -> "spot::internal::all_trans< spot::digraph< spot::twa_graph_state,spot::twa_graph_edge_data > >::iter_t":
        return _impl.twa_graph_all_trans_begin(self)

    def end(self) -> "spot::internal::all_trans< spot::digraph< spot::twa_graph_state,spot::twa_graph_edge_data > >::iter_t":
        return _impl.twa_graph_all_trans_end(self)

    def __iter__(self) -> "swig::SwigPyIterator *":
        return _impl.twa_graph_all_trans___iter__(self)
    __swig_destroy__ = _impl.delete_twa_graph_all_trans
twa_graph_all_trans_swigregister = _impl.twa_graph_all_trans_swigregister
twa_graph_all_trans_swigregister(twa_graph_all_trans)

class twa_graph_edge_boxed_data(twa_graph_edge_data):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        _impl.twa_graph_edge_boxed_data_swiginit(self, _impl.new_twa_graph_edge_boxed_data())

    def data(self, *args) -> "spot::twa_graph_edge_data const &":
        return _impl.twa_graph_edge_boxed_data_data(self, *args)
    __swig_destroy__ = _impl.delete_twa_graph_edge_boxed_data
twa_graph_edge_boxed_data_swigregister = _impl.twa_graph_edge_boxed_data_swigregister
twa_graph_edge_boxed_data_swigregister(twa_graph_edge_boxed_data)

class twa_graph_edge_storage(twa_graph_edge_boxed_data):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    dst = _swig_property(_impl.twa_graph_edge_storage_dst_get, _impl.twa_graph_edge_storage_dst_set)
    next_succ = _swig_property(_impl.twa_graph_edge_storage_next_succ_get, _impl.twa_graph_edge_storage_next_succ_set)
    src = _swig_property(_impl.twa_graph_edge_storage_src_get, _impl.twa_graph_edge_storage_src_set)

    def __init__(self):
        _impl.twa_graph_edge_storage_swiginit(self, _impl.new_twa_graph_edge_storage())

    def __lt__(self, other: 'twa_graph_edge_storage') -> "bool":
        return _impl.twa_graph_edge_storage___lt__(self, other)

    def __eq__(self, other: 'twa_graph_edge_storage') -> "bool":
        return _impl.twa_graph_edge_storage___eq__(self, other)
    __swig_destroy__ = _impl.delete_twa_graph_edge_storage
twa_graph_edge_storage_swigregister = _impl.twa_graph_edge_storage_swigregister
twa_graph_edge_storage_swigregister(twa_graph_edge_storage)

class outedge_combiner(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, aut: 'spot::twa_graph_ptr const &'):
        _impl.outedge_combiner_swiginit(self, _impl.new_outedge_combiner(aut))
    __swig_destroy__ = _impl.delete_outedge_combiner

    def __call__(self, st: 'unsigned int') -> "bdd":
        return _impl.outedge_combiner___call__(self, st)

    def new_dests(self, st: 'unsigned int', out: 'bdd') -> "void":
        return _impl.outedge_combiner_new_dests(self, st, out)
outedge_combiner_swigregister = _impl.outedge_combiner_swigregister
outedge_combiner_swigregister(outedge_combiner)


def remove_alternation(aut: 'spot::const_twa_graph_ptr const &', named_states: 'bool'=False) -> "spot::twa_graph_ptr":
    return _impl.remove_alternation(aut, named_states)
remove_alternation = _impl.remove_alternation
class univ_remover_state(state):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, states: 'std::set< unsigned int,std::less< unsigned int >,std::allocator< unsigned int > > const &'):
        _impl.univ_remover_state_swiginit(self, _impl.new_univ_remover_state(states))

    def states(self) -> "std::set< unsigned int,std::less< unsigned int >,std::allocator< unsigned int > > const &":
        return _impl.univ_remover_state_states(self)

    def is_reset(self) -> "bool":
        return _impl.univ_remover_state_is_reset(self)
    __swig_destroy__ = _impl.delete_univ_remover_state
univ_remover_state_swigregister = _impl.univ_remover_state_swigregister
univ_remover_state_swigregister(univ_remover_state)

class twa_univ_remover(twa):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, aut: 'spot::const_twa_graph_ptr const &'):
        _impl.twa_univ_remover_swiginit(self, _impl.new_twa_univ_remover(aut))

    def allocate_state_vars(self) -> "void":
        return _impl.twa_univ_remover_allocate_state_vars(self)
    __swig_destroy__ = _impl.delete_twa_univ_remover
twa_univ_remover_swigregister = _impl.twa_univ_remover_swigregister
twa_univ_remover_swigregister(twa_univ_remover)


def remove_univ_otf(aut: 'spot::const_twa_graph_ptr const &') -> "spot::twa_univ_remover_ptr":
    return _impl.remove_univ_otf(aut)
remove_univ_otf = _impl.remove_univ_otf

def cleanup_acceptance_here(aut: 'spot::twa_graph_ptr', strip: 'bool'=True) -> "spot::twa_graph_ptr":
    return _impl.cleanup_acceptance_here(aut, strip)
cleanup_acceptance_here = _impl.cleanup_acceptance_here

def cleanup_acceptance(aut: 'spot::const_twa_graph_ptr') -> "spot::twa_graph_ptr":
    return _impl.cleanup_acceptance(aut)
cleanup_acceptance = _impl.cleanup_acceptance

def simplify_acceptance_here(aut: 'spot::twa_graph_ptr') -> "spot::twa_graph_ptr":
    return _impl.simplify_acceptance_here(aut)
simplify_acceptance_here = _impl.simplify_acceptance_here

def simplify_acceptance(aut: 'spot::const_twa_graph_ptr') -> "spot::twa_graph_ptr":
    return _impl.simplify_acceptance(aut)
simplify_acceptance = _impl.simplify_acceptance

def degeneralize(a: 'spot::const_twa_graph_ptr const &', use_z_lvl: 'bool'=True, use_cust_acc_orders: 'bool'=False, use_lvl_cache: 'int'=1, skip_levels: 'bool'=True, ignaccsl: 'bool'=False, remove_extra_scc: 'bool'=True) -> "spot::twa_graph_ptr":
    return _impl.degeneralize(a, use_z_lvl, use_cust_acc_orders, use_lvl_cache, skip_levels, ignaccsl, remove_extra_scc)
degeneralize = _impl.degeneralize

def degeneralize_tba(a: 'spot::const_twa_graph_ptr const &', use_z_lvl: 'bool'=True, use_cust_acc_orders: 'bool'=False, use_lvl_cache: 'int'=1, skip_levels: 'bool'=True, ignaccsl: 'bool'=False, remove_extra_scc: 'bool'=True) -> "spot::twa_graph_ptr":
    return _impl.degeneralize_tba(a, use_z_lvl, use_cust_acc_orders, use_lvl_cache, skip_levels, ignaccsl, remove_extra_scc)
degeneralize_tba = _impl.degeneralize_tba
class nca_st_info(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    clause_num = _swig_property(_impl.nca_st_info_clause_num_get, _impl.nca_st_info_clause_num_set)
    state_num = _swig_property(_impl.nca_st_info_state_num_get, _impl.nca_st_info_state_num_set)
    all_dst = _swig_property(_impl.nca_st_info_all_dst_get, _impl.nca_st_info_all_dst_set)

    def __init__(self, clause: 'unsigned int', st: 'unsigned int', dst: 'bitvect *'):
        _impl.nca_st_info_swiginit(self, _impl.new_nca_st_info(clause, st, dst))
    __swig_destroy__ = _impl.delete_nca_st_info
nca_st_info_swigregister = _impl.nca_st_info_swigregister
nca_st_info_swigregister(nca_st_info)


def nsa_to_nca(aut: 'spot::const_twa_graph_ptr', named_states: 'bool'=False, nca_info: 'spot::vect_nca_info *'=None) -> "spot::twa_graph_ptr":
    return _impl.nsa_to_nca(aut, named_states, nca_info)
nsa_to_nca = _impl.nsa_to_nca

def dnf_to_nca(aut: 'spot::const_twa_graph_ptr', named_states: 'bool'=False, nca_info: 'spot::vect_nca_info *'=None) -> "spot::twa_graph_ptr":
    return _impl.dnf_to_nca(aut, named_states, nca_info)
dnf_to_nca = _impl.dnf_to_nca

def to_nca(aut: 'spot::const_twa_graph_ptr', named_states: 'bool'=False) -> "spot::twa_graph_ptr":
    return _impl.to_nca(aut, named_states)
to_nca = _impl.to_nca

def nsa_to_dca(aut: 'spot::const_twa_graph_ptr', named_states: 'bool'=False) -> "spot::twa_graph_ptr":
    return _impl.nsa_to_dca(aut, named_states)
nsa_to_dca = _impl.nsa_to_dca

def dnf_to_dca(aut: 'spot::const_twa_graph_ptr', named_states: 'bool'=False) -> "spot::twa_graph_ptr":
    return _impl.dnf_to_dca(aut, named_states)
dnf_to_dca = _impl.dnf_to_dca

def to_dca(aut: 'spot::const_twa_graph_ptr', named_states: 'bool'=False) -> "spot::twa_graph_ptr":
    return _impl.to_dca(aut, named_states)
to_dca = _impl.to_dca

def copy(aut: 'spot::const_twa_ptr const &', p: 'spot::twa::prop_set', preserve_names: 'bool'=False, max_states: 'unsigned int'=-1) -> "spot::twa_graph_ptr":
    return _impl.copy(aut, p, preserve_names, max_states)
copy = _impl.copy

def complete_here(aut: 'spot::twa_graph_ptr') -> "void":
    return _impl.complete_here(aut)
complete_here = _impl.complete_here

def complete(aut: 'spot::const_twa_ptr const &') -> "spot::twa_graph_ptr":
    return _impl.complete(aut)
complete = _impl.complete
class emptiness_check_result(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _impl.emptiness_check_result_swiginit(self, _impl.new_emptiness_check_result(*args))
    __swig_destroy__ = _impl.delete_emptiness_check_result

    def accepting_run(self) -> "spot::twa_run_ptr":
        return _impl.emptiness_check_result_accepting_run(self)

    def automaton(self) -> "spot::const_twa_ptr const &":
        return _impl.emptiness_check_result_automaton(self)

    def options(self) -> "spot::option_map const &":
        return _impl.emptiness_check_result_options(self)

    def parse_options(self, options: 'char *') -> "char const *":
        return _impl.emptiness_check_result_parse_options(self, options)

    def statistics(self) -> "unsigned_statistics const *":
        return _impl.emptiness_check_result_statistics(self)
emptiness_check_result_swigregister = _impl.emptiness_check_result_swigregister
emptiness_check_result_swigregister(emptiness_check_result)

class emptiness_check(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _impl.delete_emptiness_check

    def automaton(self) -> "spot::const_twa_ptr const &":
        return _impl.emptiness_check_automaton(self)

    def options(self) -> "spot::option_map const &":
        return _impl.emptiness_check_options(self)

    def parse_options(self, options: 'char *') -> "char const *":
        return _impl.emptiness_check_parse_options(self, options)

    def safe(self) -> "bool":
        return _impl.emptiness_check_safe(self)

    def check(self) -> "spot::emptiness_check_result_ptr":
        return _impl.emptiness_check_check(self)

    def statistics(self) -> "unsigned_statistics const *":
        return _impl.emptiness_check_statistics(self)

    def emptiness_check_statistics(self) -> "ec_statistics const *":
        return _impl.emptiness_check_emptiness_check_statistics(self)

    def print_stats(self, os: 'ostream') -> "std::ostream &":
        return _impl.emptiness_check_print_stats(self, os)

    def options_updated(self, old: 'option_map') -> "void":
        return _impl.emptiness_check_options_updated(self, old)
emptiness_check_swigregister = _impl.emptiness_check_swigregister
emptiness_check_swigregister(emptiness_check)

class emptiness_check_instantiator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def instantiate(self, a: 'spot::const_twa_ptr const &') -> "spot::emptiness_check_ptr":
        return _impl.emptiness_check_instantiator_instantiate(self, a)

    def options(self, *args) -> "spot::option_map &":
        return _impl.emptiness_check_instantiator_options(self, *args)

    def min_sets(self) -> "unsigned int":
        return _impl.emptiness_check_instantiator_min_sets(self)

    def max_sets(self) -> "unsigned int":
        return _impl.emptiness_check_instantiator_max_sets(self)
    __swig_destroy__ = _impl.delete_emptiness_check_instantiator
emptiness_check_instantiator_swigregister = _impl.emptiness_check_instantiator_swigregister
emptiness_check_instantiator_swigregister(emptiness_check_instantiator)


def make_emptiness_check_instantiator(name: 'char const *') -> "char **":
    return _impl.make_emptiness_check_instantiator(name)
make_emptiness_check_instantiator = _impl.make_emptiness_check_instantiator
class twa_run(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    prefix = _swig_property(_impl.twa_run_prefix_get, _impl.twa_run_prefix_set)
    cycle = _swig_property(_impl.twa_run_cycle_get, _impl.twa_run_cycle_set)
    aut = _swig_property(_impl.twa_run_aut_get, _impl.twa_run_aut_set)
    __swig_destroy__ = _impl.delete_twa_run

    def __init__(self, *args):
        _impl.twa_run_swiginit(self, _impl.new_twa_run(*args))

    def reduce(self) -> "spot::twa_run_ptr":
        return _impl.twa_run_reduce(self)

    def project(self, other: 'spot::const_twa_ptr const &', right: 'bool'=False) -> "spot::twa_run_ptr":
        return _impl.twa_run_project(self, other, right)

    def replay(self, os: 'ostream', debug: 'bool'=False) -> "bool":
        return _impl.twa_run_replay(self, os, debug)

    def highlight(self, color: 'unsigned int') -> "void":
        return _impl.twa_run_highlight(self, color)

    def as_twa(self, preserve_names: 'bool'=False) -> "spot::twa_graph_ptr":
        return _impl.twa_run_as_twa(self, preserve_names)

    def __repr__(self) -> "std::string":
        return _impl.twa_run___repr__(self)

    def __str__(self) -> "std::string":
        return _impl.twa_run___str__(self)
twa_run_swigregister = _impl.twa_run_swigregister
twa_run_swigregister(twa_run)

class step(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    s = _swig_property(_impl.step_s_get, _impl.step_s_set)
    label = _swig_property(_impl.step_label_get, _impl.step_label_set)
    acc = _swig_property(_impl.step_acc_get, _impl.step_acc_set)

    def __init__(self, *args):
        _impl.step_swiginit(self, _impl.new_step(*args))
    __swig_destroy__ = _impl.delete_step
step_swigregister = _impl.step_swigregister
step_swigregister(step)

class list_step(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _impl.list_step_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _impl.list_step___nonzero__(self)

    def __bool__(self) -> "bool":
        return _impl.list_step___bool__(self)

    def __len__(self) -> "std::list< spot::twa_run::step >::size_type":
        return _impl.list_step___len__(self)

    def __getslice__(self, i: 'std::list< spot::twa_run::step >::difference_type', j: 'std::list< spot::twa_run::step >::difference_type') -> "std::list< spot::twa_run::step,std::allocator< spot::twa_run::step > > *":
        return _impl.list_step___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _impl.list_step___setslice__(self, *args)

    def __delslice__(self, i: 'std::list< spot::twa_run::step >::difference_type', j: 'std::list< spot::twa_run::step >::difference_type') -> "void":
        return _impl.list_step___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _impl.list_step___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::list< spot::twa_run::step >::value_type const &":
        return _impl.list_step___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _impl.list_step___setitem__(self, *args)

    def pop(self) -> "std::list< spot::twa_run::step >::value_type":
        return _impl.list_step_pop(self)

    def append(self, x: 'step') -> "void":
        return _impl.list_step_append(self, x)

    def empty(self) -> "bool":
        return _impl.list_step_empty(self)

    def size(self) -> "std::list< spot::twa_run::step >::size_type":
        return _impl.list_step_size(self)

    def swap(self, v: 'list_step') -> "void":
        return _impl.list_step_swap(self, v)

    def begin(self) -> "std::list< spot::twa_run::step >::iterator":
        return _impl.list_step_begin(self)

    def end(self) -> "std::list< spot::twa_run::step >::iterator":
        return _impl.list_step_end(self)

    def rbegin(self) -> "std::list< spot::twa_run::step >::reverse_iterator":
        return _impl.list_step_rbegin(self)

    def rend(self) -> "std::list< spot::twa_run::step >::reverse_iterator":
        return _impl.list_step_rend(self)

    def clear(self) -> "void":
        return _impl.list_step_clear(self)

    def get_allocator(self) -> "std::list< spot::twa_run::step >::allocator_type":
        return _impl.list_step_get_allocator(self)

    def pop_back(self) -> "void":
        return _impl.list_step_pop_back(self)

    def erase(self, *args) -> "std::list< spot::twa_run::step >::iterator":
        return _impl.list_step_erase(self, *args)

    def __init__(self, *args):
        _impl.list_step_swiginit(self, _impl.new_list_step(*args))

    def push_back(self, x: 'step') -> "void":
        return _impl.list_step_push_back(self, x)

    def front(self) -> "std::list< spot::twa_run::step >::value_type const &":
        return _impl.list_step_front(self)

    def back(self) -> "std::list< spot::twa_run::step >::value_type const &":
        return _impl.list_step_back(self)

    def assign(self, n: 'std::list< spot::twa_run::step >::size_type', x: 'step') -> "void":
        return _impl.list_step_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _impl.list_step_resize(self, *args)

    def insert(self, *args) -> "void":
        return _impl.list_step_insert(self, *args)

    def pop_front(self) -> "void":
        return _impl.list_step_pop_front(self)

    def push_front(self, x: 'step') -> "void":
        return _impl.list_step_push_front(self, x)

    def reverse(self) -> "void":
        return _impl.list_step_reverse(self)
    __swig_destroy__ = _impl.delete_list_step
list_step_swigregister = _impl.list_step_swigregister
list_step_swigregister(list_step)


def couvreur99(*args) -> "spot::emptiness_check_ptr":
    return _impl.couvreur99(*args)
couvreur99 = _impl.couvreur99

def print_lbtt(os: 'ostream', g: 'spot::const_twa_ptr const &', opt: 'char const *'=None) -> "std::ostream &":
    return _impl.print_lbtt(os, g, opt)
print_lbtt = _impl.print_lbtt

def ltl_to_taa(f: 'formula', dict: 'spot::bdd_dict_ptr const &', refined_rules: 'bool'=False) -> "spot::taa_tgba_formula_ptr":
    return _impl.ltl_to_taa(f, dict, refined_rules)
ltl_to_taa = _impl.ltl_to_taa

def ltl_to_tgba_fm(f: 'formula', dict: 'spot::bdd_dict_ptr const &', exprop: 'bool'=False, symb_merge: 'bool'=True, branching_postponement: 'bool'=False, fair_loop_approx: 'bool'=False, unobs: 'atomic_prop_set'=None, simplifier: 'tl_simplifier'=None, unambiguous: 'bool'=False) -> "spot::twa_graph_ptr":
    return _impl.ltl_to_tgba_fm(f, dict, exprop, symb_merge, branching_postponement, fair_loop_approx, unobs, simplifier, unambiguous)
ltl_to_tgba_fm = _impl.ltl_to_tgba_fm

def compsusp(f: 'formula', dict: 'spot::bdd_dict_ptr const &', no_wdba: 'bool'=False, no_simulation: 'bool'=False, early_susp: 'bool'=False, no_susp_product: 'bool'=False, wdba_smaller: 'bool'=False, oblig: 'bool'=False) -> "spot::twa_graph_ptr":
    return _impl.compsusp(f, dict, no_wdba, no_simulation, early_susp, no_susp_product, wdba_smaller, oblig)
compsusp = _impl.compsusp

def tgba_determinize(aut: 'spot::const_twa_graph_ptr const &', pretty_print: 'bool'=False, use_scc: 'bool'=True, use_simulation: 'bool'=True, use_stutter: 'bool'=True) -> "spot::twa_graph_ptr":
    return _impl.tgba_determinize(aut, pretty_print, use_scc, use_simulation, use_stutter)
tgba_determinize = _impl.tgba_determinize

def dualize(aut: 'spot::const_twa_graph_ptr const &') -> "spot::twa_graph_ptr":
    return _impl.dualize(aut)
dualize = _impl.dualize

def language_map(aut: 'spot::const_twa_graph_ptr const &') -> "std::vector< unsigned int,std::allocator< unsigned int > >":
    return _impl.language_map(aut)
language_map = _impl.language_map

def highlight_languages(aut: 'spot::twa_graph_ptr &') -> "void":
    return _impl.highlight_languages(aut)
highlight_languages = _impl.highlight_languages

def explicit_magic_search(*args) -> "spot::emptiness_check_ptr":
    return _impl.explicit_magic_search(*args)
explicit_magic_search = _impl.explicit_magic_search

def bit_state_hashing_magic_search(*args) -> "spot::emptiness_check_ptr":
    return _impl.bit_state_hashing_magic_search(*args)
bit_state_hashing_magic_search = _impl.bit_state_hashing_magic_search

def magic_search(*args) -> "spot::emptiness_check_ptr":
    return _impl.magic_search(*args)
magic_search = _impl.magic_search

def minimize_monitor(a: 'spot::const_twa_graph_ptr const &') -> "spot::twa_graph_ptr":
    return _impl.minimize_monitor(a)
minimize_monitor = _impl.minimize_monitor

def minimize_wdba(a: 'spot::const_twa_graph_ptr const &') -> "spot::twa_graph_ptr":
    return _impl.minimize_wdba(a)
minimize_wdba = _impl.minimize_wdba

def minimize_obligation(aut_f: 'spot::const_twa_graph_ptr const &', f: 'formula'=0, aut_neg_f: 'spot::const_twa_graph_ptr'=0, reject_bigger: 'bool'=False) -> "spot::twa_graph_ptr":
    return _impl.minimize_obligation(aut_f, f, aut_neg_f, reject_bigger)
minimize_obligation = _impl.minimize_obligation

def print_never_claim(os: 'ostream', g: 'spot::const_twa_ptr const &', opt: 'char const *'=None) -> "std::ostream &":
    return _impl.print_never_claim(os, g, opt)
print_never_claim = _impl.print_never_claim

def randomize(aut: 'spot::twa_graph_ptr &', randomize_states: 'bool'=True, randomize_edges: 'bool'=True) -> "void":
    return _impl.randomize(aut, randomize_states, randomize_edges)
randomize = _impl.randomize

def rabin_is_buchi_realizable(aut: 'spot::const_twa_graph_ptr const &') -> "bool":
    return _impl.rabin_is_buchi_realizable(aut)
rabin_is_buchi_realizable = _impl.rabin_is_buchi_realizable

def rabin_to_buchi_maybe(aut: 'spot::const_twa_graph_ptr const &') -> "spot::twa_graph_ptr":
    return _impl.rabin_to_buchi_maybe(aut)
rabin_to_buchi_maybe = _impl.rabin_to_buchi_maybe

def remove_fin(aut: 'spot::const_twa_graph_ptr const &') -> "spot::twa_graph_ptr":
    return _impl.remove_fin(aut)
remove_fin = _impl.remove_fin
class remove_ap(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def add_ap(self, ap_csv: 'char const *') -> "void":
        return _impl.remove_ap_add_ap(self, ap_csv)

    def empty(self) -> "bool":
        return _impl.remove_ap_empty(self)

    def strip(self, aut: 'spot::const_twa_graph_ptr') -> "spot::twa_graph_ptr":
        return _impl.remove_ap_strip(self, aut)

    def __init__(self):
        _impl.remove_ap_swiginit(self, _impl.new_remove_ap())
    __swig_destroy__ = _impl.delete_remove_ap
remove_ap_swigregister = _impl.remove_ap_swigregister
remove_ap_swigregister(remove_ap)


def to_generalized_buchi(aut: 'spot::const_twa_graph_ptr const &') -> "spot::twa_graph_ptr":
    return _impl.to_generalized_buchi(aut)
to_generalized_buchi = _impl.to_generalized_buchi

def streett_to_generalized_buchi(arg1: 'spot::const_twa_graph_ptr const &') -> "spot::twa_graph_ptr":
    return _impl.streett_to_generalized_buchi(arg1)
streett_to_generalized_buchi = _impl.streett_to_generalized_buchi

def streett_to_generalized_buchi_maybe(arg1: 'spot::const_twa_graph_ptr const &') -> "spot::twa_graph_ptr":
    return _impl.streett_to_generalized_buchi_maybe(arg1)
streett_to_generalized_buchi_maybe = _impl.streett_to_generalized_buchi_maybe

def to_generalized_rabin(aut: 'spot::const_twa_graph_ptr const &', share_inf: 'bool'=False) -> "spot::twa_graph_ptr":
    return _impl.to_generalized_rabin(aut, share_inf)
to_generalized_rabin = _impl.to_generalized_rabin

def to_generalized_streett(aut: 'spot::const_twa_graph_ptr const &', share_fin: 'bool'=False) -> "spot::twa_graph_ptr":
    return _impl.to_generalized_streett(aut, share_fin)
to_generalized_streett = _impl.to_generalized_streett

def dnf_to_streett(aut: 'spot::const_twa_graph_ptr const &', original_states: 'bool'=False) -> "spot::twa_graph_ptr":
    return _impl.dnf_to_streett(aut, original_states)
dnf_to_streett = _impl.dnf_to_streett

def sbacc(aut: 'spot::twa_graph_ptr') -> "spot::twa_graph_ptr":
    return _impl.sbacc(aut)
sbacc = _impl.sbacc
class keep_all(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        _impl.keep_all_swiginit(self, _impl.new_keep_all())
    __swig_destroy__ = _impl.delete_keep_all
keep_all_swigregister = _impl.keep_all_swigregister
keep_all_swigregister(keep_all)

class keep_inner_scc(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, sccof: 'vectorunsigned', desired_scc: 'unsigned int'):
        _impl.keep_inner_scc_swiginit(self, _impl.new_keep_inner_scc(sccof, desired_scc))
    __swig_destroy__ = _impl.delete_keep_inner_scc
keep_inner_scc_swigregister = _impl.keep_inner_scc_swigregister
keep_inner_scc_swigregister(keep_inner_scc)

class scc_info_node(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _impl.scc_info_node_swiginit(self, _impl.new_scc_info_node(*args))

    def is_trivial(self) -> "bool":
        return _impl.scc_info_node_is_trivial(self)

    def is_accepting(self) -> "bool":
        return _impl.scc_info_node_is_accepting(self)

    def is_rejecting(self) -> "bool":
        return _impl.scc_info_node_is_rejecting(self)

    def is_useful(self) -> "bool":
        return _impl.scc_info_node_is_useful(self)

    def acc_marks(self) -> "spot::acc_cond::mark_t":
        return _impl.scc_info_node_acc_marks(self)

    def common_marks(self) -> "spot::acc_cond::mark_t":
        return _impl.scc_info_node_common_marks(self)

    def states(self) -> "std::vector< unsigned int,std::allocator< unsigned int > > const &":
        return _impl.scc_info_node_states(self)

    def one_state(self) -> "unsigned int":
        return _impl.scc_info_node_one_state(self)

    def succ(self) -> "spot::scc_info_node::scc_succs const &":
        return _impl.scc_info_node_succ(self)
    __swig_destroy__ = _impl.delete_scc_info_node
scc_info_node_swigregister = _impl.scc_info_node_swigregister
scc_info_node_swigregister(scc_info_node)

scc_info_options_NONE = _impl.scc_info_options_NONE
scc_info_options_STOP_ON_ACC = _impl.scc_info_options_STOP_ON_ACC
scc_info_options_TRACK_STATES = _impl.scc_info_options_TRACK_STATES
scc_info_options_TRACK_SUCCS = _impl.scc_info_options_TRACK_SUCCS
scc_info_options_TRACK_STATES_IF_FIN_USED = _impl.scc_info_options_TRACK_STATES_IF_FIN_USED
scc_info_options_ALL = _impl.scc_info_options_ALL

def __and__(left: 'spot::scc_info_options', right: 'spot::scc_info_options') -> "spot::scc_info_options":
    return _impl.__and__(left, right)
__and__ = _impl.__and__

def __or__(left: 'spot::scc_info_options', right: 'spot::scc_info_options') -> "spot::scc_info_options":
    return _impl.__or__(left, right)
__or__ = _impl.__or__
class scc_info(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    edge_filter_choice_keep = _impl.scc_info_edge_filter_choice_keep
    edge_filter_choice_ignore = _impl.scc_info_edge_filter_choice_ignore
    edge_filter_choice_cut = _impl.scc_info_edge_filter_choice_cut

    def __init__(self, *args):
        _impl.scc_info_swiginit(self, _impl.new_scc_info(*args))

    def get_aut(self) -> "spot::const_twa_graph_ptr":
        return _impl.scc_info_get_aut(self)

    def scc_count(self) -> "unsigned int":
        return _impl.scc_info_scc_count(self)

    def one_accepting_scc(self) -> "int":
        return _impl.scc_info_one_accepting_scc(self)

    def reachable_state(self, st: 'unsigned int') -> "bool":
        return _impl.scc_info_reachable_state(self, st)

    def scc_of(self, st: 'unsigned int') -> "unsigned int":
        return _impl.scc_info_scc_of(self, st)

    def begin(self) -> "std::vector< spot::scc_info::scc_node,std::allocator< spot::scc_info::scc_node > >::const_iterator":
        return _impl.scc_info_begin(self)

    def end(self) -> "std::vector< spot::scc_info::scc_node,std::allocator< spot::scc_info::scc_node > >::const_iterator":
        return _impl.scc_info_end(self)

    def cbegin(self) -> "std::vector< spot::scc_info::scc_node,std::allocator< spot::scc_info::scc_node > >::const_iterator":
        return _impl.scc_info_cbegin(self)

    def cend(self) -> "std::vector< spot::scc_info::scc_node,std::allocator< spot::scc_info::scc_node > >::const_iterator":
        return _impl.scc_info_cend(self)

    def rbegin(self) -> "std::vector< spot::scc_info::scc_node,std::allocator< spot::scc_info::scc_node > >::const_reverse_iterator":
        return _impl.scc_info_rbegin(self)

    def rend(self) -> "std::vector< spot::scc_info::scc_node,std::allocator< spot::scc_info::scc_node > >::const_reverse_iterator":
        return _impl.scc_info_rend(self)

    def states_of(self, scc: 'unsigned int') -> "std::vector< unsigned int,std::allocator< unsigned int > > const &":
        return _impl.scc_info_states_of(self, scc)

    def edges_of(self, scc: 'unsigned int') -> "spot::internal::scc_edges< spot::twa_graph::graph_t const,spot::internal::keep_all >":
        return _impl.scc_info_edges_of(self, scc)

    def inner_edges_of(self, scc: 'unsigned int') -> "spot::internal::scc_edges< spot::twa_graph::graph_t const,spot::internal::keep_inner_scc >":
        return _impl.scc_info_inner_edges_of(self, scc)

    def one_state_of(self, scc: 'unsigned int') -> "unsigned int":
        return _impl.scc_info_one_state_of(self, scc)

    def initial(self) -> "unsigned int":
        return _impl.scc_info_initial(self)

    def succ(self, scc: 'unsigned int') -> "spot::scc_info::scc_succs const &":
        return _impl.scc_info_succ(self, scc)

    def is_trivial(self, scc: 'unsigned int') -> "bool":
        return _impl.scc_info_is_trivial(self, scc)

    def acc(self, scc: 'unsigned int') -> "spot::acc_cond::mark_t":
        return _impl.scc_info_acc(self, scc)

    def is_accepting_scc(self, scc: 'unsigned int') -> "bool":
        return _impl.scc_info_is_accepting_scc(self, scc)

    def is_rejecting_scc(self, scc: 'unsigned int') -> "bool":
        return _impl.scc_info_is_rejecting_scc(self, scc)

    def determine_unknown_acceptance(self) -> "void":
        return _impl.scc_info_determine_unknown_acceptance(self)

    def is_useful_scc(self, scc: 'unsigned int') -> "bool":
        return _impl.scc_info_is_useful_scc(self, scc)

    def is_useful_state(self, st: 'unsigned int') -> "bool":
        return _impl.scc_info_is_useful_state(self, st)

    def marks(self) -> "std::vector< std::set< spot::acc_cond::mark_t,std::less< spot::acc_cond::mark_t >,std::allocator< spot::acc_cond::mark_t > >,std::allocator< std::set< spot::acc_cond::mark_t,std::less< spot::acc_cond::mark_t >,std::allocator< spot::acc_cond::mark_t > > > >":
        return _impl.scc_info_marks(self)

    def marks_of(self, scc: 'unsigned int') -> "std::set< spot::acc_cond::mark_t,std::less< spot::acc_cond::mark_t >,std::allocator< spot::acc_cond::mark_t > >":
        return _impl.scc_info_marks_of(self, scc)

    def used_acc(self) -> "std::vector< std::set< spot::acc_cond::mark_t,std::less< spot::acc_cond::mark_t >,std::allocator< spot::acc_cond::mark_t > >,std::allocator< std::set< spot::acc_cond::mark_t,std::less< spot::acc_cond::mark_t >,std::allocator< spot::acc_cond::mark_t > > > >":
        return _impl.scc_info_used_acc(self)

    def used_acc_of(self, scc: 'unsigned int') -> "std::set< spot::acc_cond::mark_t,std::less< spot::acc_cond::mark_t >,std::allocator< spot::acc_cond::mark_t > >":
        return _impl.scc_info_used_acc_of(self, scc)

    def acc_sets_of(self, scc: 'unsigned int') -> "spot::acc_cond::mark_t":
        return _impl.scc_info_acc_sets_of(self, scc)

    def common_sets_of(self, scc: 'unsigned int') -> "spot::acc_cond::mark_t":
        return _impl.scc_info_common_sets_of(self, scc)

    def weak_sccs(self) -> "std::vector< bool,std::allocator< bool > >":
        return _impl.scc_info_weak_sccs(self)

    def scc_ap_support(self, scc: 'unsigned int') -> "bdd":
        return _impl.scc_info_scc_ap_support(self, scc)

    def split_on_sets(self, scc: 'unsigned int', sets: 'mark_t', preserve_names: 'bool'=False) -> "std::vector< spot::twa_graph_ptr,std::allocator< spot::twa_graph_ptr > >":
        return _impl.scc_info_split_on_sets(self, scc, sets, preserve_names)

    def states_on_acc_cycle_of(self, scc: 'unsigned int') -> "std::vector< unsigned int,std::allocator< unsigned int > >":
        return _impl.scc_info_states_on_acc_cycle_of(self, scc)

    def __iter__(self) -> "swig::SwigPyIterator *":
        return _impl.scc_info___iter__(self)
    __swig_destroy__ = _impl.delete_scc_info
scc_info_swigregister = _impl.scc_info_swigregister
scc_info_swigregister(scc_info)


def dump_scc_info_dot(out: 'ostream', aut: 'spot::const_twa_graph_ptr', sccinfo: 'scc_info'=None) -> "std::ostream &":
    return _impl.dump_scc_info_dot(out, aut, sccinfo)
dump_scc_info_dot = _impl.dump_scc_info_dot
class scc_info_scc_edges(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, begin: 'spot::internal::scc_edges< spot::digraph< spot::twa_graph_state,spot::twa_graph_edge_data > const,spot::internal::keep_all >::state_iterator', end: 'spot::internal::scc_edges< spot::digraph< spot::twa_graph_state,spot::twa_graph_edge_data > const,spot::internal::keep_all >::state_iterator', tv: 'spot::internal::scc_edges< spot::digraph< spot::twa_graph_state,spot::twa_graph_edge_data > const,spot::internal::keep_all >::tv_t *', sv: 'spot::internal::scc_edges< spot::digraph< spot::twa_graph_state,spot::twa_graph_edge_data > const,spot::internal::keep_all >::sv_t *', dv: 'spot::internal::scc_edges< spot::digraph< spot::twa_graph_state,spot::twa_graph_edge_data > const,spot::internal::keep_all >::dv_t *', filt: 'keep_all'):
        _impl.scc_info_scc_edges_swiginit(self, _impl.new_scc_info_scc_edges(begin, end, tv, sv, dv, filt))

    def begin(self) -> "spot::internal::scc_edges< spot::digraph< spot::twa_graph_state,spot::twa_graph_edge_data > const,spot::internal::keep_all >::iter_t":
        return _impl.scc_info_scc_edges_begin(self)

    def end(self) -> "spot::internal::scc_edges< spot::digraph< spot::twa_graph_state,spot::twa_graph_edge_data > const,spot::internal::keep_all >::iter_t":
        return _impl.scc_info_scc_edges_end(self)

    def __iter__(self) -> "swig::SwigPyIterator *":
        return _impl.scc_info_scc_edges___iter__(self)
    __swig_destroy__ = _impl.delete_scc_info_scc_edges
scc_info_scc_edges_swigregister = _impl.scc_info_scc_edges_swigregister
scc_info_scc_edges_swigregister(scc_info_scc_edges)

class scc_info_inner_scc_edges(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, begin: 'spot::internal::scc_edges< spot::digraph< spot::twa_graph_state,spot::twa_graph_edge_data > const,spot::internal::keep_inner_scc >::state_iterator', end: 'spot::internal::scc_edges< spot::digraph< spot::twa_graph_state,spot::twa_graph_edge_data > const,spot::internal::keep_inner_scc >::state_iterator', tv: 'spot::internal::scc_edges< spot::digraph< spot::twa_graph_state,spot::twa_graph_edge_data > const,spot::internal::keep_inner_scc >::tv_t *', sv: 'spot::internal::scc_edges< spot::digraph< spot::twa_graph_state,spot::twa_graph_edge_data > const,spot::internal::keep_inner_scc >::sv_t *', dv: 'spot::internal::scc_edges< spot::digraph< spot::twa_graph_state,spot::twa_graph_edge_data > const,spot::internal::keep_inner_scc >::dv_t *', filt: 'keep_inner_scc'):
        _impl.scc_info_inner_scc_edges_swiginit(self, _impl.new_scc_info_inner_scc_edges(begin, end, tv, sv, dv, filt))

    def begin(self) -> "spot::internal::scc_edges< spot::digraph< spot::twa_graph_state,spot::twa_graph_edge_data > const,spot::internal::keep_inner_scc >::iter_t":
        return _impl.scc_info_inner_scc_edges_begin(self)

    def end(self) -> "spot::internal::scc_edges< spot::digraph< spot::twa_graph_state,spot::twa_graph_edge_data > const,spot::internal::keep_inner_scc >::iter_t":
        return _impl.scc_info_inner_scc_edges_end(self)

    def __iter__(self) -> "swig::SwigPyIterator *":
        return _impl.scc_info_inner_scc_edges___iter__(self)
    __swig_destroy__ = _impl.delete_scc_info_inner_scc_edges
scc_info_inner_scc_edges_swigregister = _impl.scc_info_inner_scc_edges_swigregister
scc_info_inner_scc_edges_swigregister(scc_info_inner_scc_edges)

class vector_twa_graph(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _impl.vector_twa_graph_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _impl.vector_twa_graph___nonzero__(self)

    def __bool__(self) -> "bool":
        return _impl.vector_twa_graph___bool__(self)

    def __len__(self) -> "std::vector< std::shared_ptr< spot::twa_graph > >::size_type":
        return _impl.vector_twa_graph___len__(self)

    def __getslice__(self, i: 'std::vector< std::shared_ptr< spot::twa_graph > >::difference_type', j: 'std::vector< std::shared_ptr< spot::twa_graph > >::difference_type') -> "std::vector< std::shared_ptr< spot::twa_graph >,std::allocator< std::shared_ptr< spot::twa_graph > > > *":
        return _impl.vector_twa_graph___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _impl.vector_twa_graph___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< std::shared_ptr< spot::twa_graph > >::difference_type', j: 'std::vector< std::shared_ptr< spot::twa_graph > >::difference_type') -> "void":
        return _impl.vector_twa_graph___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _impl.vector_twa_graph___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::shared_ptr< spot::twa_graph > >::value_type const &":
        return _impl.vector_twa_graph___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _impl.vector_twa_graph___setitem__(self, *args)

    def pop(self) -> "std::vector< std::shared_ptr< spot::twa_graph > >::value_type":
        return _impl.vector_twa_graph_pop(self)

    def append(self, x: 'std::vector< std::shared_ptr< spot::twa_graph > >::value_type const &') -> "void":
        return _impl.vector_twa_graph_append(self, x)

    def empty(self) -> "bool":
        return _impl.vector_twa_graph_empty(self)

    def size(self) -> "std::vector< std::shared_ptr< spot::twa_graph > >::size_type":
        return _impl.vector_twa_graph_size(self)

    def swap(self, v: 'vector_twa_graph') -> "void":
        return _impl.vector_twa_graph_swap(self, v)

    def begin(self) -> "std::vector< std::shared_ptr< spot::twa_graph > >::iterator":
        return _impl.vector_twa_graph_begin(self)

    def end(self) -> "std::vector< std::shared_ptr< spot::twa_graph > >::iterator":
        return _impl.vector_twa_graph_end(self)

    def rbegin(self) -> "std::vector< std::shared_ptr< spot::twa_graph > >::reverse_iterator":
        return _impl.vector_twa_graph_rbegin(self)

    def rend(self) -> "std::vector< std::shared_ptr< spot::twa_graph > >::reverse_iterator":
        return _impl.vector_twa_graph_rend(self)

    def clear(self) -> "void":
        return _impl.vector_twa_graph_clear(self)

    def get_allocator(self) -> "std::vector< std::shared_ptr< spot::twa_graph > >::allocator_type":
        return _impl.vector_twa_graph_get_allocator(self)

    def pop_back(self) -> "void":
        return _impl.vector_twa_graph_pop_back(self)

    def erase(self, *args) -> "std::vector< std::shared_ptr< spot::twa_graph > >::iterator":
        return _impl.vector_twa_graph_erase(self, *args)

    def __init__(self, *args):
        _impl.vector_twa_graph_swiginit(self, _impl.new_vector_twa_graph(*args))

    def push_back(self, x: 'std::vector< std::shared_ptr< spot::twa_graph > >::value_type const &') -> "void":
        return _impl.vector_twa_graph_push_back(self, x)

    def front(self) -> "std::vector< std::shared_ptr< spot::twa_graph > >::value_type const &":
        return _impl.vector_twa_graph_front(self)

    def back(self) -> "std::vector< std::shared_ptr< spot::twa_graph > >::value_type const &":
        return _impl.vector_twa_graph_back(self)

    def assign(self, n: 'std::vector< std::shared_ptr< spot::twa_graph > >::size_type', x: 'std::vector< std::shared_ptr< spot::twa_graph > >::value_type const &') -> "void":
        return _impl.vector_twa_graph_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _impl.vector_twa_graph_resize(self, *args)

    def insert(self, *args) -> "void":
        return _impl.vector_twa_graph_insert(self, *args)

    def reserve(self, n: 'std::vector< std::shared_ptr< spot::twa_graph > >::size_type') -> "void":
        return _impl.vector_twa_graph_reserve(self, n)

    def capacity(self) -> "std::vector< std::shared_ptr< spot::twa_graph > >::size_type":
        return _impl.vector_twa_graph_capacity(self)
    __swig_destroy__ = _impl.delete_vector_twa_graph
vector_twa_graph_swigregister = _impl.vector_twa_graph_swigregister
vector_twa_graph_swigregister(vector_twa_graph)


def is_terminal_automaton(aut: 'spot::const_twa_graph_ptr const &', sm: 'scc_info'=None, ignore_trivial_scc: 'bool'=False) -> "bool":
    return _impl.is_terminal_automaton(aut, sm, ignore_trivial_scc)
is_terminal_automaton = _impl.is_terminal_automaton

def is_weak_automaton(aut: 'spot::const_twa_graph_ptr const &', sm: 'scc_info'=None) -> "bool":
    return _impl.is_weak_automaton(aut, sm)
is_weak_automaton = _impl.is_weak_automaton

def is_very_weak_automaton(aut: 'spot::const_twa_graph_ptr const &', sm: 'scc_info'=None) -> "bool":
    return _impl.is_very_weak_automaton(aut, sm)
is_very_weak_automaton = _impl.is_very_weak_automaton

def is_inherently_weak_automaton(aut: 'spot::const_twa_graph_ptr const &', sm: 'scc_info'=None) -> "bool":
    return _impl.is_inherently_weak_automaton(aut, sm)
is_inherently_weak_automaton = _impl.is_inherently_weak_automaton

def is_safety_automaton(aut: 'spot::const_twa_graph_ptr const &', sm: 'scc_info'=None) -> "bool":
    return _impl.is_safety_automaton(aut, sm)
is_safety_automaton = _impl.is_safety_automaton

def check_strength(aut: 'spot::twa_graph_ptr const &', sm: 'scc_info'=None) -> "void":
    return _impl.check_strength(aut, sm)
check_strength = _impl.check_strength

def decompose_strength(aut: 'spot::const_twa_graph_ptr const &', keep: 'char const *') -> "spot::twa_graph_ptr":
    return _impl.decompose_strength(aut, keep)
decompose_strength = _impl.decompose_strength

def decompose_scc(*args) -> "spot::twa_graph_ptr":
    return _impl.decompose_scc(*args)
decompose_scc = _impl.decompose_scc

def scc_filter(aut: 'spot::const_twa_graph_ptr const &', remove_all_useless: 'bool'=False, given_si: 'scc_info'=None) -> "spot::twa_graph_ptr":
    return _impl.scc_filter(aut, remove_all_useless, given_si)
scc_filter = _impl.scc_filter

def scc_filter_states(aut: 'spot::const_twa_graph_ptr const &', remove_all_useless: 'bool'=False, given_si: 'scc_info'=None) -> "spot::twa_graph_ptr":
    return _impl.scc_filter_states(aut, remove_all_useless, given_si)
scc_filter_states = _impl.scc_filter_states

def scc_filter_susp(aut: 'spot::const_twa_graph_ptr const &', remove_all_useless: 'bool', suspvars: 'bdd', ignoredvars: 'bdd', early_susp: 'bool', given_si: 'scc_info'=None) -> "spot::twa_graph_ptr":
    return _impl.scc_filter_susp(aut, remove_all_useless, suspvars, ignoredvars, early_susp, given_si)
scc_filter_susp = _impl.scc_filter_susp
class twa_statistics(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    edges = _swig_property(_impl.twa_statistics_edges_get, _impl.twa_statistics_edges_set)
    states = _swig_property(_impl.twa_statistics_states_get, _impl.twa_statistics_states_set)

    def __init__(self):
        _impl.twa_statistics_swiginit(self, _impl.new_twa_statistics())

    def dump(self, out: 'ostream') -> "std::ostream &":
        return _impl.twa_statistics_dump(self, out)
    __swig_destroy__ = _impl.delete_twa_statistics
twa_statistics_swigregister = _impl.twa_statistics_swigregister
twa_statistics_swigregister(twa_statistics)

class twa_sub_statistics(twa_statistics):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    transitions = _swig_property(_impl.twa_sub_statistics_transitions_get, _impl.twa_sub_statistics_transitions_set)

    def __init__(self):
        _impl.twa_sub_statistics_swiginit(self, _impl.new_twa_sub_statistics())

    def dump(self, out: 'ostream') -> "std::ostream &":
        return _impl.twa_sub_statistics_dump(self, out)
    __swig_destroy__ = _impl.delete_twa_sub_statistics
twa_sub_statistics_swigregister = _impl.twa_sub_statistics_swigregister
twa_sub_statistics_swigregister(twa_sub_statistics)


def sub_stats_reachable(g: 'spot::const_twa_ptr const &') -> "spot::twa_sub_statistics":
    return _impl.sub_stats_reachable(g)
sub_stats_reachable = _impl.sub_stats_reachable
class printable_formula(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _print(self, os: 'ostream', arg3: 'char const *') -> "void":
        return _impl.printable_formula__print(self, os, arg3)

    def __init__(self):
        _impl.printable_formula_swiginit(self, _impl.new_printable_formula())
    __swig_destroy__ = _impl.delete_printable_formula
printable_formula_swigregister = _impl.printable_formula_swigregister
printable_formula_swigregister(printable_formula)

class printable_acc_cond(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _print(self, os: 'ostream', pos: 'char const *') -> "void":
        return _impl.printable_acc_cond__print(self, os, pos)

    def __init__(self):
        _impl.printable_acc_cond_swiginit(self, _impl.new_printable_acc_cond())
    __swig_destroy__ = _impl.delete_printable_acc_cond
printable_acc_cond_swigregister = _impl.printable_acc_cond_swigregister
printable_acc_cond_swigregister(printable_acc_cond)

class printable_scc_info(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def automaton(self, aut: 'spot::const_twa_graph_ptr const &') -> "void":
        return _impl.printable_scc_info_automaton(self, aut)

    def reset(self) -> "void":
        return _impl.printable_scc_info_reset(self)

    def _print(self, os: 'ostream', pos: 'char const *') -> "void":
        return _impl.printable_scc_info__print(self, os, pos)

    def __init__(self):
        _impl.printable_scc_info_swiginit(self, _impl.new_printable_scc_info())
    __swig_destroy__ = _impl.delete_printable_scc_info
printable_scc_info_swigregister = _impl.printable_scc_info_swigregister
printable_scc_info_swigregister(printable_scc_info)

class stat_printer(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, os: 'ostream', format: 'char const *'):
        _impl.stat_printer_swiginit(self, _impl.new_stat_printer(os, format))

    def _print(self, aut: 'spot::const_twa_graph_ptr const &', f: 'formula'=0) -> "std::ostream &":
        return _impl.stat_printer__print(self, aut, f)
    __swig_destroy__ = _impl.delete_stat_printer
stat_printer_swigregister = _impl.stat_printer_swigregister
stat_printer_swigregister(stat_printer)


def count_nondet_states(aut: 'spot::const_twa_graph_ptr const &') -> "unsigned int":
    return _impl.count_nondet_states(aut)
count_nondet_states = _impl.count_nondet_states

def is_universal(aut: 'spot::const_twa_graph_ptr const &') -> "bool":
    return _impl.is_universal(aut)
is_universal = _impl.is_universal

def is_deterministic(aut: 'spot::const_twa_graph_ptr const &') -> "bool":
    return _impl.is_deterministic(aut)
is_deterministic = _impl.is_deterministic

def highlight_nondet_states(aut: 'spot::twa_graph_ptr &', color: 'unsigned int') -> "void":
    return _impl.highlight_nondet_states(aut, color)
highlight_nondet_states = _impl.highlight_nondet_states

def highlight_nondet_edges(aut: 'spot::twa_graph_ptr &', color: 'unsigned int') -> "void":
    return _impl.highlight_nondet_edges(aut, color)
highlight_nondet_edges = _impl.highlight_nondet_edges

def is_complete(aut: 'spot::const_twa_graph_ptr const &') -> "bool":
    return _impl.is_complete(aut)
is_complete = _impl.is_complete

def is_semi_deterministic(aut: 'spot::const_twa_graph_ptr const &') -> "bool":
    return _impl.is_semi_deterministic(aut)
is_semi_deterministic = _impl.is_semi_deterministic

def check_determinism(aut: 'spot::twa_graph_ptr') -> "void":
    return _impl.check_determinism(aut)
check_determinism = _impl.check_determinism

def is_colored(aut: 'spot::const_twa_graph_ptr const &') -> "bool":
    return _impl.is_colored(aut)
is_colored = _impl.is_colored

def is_unambiguous(aut: 'spot::const_twa_graph_ptr const &') -> "bool":
    return _impl.is_unambiguous(aut)
is_unambiguous = _impl.is_unambiguous

def check_unambiguous(aut: 'spot::twa_graph_ptr const &') -> "bool":
    return _impl.check_unambiguous(aut)
check_unambiguous = _impl.check_unambiguous

def scc_has_rejecting_cycle(map: 'scc_info', scc: 'unsigned int') -> "bool":
    return _impl.scc_has_rejecting_cycle(map, scc)
scc_has_rejecting_cycle = _impl.scc_has_rejecting_cycle

def is_inherently_weak_scc(map: 'scc_info', scc: 'unsigned int') -> "bool":
    return _impl.is_inherently_weak_scc(map, scc)
is_inherently_weak_scc = _impl.is_inherently_weak_scc

def is_weak_scc(map: 'scc_info', scc: 'unsigned int') -> "bool":
    return _impl.is_weak_scc(map, scc)
is_weak_scc = _impl.is_weak_scc

def is_complete_scc(map: 'scc_info', scc: 'unsigned int') -> "bool":
    return _impl.is_complete_scc(map, scc)
is_complete_scc = _impl.is_complete_scc

def is_terminal_scc(map: 'scc_info', scc: 'unsigned int') -> "bool":
    return _impl.is_terminal_scc(map, scc)
is_terminal_scc = _impl.is_terminal_scc

def simulation(*args) -> "spot::twa_graph_ptr":
    return _impl.simulation(*args)
simulation = _impl.simulation

def simulation_sba(automaton: 'spot::const_twa_graph_ptr const &') -> "spot::twa_graph_ptr":
    return _impl.simulation_sba(automaton)
simulation_sba = _impl.simulation_sba

def cosimulation(automaton: 'spot::const_twa_graph_ptr const &') -> "spot::twa_graph_ptr":
    return _impl.cosimulation(automaton)
cosimulation = _impl.cosimulation

def cosimulation_sba(automaton: 'spot::const_twa_graph_ptr const &') -> "spot::twa_graph_ptr":
    return _impl.cosimulation_sba(automaton)
cosimulation_sba = _impl.cosimulation_sba

def iterated_simulations(automaton: 'spot::const_twa_graph_ptr const &') -> "spot::twa_graph_ptr":
    return _impl.iterated_simulations(automaton)
iterated_simulations = _impl.iterated_simulations

def iterated_simulations_sba(automaton: 'spot::const_twa_graph_ptr const &') -> "spot::twa_graph_ptr":
    return _impl.iterated_simulations_sba(automaton)
iterated_simulations_sba = _impl.iterated_simulations_sba
parity_kind_max = _impl.parity_kind_max
parity_kind_min = _impl.parity_kind_min
parity_kind_same = _impl.parity_kind_same
parity_kind_any = _impl.parity_kind_any
parity_style_odd = _impl.parity_style_odd
parity_style_even = _impl.parity_style_even
parity_style_same = _impl.parity_style_same
parity_style_any = _impl.parity_style_any

def change_parity(aut: 'spot::const_twa_graph_ptr const &', kind: 'spot::parity_kind', style: 'spot::parity_style') -> "spot::twa_graph_ptr":
    return _impl.change_parity(aut, kind, style)
change_parity = _impl.change_parity

def change_parity_here(aut: 'spot::twa_graph_ptr', kind: 'spot::parity_kind', style: 'spot::parity_style') -> "spot::twa_graph_ptr":
    return _impl.change_parity_here(aut, kind, style)
change_parity_here = _impl.change_parity_here

def cleanup_parity(aut: 'spot::const_twa_graph_ptr const &', keep_style: 'bool'=False) -> "spot::twa_graph_ptr":
    return _impl.cleanup_parity(aut, keep_style)
cleanup_parity = _impl.cleanup_parity

def cleanup_parity_here(aut: 'spot::twa_graph_ptr', keep_style: 'bool'=False) -> "spot::twa_graph_ptr":
    return _impl.cleanup_parity_here(aut, keep_style)
cleanup_parity_here = _impl.cleanup_parity_here

def colorize_parity(aut: 'spot::const_twa_graph_ptr const &', keep_style: 'bool'=False) -> "spot::twa_graph_ptr":
    return _impl.colorize_parity(aut, keep_style)
colorize_parity = _impl.colorize_parity

def colorize_parity_here(aut: 'spot::twa_graph_ptr', keep_style: 'bool'=False) -> "spot::twa_graph_ptr":
    return _impl.colorize_parity_here(aut, keep_style)
colorize_parity_here = _impl.colorize_parity_here

def parity_product(left: 'spot::const_twa_graph_ptr const &', right: 'spot::const_twa_graph_ptr const &') -> "spot::twa_graph_ptr":
    return _impl.parity_product(left, right)
parity_product = _impl.parity_product

def parity_product_or(left: 'spot::const_twa_graph_ptr const &', right: 'spot::const_twa_graph_ptr const &') -> "spot::twa_graph_ptr":
    return _impl.parity_product_or(left, right)
parity_product_or = _impl.parity_product_or
class postprocessor(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, opt: 'option_map'=None):
        _impl.postprocessor_swiginit(self, _impl.new_postprocessor(opt))
    TGBA = _impl.postprocessor_TGBA
    BA = _impl.postprocessor_BA
    Monitor = _impl.postprocessor_Monitor
    Generic = _impl.postprocessor_Generic
    Parity = _impl.postprocessor_Parity
    ParityMin = _impl.postprocessor_ParityMin
    ParityMax = _impl.postprocessor_ParityMax
    ParityOdd = _impl.postprocessor_ParityOdd
    ParityEven = _impl.postprocessor_ParityEven
    ParityMinOdd = _impl.postprocessor_ParityMinOdd
    ParityMaxOdd = _impl.postprocessor_ParityMaxOdd
    ParityMinEven = _impl.postprocessor_ParityMinEven
    ParityMaxEven = _impl.postprocessor_ParityMaxEven
    CoBuchi = _impl.postprocessor_CoBuchi

    def set_type(self, type: 'spot::postprocessor::output_type') -> "void":
        return _impl.postprocessor_set_type(self, type)
    Any = _impl.postprocessor_Any
    Small = _impl.postprocessor_Small
    Deterministic = _impl.postprocessor_Deterministic
    Complete = _impl.postprocessor_Complete
    SBAcc = _impl.postprocessor_SBAcc
    Unambiguous = _impl.postprocessor_Unambiguous
    Colored = _impl.postprocessor_Colored

    def set_pref(self, pref: 'spot::postprocessor::output_pref') -> "void":
        return _impl.postprocessor_set_pref(self, pref)
    Low = _impl.postprocessor_Low
    Medium = _impl.postprocessor_Medium
    High = _impl.postprocessor_High

    def set_level(self, level: 'spot::postprocessor::optimization_level') -> "void":
        return _impl.postprocessor_set_level(self, level)

    def run(self, input: 'spot::twa_graph_ptr', f: 'formula'=0) -> "spot::twa_graph_ptr":
        return _impl.postprocessor_run(self, input, f)
    __swig_destroy__ = _impl.delete_postprocessor
postprocessor_swigregister = _impl.postprocessor_swigregister
postprocessor_swigregister(postprocessor)


def product(*args) -> "spot::twa_graph_ptr":
    return _impl.product(*args)
product = _impl.product

def product_or(*args) -> "spot::twa_graph_ptr":
    return _impl.product_or(*args)
product_or = _impl.product_or

def split_edges(aut: 'spot::const_twa_graph_ptr const &') -> "spot::twa_graph_ptr":
    return _impl.split_edges(aut)
split_edges = _impl.split_edges

def sum(*args) -> "spot::twa_graph_ptr":
    return _impl.sum(*args)
sum = _impl.sum

def sum_and(*args) -> "spot::twa_graph_ptr":
    return _impl.sum_and(*args)
sum_and = _impl.sum_and

def sl(aut: 'spot::const_twa_graph_ptr') -> "spot::twa_graph_ptr":
    return _impl.sl(aut)
sl = _impl.sl

def sl2_inplace(aut: 'spot::twa_graph_ptr') -> "spot::twa_graph_ptr":
    return _impl.sl2_inplace(aut)
sl2_inplace = _impl.sl2_inplace

def sl2(aut: 'spot::const_twa_graph_ptr') -> "spot::twa_graph_ptr":
    return _impl.sl2(aut)
sl2 = _impl.sl2

def closure_inplace(aut: 'spot::twa_graph_ptr') -> "spot::twa_graph_ptr":
    return _impl.closure_inplace(aut)
closure_inplace = _impl.closure_inplace

def closure(aut: 'spot::const_twa_graph_ptr') -> "spot::twa_graph_ptr":
    return _impl.closure(aut)
closure = _impl.closure

def is_stutter_invariant(*args) -> "bool":
    return _impl.is_stutter_invariant(*args)
is_stutter_invariant = _impl.is_stutter_invariant

def check_stutter_invariance(aut_f: 'spot::twa_graph_ptr', f: 'formula'=0, do_not_determinize: 'bool'=False) -> "spot::trival":
    return _impl.check_stutter_invariance(aut_f, f, do_not_determinize)
check_stutter_invariance = _impl.check_stutter_invariance

def stutter_invariant_states(*args) -> "std::vector< bool,std::allocator< bool > >":
    return _impl.stutter_invariant_states(*args)
stutter_invariant_states = _impl.stutter_invariant_states

def highlight_stutter_invariant_states(*args) -> "void":
    return _impl.highlight_stutter_invariant_states(*args)
highlight_stutter_invariant_states = _impl.highlight_stutter_invariant_states

def stutter_invariant_letters(*args) -> "std::vector< bdd,std::allocator< bdd > >":
    return _impl.stutter_invariant_letters(*args)
stutter_invariant_letters = _impl.stutter_invariant_letters

def is_stutter_invariant_forward_closed(aut: 'spot::twa_graph_ptr', sistates: 'vectorbool') -> "int":
    return _impl.is_stutter_invariant_forward_closed(aut, sistates)
is_stutter_invariant_forward_closed = _impl.is_stutter_invariant_forward_closed

def make_stutter_invariant_forward_closed_inplace(aut: 'spot::twa_graph_ptr', sistates: 'vectorbool') -> "std::vector< bool,std::allocator< bool > >":
    return _impl.make_stutter_invariant_forward_closed_inplace(aut, sistates)
make_stutter_invariant_forward_closed_inplace = _impl.make_stutter_invariant_forward_closed_inplace
class translator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _impl.translator_swiginit(self, _impl.new_translator(*args))
    __swig_destroy__ = _impl.delete_translator

    def set_type(self, type: 'spot::translator::output_type') -> "void":
        return _impl.translator_set_type(self, type)

    def set_pref(self, pref: 'spot::translator::output_pref') -> "void":
        return _impl.translator_set_pref(self, pref)

    def set_level(self, level: 'spot::translator::optimization_level') -> "void":
        return _impl.translator_set_level(self, level)

    def run(self, *args) -> "spot::twa_graph_ptr":
        return _impl.translator_run(self, *args)

    def clear_caches(self) -> "void":
        return _impl.translator_clear_caches(self)
translator_swigregister = _impl.translator_swigregister
translator_swigregister(translator)


def to_weak_alternating(aut: 'spot::const_twa_graph_ptr &', less: 'bool'=False) -> "spot::twa_graph_ptr":
    return _impl.to_weak_alternating(aut, less)
to_weak_alternating = _impl.to_weak_alternating

def print_hoa(os: 'ostream', g: 'spot::const_twa_ptr const &', opt: 'char const *'=None) -> "std::ostream &":
    return _impl.print_hoa(os, g, opt)
print_hoa = _impl.print_hoa

def dtwa_sat_synthetize(a: 'spot::const_twa_graph_ptr const &', target_acc_number: 'unsigned int', target_acc: 'acc_code', target_state_number: 'int', state_based: 'bool'=False, colored: 'bool'=False) -> "spot::twa_graph_ptr":
    return _impl.dtwa_sat_synthetize(a, target_acc_number, target_acc, target_state_number, state_based, colored)
dtwa_sat_synthetize = _impl.dtwa_sat_synthetize

def dtwa_sat_minimize(a: 'spot::const_twa_graph_ptr const &', target_acc_number: 'unsigned int', target_acc: 'acc_code', state_based: 'bool'=False, max_states: 'int'=-1, colored: 'bool'=False) -> "spot::twa_graph_ptr":
    return _impl.dtwa_sat_minimize(a, target_acc_number, target_acc, state_based, max_states, colored)
dtwa_sat_minimize = _impl.dtwa_sat_minimize

def dtwa_sat_minimize_dichotomy(a: 'spot::const_twa_graph_ptr const &', target_acc_number: 'unsigned int', target_acc: 'acc_code', state_based: 'bool'=False, langmap: 'bool'=False, max_states: 'int'=-1, colored: 'bool'=False) -> "spot::twa_graph_ptr":
    return _impl.dtwa_sat_minimize_dichotomy(a, target_acc_number, target_acc, state_based, langmap, max_states, colored)
dtwa_sat_minimize_dichotomy = _impl.dtwa_sat_minimize_dichotomy

def dtwa_sat_minimize_incr(a: 'spot::const_twa_graph_ptr const &', target_acc_number: 'unsigned int', target_acc: 'acc_code', state_based: 'bool'=False, max_states: 'int'=-1, colored: 'bool'=False, param: 'int'=2) -> "spot::twa_graph_ptr":
    return _impl.dtwa_sat_minimize_incr(a, target_acc_number, target_acc, state_based, max_states, colored, param)
dtwa_sat_minimize_incr = _impl.dtwa_sat_minimize_incr

def dtwa_sat_minimize_assume(a: 'spot::const_twa_graph_ptr const &', target_acc_number: 'unsigned int', target_acc: 'acc_code', state_based: 'bool'=False, max_states: 'int'=-1, colored: 'bool'=False, param: 'int'=6) -> "spot::twa_graph_ptr":
    return _impl.dtwa_sat_minimize_assume(a, target_acc_number, target_acc, state_based, max_states, colored, param)
dtwa_sat_minimize_assume = _impl.dtwa_sat_minimize_assume

def sat_minimize(aut: 'spot::twa_graph_ptr', opt: 'char const *', state_based: 'bool'=False) -> "spot::twa_graph_ptr":
    return _impl.sat_minimize(aut, opt, state_based)
sat_minimize = _impl.sat_minimize

def relabel_here(aut: 'spot::twa_graph_ptr &', relmap: 'relabeling_map') -> "void":
    return _impl.relabel_here(aut, relmap)
relabel_here = _impl.relabel_here
class twa_word(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args):
        _impl.twa_word_swiginit(self, _impl.new_twa_word(*args))
    __swig_destroy__ = _impl.delete_twa_word

    def simplify(self) -> "void":
        return _impl.twa_word_simplify(self)
    prefix = _swig_property(_impl.twa_word_prefix_get, _impl.twa_word_prefix_set)
    cycle = _swig_property(_impl.twa_word_cycle_get, _impl.twa_word_cycle_set)

    def get_dict(self) -> "spot::bdd_dict_ptr":
        return _impl.twa_word_get_dict(self)

    def as_automaton(self) -> "spot::twa_graph_ptr":
        return _impl.twa_word_as_automaton(self)

    def __repr__(self) -> "std::string":
        return _impl.twa_word___repr__(self)

    def __str__(self) -> "std::string":
        return _impl.twa_word___str__(self)
twa_word_swigregister = _impl.twa_word_swigregister
twa_word_swigregister(twa_word)


def make_twa_word(*args) -> "spot::twa_word_ptr":
    return _impl.make_twa_word(*args)
make_twa_word = _impl.make_twa_word

def parse_word(word: 'std::string const &', dict: 'spot::bdd_dict_ptr const &') -> "spot::twa_word_ptr":
    return _impl.parse_word(word, dict)
parse_word = _impl.parse_word
class list_bdd(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _impl.list_bdd_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _impl.list_bdd___nonzero__(self)

    def __bool__(self) -> "bool":
        return _impl.list_bdd___bool__(self)

    def __len__(self) -> "std::list< bdd >::size_type":
        return _impl.list_bdd___len__(self)

    def __getslice__(self, i: 'std::list< bdd >::difference_type', j: 'std::list< bdd >::difference_type') -> "std::list< bdd,std::allocator< bdd > > *":
        return _impl.list_bdd___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _impl.list_bdd___setslice__(self, *args)

    def __delslice__(self, i: 'std::list< bdd >::difference_type', j: 'std::list< bdd >::difference_type') -> "void":
        return _impl.list_bdd___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _impl.list_bdd___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::list< bdd >::value_type const &":
        return _impl.list_bdd___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _impl.list_bdd___setitem__(self, *args)

    def pop(self) -> "std::list< bdd >::value_type":
        return _impl.list_bdd_pop(self)

    def append(self, x: 'bdd') -> "void":
        return _impl.list_bdd_append(self, x)

    def empty(self) -> "bool":
        return _impl.list_bdd_empty(self)

    def size(self) -> "std::list< bdd >::size_type":
        return _impl.list_bdd_size(self)

    def swap(self, v: 'list_bdd') -> "void":
        return _impl.list_bdd_swap(self, v)

    def begin(self) -> "std::list< bdd >::iterator":
        return _impl.list_bdd_begin(self)

    def end(self) -> "std::list< bdd >::iterator":
        return _impl.list_bdd_end(self)

    def rbegin(self) -> "std::list< bdd >::reverse_iterator":
        return _impl.list_bdd_rbegin(self)

    def rend(self) -> "std::list< bdd >::reverse_iterator":
        return _impl.list_bdd_rend(self)

    def clear(self) -> "void":
        return _impl.list_bdd_clear(self)

    def get_allocator(self) -> "std::list< bdd >::allocator_type":
        return _impl.list_bdd_get_allocator(self)

    def pop_back(self) -> "void":
        return _impl.list_bdd_pop_back(self)

    def erase(self, *args) -> "std::list< bdd >::iterator":
        return _impl.list_bdd_erase(self, *args)

    def __init__(self, *args):
        _impl.list_bdd_swiginit(self, _impl.new_list_bdd(*args))

    def push_back(self, x: 'bdd') -> "void":
        return _impl.list_bdd_push_back(self, x)

    def front(self) -> "std::list< bdd >::value_type const &":
        return _impl.list_bdd_front(self)

    def back(self) -> "std::list< bdd >::value_type const &":
        return _impl.list_bdd_back(self)

    def assign(self, n: 'std::list< bdd >::size_type', x: 'bdd') -> "void":
        return _impl.list_bdd_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _impl.list_bdd_resize(self, *args)

    def insert(self, *args) -> "void":
        return _impl.list_bdd_insert(self, *args)

    def pop_front(self) -> "void":
        return _impl.list_bdd_pop_front(self)

    def push_front(self, x: 'bdd') -> "void":
        return _impl.list_bdd_push_front(self, x)

    def reverse(self) -> "void":
        return _impl.list_bdd_reverse(self)
    __swig_destroy__ = _impl.delete_list_bdd
list_bdd_swigregister = _impl.list_bdd_swigregister
list_bdd_swigregister(list_bdd)

class isomorphism_checker(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, ref: 'spot::const_twa_graph_ptr const'):
        _impl.isomorphism_checker_swiginit(self, _impl.new_isomorphism_checker(ref))

    def is_isomorphic(self, aut: 'spot::const_twa_graph_ptr const') -> "bool":
        return _impl.isomorphism_checker_is_isomorphic(self, aut)
    are_isomorphic = staticmethod(_impl.isomorphism_checker_are_isomorphic)
    __swig_destroy__ = _impl.delete_isomorphism_checker
isomorphism_checker_swigregister = _impl.isomorphism_checker_swigregister
isomorphism_checker_swigregister(isomorphism_checker)

def isomorphism_checker_are_isomorphic(ref: 'spot::const_twa_graph_ptr const', aut: 'spot::const_twa_graph_ptr const') -> "bool":
    return _impl.isomorphism_checker_are_isomorphic(ref, aut)
isomorphism_checker_are_isomorphic = _impl.isomorphism_checker_are_isomorphic


def iar(aut: 'spot::const_twa_graph_ptr const &') -> "spot::twa_graph_ptr":
    return _impl.iar(aut)
iar = _impl.iar

def iar_maybe(aut: 'spot::const_twa_graph_ptr const &') -> "spot::twa_graph_ptr":
    return _impl.iar_maybe(aut)
iar_maybe = _impl.iar_maybe

def dtwa_complement(aut: 'spot::const_twa_graph_ptr const &') -> "spot::twa_graph_ptr":
    return _impl.dtwa_complement(aut)
dtwa_complement = _impl.dtwa_complement
class parse_aut_error_list(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __nonzero__(self) -> "bool":
        return _impl.parse_aut_error_list___nonzero__(self)

    def __bool__(self) -> "bool":
        return _impl.parse_aut_error_list___bool__(self)

    def __init__(self):
        _impl.parse_aut_error_list_swiginit(self, _impl.new_parse_aut_error_list())
    __swig_destroy__ = _impl.delete_parse_aut_error_list
parse_aut_error_list_swigregister = _impl.parse_aut_error_list_swigregister
parse_aut_error_list_swigregister(parse_aut_error_list)

parsed_aut_type_HOA = _impl.parsed_aut_type_HOA
parsed_aut_type_NeverClaim = _impl.parsed_aut_type_NeverClaim
parsed_aut_type_LBTT = _impl.parsed_aut_type_LBTT
parsed_aut_type_DRA = _impl.parsed_aut_type_DRA
parsed_aut_type_DSA = _impl.parsed_aut_type_DSA
parsed_aut_type_Unknown = _impl.parsed_aut_type_Unknown
class parsed_aut(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    aut = _swig_property(_impl.parsed_aut_aut_get, _impl.parsed_aut_aut_set)
    ks = _swig_property(_impl.parsed_aut_ks_get, _impl.parsed_aut_ks_set)
    aborted = _swig_property(_impl.parsed_aut_aborted_get, _impl.parsed_aut_aborted_set)
    loc = _swig_property(_impl.parsed_aut_loc_get, _impl.parsed_aut_loc_set)
    type = _swig_property(_impl.parsed_aut_type_get, _impl.parsed_aut_type_set)
    filename = _swig_property(_impl.parsed_aut_filename_get)
    errors = _swig_property(_impl.parsed_aut_errors_get, _impl.parsed_aut_errors_set)

    def __init__(self, str: 'std::string const &'):
        _impl.parsed_aut_swiginit(self, _impl.new_parsed_aut(str))

    def format_errors(self, os: 'ostream') -> "bool":
        return _impl.parsed_aut_format_errors(self, os)
    __swig_destroy__ = _impl.delete_parsed_aut
parsed_aut_swigregister = _impl.parsed_aut_swigregister
parsed_aut_swigregister(parsed_aut)

class automaton_parser_options(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    ignore_abort = _swig_property(_impl.automaton_parser_options_ignore_abort_get, _impl.automaton_parser_options_ignore_abort_set)
    debug = _swig_property(_impl.automaton_parser_options_debug_get, _impl.automaton_parser_options_debug_set)
    trust_hoa = _swig_property(_impl.automaton_parser_options_trust_hoa_get, _impl.automaton_parser_options_trust_hoa_set)
    raise_errors = _swig_property(_impl.automaton_parser_options_raise_errors_get, _impl.automaton_parser_options_raise_errors_set)
    want_kripke = _swig_property(_impl.automaton_parser_options_want_kripke_get, _impl.automaton_parser_options_want_kripke_set)

    def __init__(self):
        _impl.automaton_parser_options_swiginit(self, _impl.new_automaton_parser_options())
    __swig_destroy__ = _impl.delete_automaton_parser_options
automaton_parser_options_swigregister = _impl.automaton_parser_options_swigregister
automaton_parser_options_swigregister(automaton_parser_options)

class automaton_stream_parser(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _impl.automaton_stream_parser_swiginit(self, _impl.new_automaton_stream_parser(*args))
    __swig_destroy__ = _impl.delete_automaton_stream_parser

    def parse(self, *args) -> "spot::parsed_aut_ptr":
        return _impl.automaton_stream_parser_parse(self, *args)
automaton_stream_parser_swigregister = _impl.automaton_stream_parser_swigregister
automaton_stream_parser_swigregister(automaton_stream_parser)


def parse_aut(*args) -> "spot::parsed_aut_ptr":
    return _impl.parse_aut(*args)
parse_aut = _impl.parse_aut
class fair_kripke_succ_iterator(twa_succ_iterator):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _impl.delete_fair_kripke_succ_iterator
fair_kripke_succ_iterator_swigregister = _impl.fair_kripke_succ_iterator_swigregister
fair_kripke_succ_iterator_swigregister(fair_kripke_succ_iterator)

class fair_kripke(twa):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def state_condition(self, s: 'state') -> "bdd":
        return _impl.fair_kripke_state_condition(self, s)

    def state_acceptance_mark(self, s: 'state') -> "spot::acc_cond::mark_t":
        return _impl.fair_kripke_state_acceptance_mark(self, s)
    __swig_destroy__ = _impl.delete_fair_kripke
fair_kripke_swigregister = _impl.fair_kripke_swigregister
fair_kripke_swigregister(fair_kripke)

class kripke_succ_iterator(twa_succ_iterator):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def recycle(self, cond: 'bdd') -> "void":
        return _impl.kripke_succ_iterator_recycle(self, cond)
    __swig_destroy__ = _impl.delete_kripke_succ_iterator
kripke_succ_iterator_swigregister = _impl.kripke_succ_iterator_swigregister
kripke_succ_iterator_swigregister(kripke_succ_iterator)

class kripke(fair_kripke):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _impl.delete_kripke
kripke_swigregister = _impl.kripke_swigregister
kripke_swigregister(kripke)

class ta(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _impl.delete_ta

    def get_initial_states_set(self) -> "spot::ta::const_states_set_t":
        return _impl.ta_get_initial_states_set(self)

    def get_artificial_initial_state(self) -> "spot::state const *":
        return _impl.ta_get_artificial_initial_state(self)

    def succ_iter(self, *args) -> "spot::ta_succ_iterator *":
        return _impl.ta_succ_iter(self, *args)

    def get_dict(self) -> "spot::bdd_dict_ptr":
        return _impl.ta_get_dict(self)

    def format_state(self, s: 'state') -> "std::string":
        return _impl.ta_format_state(self, s)

    def is_accepting_state(self, s: 'state') -> "bool":
        return _impl.ta_is_accepting_state(self, s)

    def is_livelock_accepting_state(self, s: 'state') -> "bool":
        return _impl.ta_is_livelock_accepting_state(self, s)

    def is_initial_state(self, s: 'state') -> "bool":
        return _impl.ta_is_initial_state(self, s)

    def get_state_condition(self, s: 'state') -> "bdd":
        return _impl.ta_get_state_condition(self, s)

    def free_state(self, s: 'state') -> "void":
        return _impl.ta_free_state(self, s)

    def acc(self, *args) -> "spot::acc_cond &":
        return _impl.ta_acc(self, *args)
ta_swigregister = _impl.ta_swigregister
ta_swigregister(ta)

class ta_succ_iterator(twa_succ_iterator):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _impl.delete_ta_succ_iterator
ta_succ_iterator_swigregister = _impl.ta_succ_iterator_swigregister
ta_succ_iterator_swigregister(ta_succ_iterator)

class tgta(twa):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _impl.delete_tgta

    def succ_iter_by_changeset(self, s: 'state', change_set: 'bdd') -> "spot::twa_succ_iterator *":
        return _impl.tgta_succ_iter_by_changeset(self, s, change_set)
tgta_swigregister = _impl.tgta_swigregister
tgta_swigregister(tgta)

class ta_explicit(ta):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, tgba: 'spot::const_twa_ptr const &', n_acc: 'unsigned int', artificial_initial_state: 'state_ta_explicit'=None):
        _impl.ta_explicit_swiginit(self, _impl.new_ta_explicit(tgba, n_acc, artificial_initial_state))

    def get_tgba(self) -> "spot::const_twa_ptr":
        return _impl.ta_explicit_get_tgba(self)

    def add_state(self, s: 'state_ta_explicit') -> "spot::state_ta_explicit *":
        return _impl.ta_explicit_add_state(self, s)

    def add_to_initial_states_set(self, *args) -> "void":
        return _impl.ta_explicit_add_to_initial_states_set(self, *args)

    def create_transition(self, source: 'state_ta_explicit', condition: 'bdd', acceptance_conditions: 'mark_t', dest: 'state_ta_explicit', add_at_beginning: 'bool'=False) -> "void":
        return _impl.ta_explicit_create_transition(self, source, condition, acceptance_conditions, dest, add_at_beginning)

    def delete_stuttering_transitions(self) -> "void":
        return _impl.ta_explicit_delete_stuttering_transitions(self)
    __swig_destroy__ = _impl.delete_ta_explicit

    def succ_iter(self, *args) -> "spot::ta_succ_iterator *":
        return _impl.ta_explicit_succ_iter(self, *args)

    def get_dict(self) -> "spot::bdd_dict_ptr":
        return _impl.ta_explicit_get_dict(self)

    def get_artificial_initial_state(self) -> "spot::state *":
        return _impl.ta_explicit_get_artificial_initial_state(self)

    def set_artificial_initial_state(self, s: 'state_ta_explicit') -> "void":
        return _impl.ta_explicit_set_artificial_initial_state(self, s)

    def delete_stuttering_and_hole_successors(self, s: 'state') -> "void":
        return _impl.ta_explicit_delete_stuttering_and_hole_successors(self, s)

    def get_states_set(self) -> "spot::ta::states_set_t":
        return _impl.ta_explicit_get_states_set(self)
ta_explicit_swigregister = _impl.ta_explicit_swigregister
ta_explicit_swigregister(ta_explicit)

class state_ta_explicit(state):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _impl.delete_state_ta_explicit
state_ta_explicit_swigregister = _impl.state_ta_explicit_swigregister
state_ta_explicit_swigregister(state_ta_explicit)

class ta_explicit_succ_iterator(ta_succ_iterator):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _impl.ta_explicit_succ_iterator_swiginit(self, _impl.new_ta_explicit_succ_iterator(*args))
    __swig_destroy__ = _impl.delete_ta_explicit_succ_iterator
ta_explicit_succ_iterator_swigregister = _impl.ta_explicit_succ_iterator_swigregister
ta_explicit_succ_iterator_swigregister(ta_explicit_succ_iterator)


def make_ta_explicit(tgba: 'spot::const_twa_ptr const &', n_acc: 'unsigned int', artificial_initial_state: 'state_ta_explicit'=None) -> "spot::ta_explicit_ptr":
    return _impl.make_ta_explicit(tgba, n_acc, artificial_initial_state)
make_ta_explicit = _impl.make_ta_explicit
class tgta_explicit(tgta):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, tgba: 'spot::const_twa_ptr const &', n_acc: 'unsigned int', artificial_initial_state: 'state_ta_explicit'):
        _impl.tgta_explicit_swiginit(self, _impl.new_tgta_explicit(tgba, n_acc, artificial_initial_state))

    def get_init_state(self) -> "spot::state *":
        return _impl.tgta_explicit_get_init_state(self)

    def get_ta(self, *args) -> "spot::ta_explicit_ptr":
        return _impl.tgta_explicit_get_ta(self, *args)
    __swig_destroy__ = _impl.delete_tgta_explicit
tgta_explicit_swigregister = _impl.tgta_explicit_swigregister
tgta_explicit_swigregister(tgta_explicit)


def make_tgta_explicit(tgba: 'spot::const_twa_ptr const &', n_acc: 'unsigned int', artificial_initial_state: 'state_ta_explicit'=None) -> "spot::tgta_explicit_ptr":
    return _impl.make_tgta_explicit(tgba, n_acc, artificial_initial_state)
make_tgta_explicit = _impl.make_tgta_explicit

def tgba_to_ta(tgba_to_convert: 'spot::const_twa_ptr const &', atomic_propositions_set: 'bdd', degeneralized: 'bool'=True, artificial_initial_state_mode: 'bool'=True, single_pass_emptiness_check: 'bool'=False, artificial_livelock_state_mode: 'bool'=False, no_livelock: 'bool'=False) -> "spot::ta_explicit_ptr":
    return _impl.tgba_to_ta(tgba_to_convert, atomic_propositions_set, degeneralized, artificial_initial_state_mode, single_pass_emptiness_check, artificial_livelock_state_mode, no_livelock)
tgba_to_ta = _impl.tgba_to_ta

def tgba_to_tgta(tgba_to_convert: 'spot::const_twa_ptr const &', atomic_propositions_set: 'bdd') -> "spot::tgta_explicit_ptr":
    return _impl.tgba_to_tgta(tgba_to_convert, atomic_propositions_set)
tgba_to_tgta = _impl.tgba_to_tgta

def print_dot(*args) -> "std::ostream &":
    return _impl.print_dot(*args)
print_dot = _impl.print_dot
class ta_statistics(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    edges = _swig_property(_impl.ta_statistics_edges_get, _impl.ta_statistics_edges_set)
    states = _swig_property(_impl.ta_statistics_states_get, _impl.ta_statistics_states_set)
    acceptance_states = _swig_property(_impl.ta_statistics_acceptance_states_get, _impl.ta_statistics_acceptance_states_set)

    def dump(self, out: 'ostream') -> "std::ostream &":
        return _impl.ta_statistics_dump(self, out)

    def __init__(self):
        _impl.ta_statistics_swiginit(self, _impl.new_ta_statistics())
    __swig_destroy__ = _impl.delete_ta_statistics
ta_statistics_swigregister = _impl.ta_statistics_swigregister
ta_statistics_swigregister(ta_statistics)


def stats_reachable(*args) -> "spot::ta_statistics":
    return _impl.stats_reachable(*args)
stats_reachable = _impl.stats_reachable

def minimize_ta(ta_: 'spot::const_ta_ptr const &') -> "spot::ta_explicit_ptr":
    return _impl.minimize_ta(ta_)
minimize_ta = _impl.minimize_ta

def minimize_tgta(tgta_: 'spot::const_tgta_explicit_ptr const &') -> "spot::tgta_explicit_ptr":
    return _impl.minimize_tgta(tgta_)
minimize_tgta = _impl.minimize_tgta
class ostream(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _impl.delete_ostream
ostream_swigregister = _impl.ostream_swigregister
ostream_swigregister(ostream)

class ofstream(ostream):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, fn: 'char const *'):
        _impl.ofstream_swiginit(self, _impl.new_ofstream(fn))
    __swig_destroy__ = _impl.delete_ofstream
ofstream_swigregister = _impl.ofstream_swigregister
ofstream_swigregister(ofstream)

class ostringstream(ostream):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        _impl.ostringstream_swiginit(self, _impl.new_ostringstream())

    def str(self) -> "std::string":
        return _impl.ostringstream_str(self)
    __swig_destroy__ = _impl.delete_ostringstream
ostringstream_swigregister = _impl.ostringstream_swigregister
ostringstream_swigregister(ostringstream)


def fnode_instances_check() -> "bool":
    return _impl.fnode_instances_check()
fnode_instances_check = _impl.fnode_instances_check

def ensure_digraph(a: 'spot::twa_ptr const &') -> "spot::twa_graph_ptr":
    return _impl.ensure_digraph(a)
ensure_digraph = _impl.ensure_digraph

def get_cout() -> "std::ostream &":
    return _impl.get_cout()
get_cout = _impl.get_cout

def nl_cout() -> "void":
    return _impl.nl_cout()
nl_cout = _impl.nl_cout

def get_cerr() -> "std::ostream &":
    return _impl.get_cerr()
get_cerr = _impl.get_cerr

def nl_cerr() -> "void":
    return _impl.nl_cerr()
nl_cerr = _impl.nl_cerr

def print_on(on: 'ostream', what: 'std::string const &') -> "void":
    return _impl.print_on(on, what)
print_on = _impl.print_on

def unblock_signal(signum: 'int') -> "int":
    return _impl.unblock_signal(signum)
unblock_signal = _impl.unblock_signal

def states_and(aut: 'spot::twa_graph_ptr const &', il: 'vectorunsigned') -> "unsigned int":
    return _impl.states_and(aut, il)
states_and = _impl.states_and


