<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title><code>ltlcross</code></title>
<!-- 2018-01-20 Sat 14:21 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="root" />
<meta  name="description" content="Spot command-line tool for cross-comparing the output of LTL translators."
 />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" type="text/css" href="spot.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/javascript" src="http://orgmode.org/mathjax/MathJax.js"></script>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
    MathJax.Hub.Config({
        // Only one of the two following lines, depending on user settings
        // First allows browser-native MathML display, second forces HTML/CSS
        //  config: ["MMLorHTML.js"], jax: ["input/TeX"],
            jax: ["input/TeX", "output/HTML-CSS"],
        extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js",
                     "TeX/noUndefined.js"],
        tex2jax: {
            inlineMath: [ ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"], ["\\begin{displaymath}","\\end{displaymath}"] ],
            skipTags: ["script","noscript","style","textarea","pre","code"],
            ignoreClass: "tex2jax_ignore",
            processEscapes: false,
            processEnvironments: true,
            preview: "TeX"
        },
        showProcessingMessages: true,
        displayAlign: "center",
        displayIndent: "2em",

        "HTML-CSS": {
             scale: 100,
             availableFonts: ["STIX","TeX"],
             preferredFont: "TeX",
             webFont: "TeX",
             imageFont: "TeX",
             showMathMenu: true,
        },
        MMLorHTML: {
             prefer: {
                 MSIE:    "MML",
                 Firefox: "MML",
                 Opera:   "HTML",
                 other:   "HTML"
             }
        }
    });
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="tools.html"> UP </a>
 |
 <a accesskey="H" href="index.html"> HOME </a>
</div><div id="content">
<h1 class="title"><code>ltlcross</code></h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Formula selection</a></li>
<li><a href="#sec-2">Configuring translators</a>
<ul>
<li><a href="#sec-2-1">Translator specifications</a></li>
<li><a href="#sec-2-2">Trusted and untrusted translators</a></li>
</ul>
</li>
<li><a href="#sec-3">Getting statistics</a>
<ul>
<li><a href="#sec-3-1">CSV or JSON output (or both!)</a></li>
<li><a href="#sec-3-2">Description of the columns</a></li>
<li><a href="#sec-3-3">Changing the name of the translators</a></li>
</ul>
</li>
<li><a href="#checks">Detecting problems</a></li>
<li><a href="#sec-5">Miscellaneous options</a>
<ul>
<li><a href="#sec-5-1"><code>--stop-on-error</code></a></li>
<li><a href="#sec-5-2"><code>--save-bogus=FILENAME</code></a></li>
<li><a href="#sec-5-3"><code>--grind=FILENAME</code></a></li>
<li><a href="#sec-5-4"><code>--no-check</code></a></li>
<li><a href="#verbose"><code>--verbose</code></a></li>
</ul>
</li>
</ul>
</div>
</div>
<p>
<code>ltlcross</code> is a tool for cross-comparing the output of LTL-to-automata
translators.  It is actually a Spot-based clone of <a href="http://www.tcs.hut.fi/Software/lbtt/">LBTT</a>, the
<i>LTL-to-BÃ¼chi Translator Testbench</i>, that essentially performs the
same sanity checks.
</p>

<p>
The main differences with LBTT are:
</p>
<ul class="org-ul">
<li><b>support for PSL formulas in addition to LTL</b>
</li>
<li>support for (non-alternating) automata with <b>any type of acceptance condition</b>,
</li>
<li>support for <b>weak alternating automata</b>,
</li>
<li>additional intersection <b>checks with the complement</b>, allowing
to check equivalence of automata more precisely,
</li>
<li><b>more statistics</b>, especially:
<ul class="org-ul">
<li>the number of logical transitions represented by each physical edge,
</li>
<li>the number of deterministic states and automata
</li>
<li>the number of SCCs with their various strengths (nonaccepting, terminal, weak, strong)
</li>
<li>the number of terminal, weak, and strong automata
</li>
</ul>
</li>
<li>an option to <b>reduce counterexample</b> by attempting to mutate and
shorten troublesome formulas,
</li>
<li>statistics output in <b>CSV</b> for easier post-processing,
</li>
<li><b>more precise time measurement</b> (LBTT was only precise to
1/100 of a second, reporting most times as "0.00s").
</li>
</ul>

<p>
Although <code>ltlcross</code> performs the same sanity checks as LBTT, it does
not implement any of the interactive features of LBTT.  In our almost
10-year usage of LBTT, we never had to use its interactive features to
understand bugs in our translation.  Therefore <code>ltlcross</code> will report
problems, maybe with a conterexample, but you will be on your own to
investigate and fix them.
</p>

<p>
The core of <code>ltlcross</code> is a loop that does the following steps:
</p>
<ul class="org-ul">
<li>Input a formula
</li>
<li>Translate the formula and its negation using each configured translator.
If there are 3 translators, the positive and negative translations
will be denoted <code>P0</code>, <code>N0</code>, <code>P1</code>, <code>N1</code>, <code>P2</code>, <code>N2</code>.  Optionally
build complemented automata denoted <code>Comp(P0)</code>, <code>Comp(N0)</code>, etc.
</li>
<li>Perform sanity checks between all these automata to detect any problem.
</li>
<li>Build the products of these automata with a random state-space (the same
state-space for all translations).  (If the <code>--products=N</code> option is given,
<code>N</code> products are performed instead.)
</li>
<li>Gather statistics if requested.
</li>
</ul>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Formula selection</h2>
<div class="outline-text-2" id="text-1">
<p>
Formulas to translate should be specified using the <a href="ioltl.html">common input
options</a>.  Standard input is read if it is not connected to a terminal,
and no <code>-f</code> or <code>-F</code> options are given.
</p>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Configuring translators</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">Translator specifications</h3>
<div class="outline-text-3" id="text-2-1">
<p>
Each translator should be specified as a string that use some of the
following character sequences:
</p>

<pre class="example">
%%                         a single %
%f,%s,%l,%w                the formula as a (quoted) string in Spot, Spin,
                           LBT, or Wring's syntax
%F,%S,%L,%W                the formula as a file in Spot, Spin, LBT, or
                           Wring's syntax
%O                         the automaton output in HOA, never claim, LBTT, or
                           ltl2dstar's format
</pre>

<p>
For instance here is how we could cross-compare the never claims
output by <code>spin</code> and <code>ltl2tgba</code> for the formulas <code>GFa</code> and <code>X(a U b)</code>.
</p>

<div class="org-src-container">

<pre class="src src-sh">ltlcross -f <span class="org-string">'GFa'</span> -f <span class="org-string">'X(a U b)'</span> <span class="org-string">'ltl2tgba -s %s &gt;%O'</span> <span class="org-string">'spin -f %s &gt;%O'</span>
</pre>
</div>
<p>
When <code>ltlcross</code> executes these commands, <code>%s</code> will be replaced
by the formula in Spin's syntax, and <code>%O</code> will be replaced by a
temporary file into which the output of the translator is redirected
before it is read back by <code>ltlcross</code>.
</p>

<pre class="example">
[](&lt;&gt;(a))
Running [P0]: ltl2tgba -s '[](&lt;&gt;(a))' &gt;'lcr-o0-vC9D7N'
Running [P1]: spin -f '[](&lt;&gt;(a))' &gt;'lcr-o1-jFh5rq'
Running [N0]: ltl2tgba -s '!([](&lt;&gt;(a)))' &gt;'lcr-o0-xbVIM2'
Running [N1]: spin -f '!([](&lt;&gt;(a)))' &gt;'lcr-o1-4AWn9E'
Performing sanity checks and gathering statistics...

X((a) U (b))
Running [P0]: ltl2tgba -s 'X((a) U (b))' &gt;'lcr-o0-xLa8wh'
Running [P1]: spin -f 'X((a) U (b))' &gt;'lcr-o1-cuYVWT'
Running [N0]: ltl2tgba -s '!(X((a) U (b)))' &gt;'lcr-o0-GVZWmw'
Running [N1]: spin -f '!(X((a) U (b)))' &gt;'lcr-o1-QBGWO8'
Performing sanity checks and gathering statistics...

No problem detected.
</pre>

<p>
To handle tools that do not support some LTL operators, the character
sequences <code>%f</code>, <code>%s</code>, <code>%l</code>, <code>%w</code>, <code>%F</code>, <code>%S</code>, <code>%L</code>, and <code>%W</code> can be
"infixed" by a bracketed list of operators to rewrite away.  For
instance if a tool reads LTL formulas from a file in LBT's syntax, but
does not support operators <code>M</code> (strong until) and <code>W</code> (weak until),
use <code>%[WM]L</code> instead of just <code>%L</code>; this way operators <code>W</code> and <code>M</code> will
be rewritten using the other supported operators.
</p>

<p>
<code>ltlcross</code> can only read four kinds of output:
</p>
<ul class="org-ul">
<li>Never claims (only if they are restricted to representing an
automaton using <code>if</code>, <code>goto</code>, and <code>skip</code> statements) such as those
output by <a href="http://spinroot.com/"><code>spin</code></a>, <a href="http://www.lsv.ens-cachan.fr/~gastin/ltl2ba/"><code>ltl2ba</code></a>, <a href="https://sourceforge.net/projects/ltl3ba/"><code>ltl3ba</code></a>, or <code>ltl2tgba --spin</code>.  The
newer syntax introduced by Spin 6.24, using <code>do</code> instead of <code>if</code>,
is also supported.
</li>
<li><a href="http://www.tcs.hut.fi/Software/lbtt/doc/html/Format-for-automata.html">LBTT's format</a>, which supports generalized BÃ¼chi automata with
either state-based acceptance or transition-based acceptance.
This output is used for instance by <a href="http://www.tcs.hut.fi/Software/maria/tools/lbt/"><code>lbt</code></a>, <a href="http://web.archive.org/web/20080607170403/http://www.science.unitn.it/~stonetta/modella.html"><code>modella</code></a>, or <code>ltl2tgba
    --lbtt</code>.
</li>
<li>Non-alternating automata in <a href="http://adl.github.io/hoaf/">the HOA format</a> with any acceptance
condition.
</li>
<li><a href="concepts.html#property-flags">Weak</a> alternating automata in <a href="http://adl.github.io/hoaf/">the HOA format</a>.
</li>
<li><a href="http://www.ltl2dstar.de/docs/ltl2dstar.html"><code>ltl2dstar</code>'s format</a>, which supports deterministic Rabin or Streett
automata.
</li>
</ul>

<p>
Files in any of these format should be indicated with <code>%O</code>.  (Past
versions of <code>ltlcross</code> used different letters for each format, but the
four parsers have been merged into a single one.)
</p>

<p>
Of course all configured tools need not use the same <code>%</code> sequences.
The following list shows some typical configurations for some existing
tools:
</p>

<ul class="org-ul">
<li>'<code>spin -f %s &gt;%O</code>'
</li>
<li>'<code>ltl2ba -f %s &gt;%O</code>'
</li>
<li>'<code>ltl3ba -M0 -f %s &gt;%O</code>' (less deterministic output, can be smaller)
</li>
<li>'<code>ltl3ba -M1 -f %s &gt;%O</code>' (more deterministic output)
</li>
<li>'<code>modella -r12 -g -e %[MWei^]L %O</code>'
</li>
<li>'<code>/path/to/script4lbtt.py %L %O</code>' (script supplied by <a href="http://web.archive.org/web/20070214050826/http://estragon.ti.informatik.uni-kiel.de/~fritz/">ltl2nba</a> for
its interface with LBTT)
</li>
<li>'<code>ltl2tgba -s %f &gt;%O</code>' (smaller output, BÃ¼chi automaton)
</li>
<li>'<code>ltl2tgba -s -D %f &gt;%O</code>' (more deterministic output, BÃ¼chi automaton)
</li>
<li>'<code>ltl2tgba -H %f &gt;%O</code>' (smaller output, TGBA)
</li>
<li>'<code>ltl2tgba -H -D %f &gt;%O</code>' (more deterministic output, TGBA)
</li>
<li>'<code>lbt &lt;%L &gt;%O</code>'
</li>
<li>'<code>ltl2dstar --ltl2nba=spin:path/to/ltl2tgba@-sD
    --output-format=hoa %[MW]L %O</code>' deterministic Rabin output in HOA, as
supported since version 0.5.2 of <code>ltl2dstar</code>.
</li>
<li>'<code>ltl2dstar --ltl2nba=spin:path/to/ltl2tgba@-sD --automata=streett
    --output-format=hoa %[MW]L %O</code>' deterministic Streett output in HOA,
as supported since version 0.5.2 of <code>ltl2dstar</code>.
</li>
<li>'<code>ltl2dstar --ltl2nba=spin:path/to/ltl2tgba@-sD %[MW]L %O</code>' (Rabin
output in DSTAR format, as supported in older versions of
<code>ltl2dstar</code>.
</li>
<li>'<code>ltl2dstar --ltl2nba=spin:path/to/ltl2tgba@-sD %L - | dstar2tgba
    -s &gt;%O</code>' (external conversion from Rabin to BÃ¼chi done by
<code>dstar2tgba</code> for more reduction of the BÃ¼chi automaton than what
<code>ltlcross</code> would provide)
</li>
<li>'<code>java -jar Rabinizer.jar -ltl2dstar %[MW]F %O; mv %O.dst %O</code>' (Rabinizer
uses the last <code>%O</code> argument as a prefix to which it always append <code>.dst</code>,
so we have to rename <code>%O.dst</code> as <code>%O</code> so that <code>ltlcross</code> can find the file)
</li>
<li>'<code>java -jar rabinizer3.1.jar -in=formula -silent -out=std -format=hoa -auto=tr %[MWRei^]f &gt;%O</code>'
(rabinizer 3.1 can output automata in the HOA format)
</li>
<li>'<code>ltl3dra -f %s &gt;%O</code>' (The HOA format is the default for <code>ltl3dra</code>.)
</li>
<li>'<code>ltl3tela -f %s &gt;%O</code>' (The HOA format is the default for <code>ltl3tela</code>.)
</li>
</ul>

<p>
To simplify the use of some of the above tools, a set of predefined
shorthands are available.  Those can be listed with the
<code>--list-shorthands</code> option.
</p>

<div class="org-src-container">

<pre class="src src-sh">ltlcross --list-shorthands
</pre>
</div>
<pre class="example">
If a COMMANDFMT does not use any %-sequence, and starts with one of
the following words, then the string on the right is appended.

  lbt          &lt;%L&gt;%O
  ltl2ba       -f %s&gt;%O
  ltl2da       %f&gt;%O
  ltl2dpa      %f&gt;%O
  ltl2ldba     %f&gt;%O
  ltl2dstar    --output-format=hoa %[MW]L %O
  ltl2tgba     -H %f&gt;%O
  ltl3ba       -f %s&gt;%O
  ltl3dra      -f %s&gt;%O
  ltl3hoa      -f %f&gt;%O
  ltl3tela     -f %f&gt;%O
  modella      %[MWei^]L %O
  spin         -f %s&gt;%O

Any {name} and directory component is skipped for the purpose of
matching those prefixes.  So for instance
  '{DRA} ~/mytools/ltl2dstar-0.5.2'
will be changed into
  '{DRA} ~/mytools/ltl2dstar-0.5.2 --output-format=hoa %[MW]L %O'
</pre>

<p>
What this implies is that running <code>ltlcross ltl2ba ltl3ba ...</code> is
the same as running <code>ltlcross 'ltl2ba -f %s&gt;%O' 'ltl3ba -f %s&gt;%O' ...</code>
</p>

<p>
Because only the prefix of the actual command is checked, you can
still specify some options.  For instance <code>ltlcross 'ltl2tgba -D' ...</code>
is short for <code>ltlcross 'ltl2tgba -D -H %F&gt;%O' ...</code>
</p>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">Trusted and untrusted translators</h3>
<div class="outline-text-3" id="text-2-2">
<p>
By default, all translators specified are not trusted.  This means
that <code>ltlcross</code> will cross-compare the output of all translators,
possibly yielding a quadratic number of tests.
</p>

<p>
It is possible to declare that certain translators should be trusted
by specifying them with the <code>--reference=COMMANDFMT</code> option.  This has
a few implications:
</p>
<ul class="org-ul">
<li>the automata output by reference translators are not tested
</li>
<li>a pair of positive and negative reference automata are selected
from the reference translators (the smallest automata, in case
multiple references are available), and all other translators will
only be compared to these reference automata.
</li>
</ul>

<p>
Consequently, the number of test performed is now linear in the number
of untrusted references.  The easiest way to observe the effect of
<code>--reference</code> is to run the <code>ltlcross</code> with the <a href="#verbose"><code>--verbose</code> option</a>,
with and without some <code>--reference</code> translators.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">Getting statistics</h2>
<div class="outline-text-2" id="text-3">
<p>
Detailed statistics about the result of each translation, and the
product of that resulting automaton with the random state-space, can
be obtained using the <code>--csv=FILE</code> or <code>--json=FILE</code> option.
</p>
</div>

<div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">CSV or JSON output (or both!)</h3>
<div class="outline-text-3" id="text-3-1">
<p>
The following compare <code>ltl2tgba</code>, <code>spin</code>, and <code>lbt</code> on three random
formulas (where <code>W</code> and <code>M</code> operators have been rewritten away because
they are not supported by <code>spin</code> and <code>lbt</code>).
</p>

<div class="org-src-container">

<pre class="src src-sh">randltl -n 3 a b |
ltlfilt --remove-wm |
ltlcross --csv=results.csv <span class="org-sh-escaped-newline">\</span>
         <span class="org-string">'ltl2tgba -s %f &gt;%O'</span> <span class="org-sh-escaped-newline">\</span>
         <span class="org-string">'spin -f %s &gt;%O'</span> <span class="org-sh-escaped-newline">\</span>
         <span class="org-string">'lbt &lt; %L &gt;%O'</span>
</pre>
</div>
<p>
After this execution, the file <code>results.csv</code> contains the following:
</p>

<pre class="example">
"formula","tool","exit_status","exit_code","time","states","edges","transitions","acc","scc","nondet_states","nondet_aut","complete_aut","product_states","product_transitions","product_scc"
"0","ltl2tgba -s %f &gt;%O","ok",0,0.0118255,1,1,0,1,1,0,0,0,1,0,1
"0","spin -f %s &gt;%O","ok",0,0.000940633,2,2,1,1,2,0,0,0,1,0,1
"0","lbt &lt; %L &gt;%O","exit code",2,0.00103297,,,,,,,,,,,
"1","ltl2tgba -s %f &gt;%O","ok",0,0.0107316,1,1,1,1,1,0,0,1,200,4199,1
"1","spin -f %s &gt;%O","ok",0,0.00085299,2,2,2,1,2,0,0,1,201,4220,2
"1","lbt &lt; %L &gt;%O","exit code",2,0.000888048,,,,,,,,,,,
"!((1) U (F(!(p0))))","ltl2tgba -s %f &gt;%O","ok",0,0.0107568,1,1,1,1,1,0,0,0,200,2059,1
"!((1) U (F(!(p0))))","spin -f %s &gt;%O","ok",0,0.000893701,1,1,1,1,1,0,0,0,200,2059,1
"!((1) U (F(!(p0))))","lbt &lt; %L &gt;%O","exit code",2,0.00105079,,,,,,,,,,,
"(1) U (F(!(p0)))","ltl2tgba -s %f &gt;%O","ok",0,0.010926,2,3,4,1,2,0,0,1,400,8264,2
"(1) U (F(!(p0)))","spin -f %s &gt;%O","ok",0,0.000946616,2,3,5,1,2,1,1,1,400,10337,2
"(1) U (F(!(p0)))","lbt &lt; %L &gt;%O","exit code",2,0.00111029,,,,,,,,,,,
"(1) U ((G(p0)) | (F(p1)))","ltl2tgba -s %f &gt;%O","ok",0,0.0118564,3,5,11,1,3,1,1,0,600,11358,3
"(1) U ((G(p0)) | (F(p1)))","spin -f %s &gt;%O","ok",0,0.00103259,4,8,24,1,4,2,1,0,800,24920,4
"(1) U ((G(p0)) | (F(p1)))","lbt &lt; %L &gt;%O","exit code",2,0.00118567,,,,,,,,,,,
"!((1) U ((G(p0)) | (F(p1))))","ltl2tgba -s %f &gt;%O","ok",0,0.0109786,2,4,4,1,1,0,0,0,395,3964,1
"!((1) U ((G(p0)) | (F(p1))))","spin -f %s &gt;%O","ok",0,0.00325304,6,18,17,1,4,5,1,0,592,8891,1
"!((1) U ((G(p0)) | (F(p1))))","lbt &lt; %L &gt;%O","exit code",2,0.00111555,,,,,,,,,,,
</pre>

<p>
This file can be loaded in any spreadsheet or statistical application.
</p>

<p>
Although we only supplied 2 random generated formulas, the output
contains 4 formulas because <code>ltlcross</code> had to translate the positive
and negative version of each.
</p>

<p>
If we had used the option <code>--json=results.json</code> instead of (or in
addition to) <code>--cvs=results.csv</code>, the file <code>results.json</code> would have
contained the following <a href="http://www.json.org/">JSON</a> output.
</p>

<pre class="example">
{
  "tool": [
    "ltl2tgba -s %f &gt;%O",
    "spin -f %s &gt;%O",
    "lbt &lt; %L &gt;%O"
  ],
  "formula": [
    "0",
    "1",
    "!((1) U (F(!(p0))))",
    "(1) U (F(!(p0)))",
    "(1) U ((G(p0)) | (F(p1)))",
    "!((1) U ((G(p0)) | (F(p1))))"
  ],
  "fields":  [
  "formula","tool","exit_status","exit_code","time","states","edges","transitions","acc","scc","nondet_states","nondet_aut","complete_aut","product_states","product_transitions","product_scc"
  ],
  "inputs":  [ 0, 1 ],
  "results": [
    [ 0,0,"ok",0,0.0118255,1,1,0,1,1,0,0,0,1,0,1 ],
    [ 0,1,"ok",0,0.000940633,2,2,1,1,2,0,0,0,1,0,1 ],
    [ 0,2,"exit code",2,0.00103297,null,null,null,null,null,null,null,null,null,null,null ],
    [ 1,0,"ok",0,0.0107316,1,1,1,1,1,0,0,1,200,4199,1 ],
    [ 1,1,"ok",0,0.00085299,2,2,2,1,2,0,0,1,201,4220,2 ],
    [ 1,2,"exit code",2,0.000888048,null,null,null,null,null,null,null,null,null,null,null ],
    [ 2,0,"ok",0,0.0107568,1,1,1,1,1,0,0,0,200,2059,1 ],
    [ 2,1,"ok",0,0.000893701,1,1,1,1,1,0,0,0,200,2059,1 ],
    [ 2,2,"exit code",2,0.00105079,null,null,null,null,null,null,null,null,null,null,null ],
    [ 3,0,"ok",0,0.010926,2,3,4,1,2,0,0,1,400,8264,2 ],
    [ 3,1,"ok",0,0.000946616,2,3,5,1,2,1,1,1,400,10337,2 ],
    [ 3,2,"exit code",2,0.00111029,null,null,null,null,null,null,null,null,null,null,null ],
    [ 4,0,"ok",0,0.0118564,3,5,11,1,3,1,1,0,600,11358,3 ],
    [ 4,1,"ok",0,0.00103259,4,8,24,1,4,2,1,0,800,24920,4 ],
    [ 4,2,"exit code",2,0.00118567,null,null,null,null,null,null,null,null,null,null,null ],
    [ 5,0,"ok",0,0.0109786,2,4,4,1,1,0,0,0,395,3964,1 ],
    [ 5,1,"ok",0,0.00325304,6,18,17,1,4,5,1,0,592,8891,1 ],
    [ 5,2,"exit code",2,0.00111555,null,null,null,null,null,null,null,null,null,null,null ]
  ]
}
</pre>

<p>
Here the <code>fields</code> table describes the columns of the <code>results</code> table.
The <code>inputs</code> tables lists the columns that are considered as inputs
for the experiments.  The values in the columns corresponding to the
fields <code>formula</code> and <code>tool</code> contains indices relative to the <code>formula</code>
and <code>tool</code> tables.  This format is more compact when dealing with lots
of translators and formulas, because they don't have to be repeated on
each line as in the CSV version.
</p>

<p>
JSON data can be easily processed in any language.  For instance the
following Python3 script averages each column (except the first four)
for each tool, and presents the results in a form that can almost be
copied into a LaTeX table (the <code>%</code> in the tool names have to be taken
care of).  Note that for simplicity we assume that the first two
columns are inputs, instead of reading the <code>inputs</code> field.
</p>

<div class="org-src-container">

<pre class="src src-python"><span class="org-comment-delimiter">#</span><span class="org-comment">!/usr/bin/python3</span>
<span class="org-keyword">import</span> json
<span class="org-variable-name">data</span> = json.load(<span class="org-builtin">open</span>(<span class="org-string">'results.json'</span>))
<span class="org-variable-name">datacols</span> = <span class="org-builtin">range</span>(4, <span class="org-builtin">len</span>(data[<span class="org-string">"fields"</span>]))
<span class="org-comment-delimiter"># </span><span class="org-comment">Index results by tool</span>
<span class="org-variable-name">results</span> = { t:[] <span class="org-keyword">for</span> t <span class="org-keyword">in</span> <span class="org-builtin">range</span>(0, <span class="org-builtin">len</span>(data[<span class="org-string">"tool"</span>])) }
<span class="org-keyword">for</span> l <span class="org-keyword">in</span> data[<span class="org-string">"results"</span>]:
  results[l[1]].append(l)
<span class="org-comment-delimiter"># </span><span class="org-comment">Average columns for each tool, and display them as a table</span>
<span class="org-keyword">print</span>(<span class="org-string">"%-18s &amp; count &amp; %s \\\\"</span> % (<span class="org-string">"tool"</span>, <span class="org-string">" &amp; "</span>.join(data[<span class="org-string">"fields"</span>][4:])))
<span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(0, <span class="org-builtin">len</span>(data[<span class="org-string">"tool"</span>])):
  <span class="org-variable-name">c</span> = <span class="org-builtin">len</span>(results[i])
  <span class="org-variable-name">sums</span> = [<span class="org-string">"%6.1f"</span> % (<span class="org-builtin">sum</span>([x[j] <span class="org-keyword">for</span> x <span class="org-keyword">in</span> results[i]])/c)
          <span class="org-keyword">for</span> j <span class="org-keyword">in</span> datacols]
  <span class="org-keyword">print</span>(<span class="org-string">"%-18s &amp; %3d &amp; %s \\\\"</span> % (data[<span class="org-string">"tool"</span>][i], c,
        <span class="org-string">" &amp; "</span>.join(sums)))
</pre>
</div>
<p>
The script <code>bench/ltl2tgba/sum.py</code> is a more evolved version of the
above script that generates two kinds of LaTeX tables.
</p>

<p>
When computing such statistics, you should be aware that inputs for
which a tool failed to generate an automaton (e.g. it crashed, or it
was killed if you used <code>ltlcross</code>'s <code>--timeout</code> option to limit run
time) will appear as mostly empty lines in the CSV or JSON files,
since most statistics cannot be computed without an automaton&#x2026;
Those lines with missing data can be omitted with the <code>--omit-missing</code>
option (this used to be the default up to Spot 1.2).
</p>

<p>
However data for bogus automata are still included: as shown below
<code>ltlcross</code> will report inconsistencies between automata as errors, but
it does not try to guess who is incorrect.
</p>
</div>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2">Description of the columns</h3>
<div class="outline-text-3" id="text-3-2">
<p>
The number of column output in the CSV or JSON outputs depend on the
options passed to <code>ltlcross</code>. Additional columns will be output if
<code>--strength</code>, <code>--ambiguous</code>, <code>--automata</code>, or <code>--product=+N</code> are used.
</p>

<p>
Columns <code>formula</code> and <code>tool</code> contain the formula translated and the
command run to translate it.  In the CSV, these columns contain the
actual text.  In the JSON output, these column contains an index into
the <code>formula</code> and <code>tool</code> table declared separately.
</p>

<p>
<code>exit_status</code> and <code>exit_code</code> are used to indicate if the translator
successfully produced an automaton, or if it failed.  On successful
translation, <code>exit_status</code> is equal to "<code>ok</code>" and <code>exit_code</code> is 0.
If the translation took more time than allowed with the <code>--timeout</code>
option, <code>exit_status</code> will contain "<code>timeout</code>" and <code>exit_code</code> will be
set to -1.  Other values are used to diagnose various issues: please
check the man-page for <code>ltlcross</code> for a list of them.
</p>

<p>
<code>time</code> obviously contains the time used by the translation.  Time is
measured with some high-resolution clock when available (that's
nanosecond accuracy under Linux), but because translator commands are
executed through a shell, it also includes the time to start a shell.
(This extra cost apply identically to all translators, so it is not unfair.)
</p>


<p>
All the values that follow will be missing if <code>exit_status</code> is not
equal to "<code>ok</code>".  (You may instruct <code>ltlcross</code> not to output lines with
such missing data with the option <code>--omit-missing</code>.)
</p>

<p>
<code>states</code>, <code>edges</code>, <code>transitions</code>, <code>acc</code> are size measures for the
automaton that was translated.  <code>acc</code> counts the number of acceptance
sets.  When building (degeneralized) BÃ¼chi automata, it will always be
<code>1</code>, so its value is meaningful only when evaluating translations to
generalized BÃ¼chi automata.  <code>edges</code> counts the actual number of edges
in the graph supporting the automaton; an edge (labeled by a Boolean
formula) might actually represent several transitions (each labeled by
assignment of all atomic propositions).  For instance in an automaton
where the atomic proposition are \(a\) and \(b\), one edge labeled by
\(a\lor b\) actually represents three transitions \(a b\), \(a\bar b\), and
\(\bar a b\).
</p>

<p>
The following picture displays two automata for the LTL formula <code>a U
b</code>.  They both have 2 states and 3 edges, however they differ in the
number of transitions (7 versus 8), because the initial self-loop is
more constrained in the first automaton.  A smaller number of
transition is therefore an indication of a more constrained automaton.
</p>


<div class="figure">
<p><img src="edges.svg" alt="edges.svg" />
</p>
</div>


<p>
<code>scc</code> counts the number of strongly-connected components in the automaton.
</p>

<p>
If option <code>--strength</code> is passed to <code>ltlcross</code>, these SCCs are
also partitioned on four sets based on their strengths:
</p>
<ul class="org-ul">
<li><code>nonacc_scc</code> for non-accepting SCCs (such as states A1 and A2 in the
previous picture).
</li>
<li><code>terminal_scc</code> for accepting SCCs where all states or edges belong
to the same acceptance sets, and that are complete (i.e., any state
in a terminal SCC accepts the universal language).  States
B1 and B2 in the previous picture are two terminal SCCs.
</li>
<li><code>weak_scc</code> for accepting SCCs where all states or edges belong
to the same acceptance sets, but that are not complete.
</li>
<li><code>strong_scc</code> for accepting SCCs that are not weak.
</li>
</ul>

<p>
These SCC strengths can be used to compute the strength of the
automaton as a whole:
</p>
<ul class="org-ul">
<li>an automaton is terminal if it contains only non-accepting or
terminal SCCs,
</li>
<li>an automaton is weak if it it contains only non-accepting,
terminal, or weak SCCs,
</li>
<li>an automaton is strong if it contains at least one strong SCC.
</li>
</ul>

<p>
This classification is used to fill the <code>terminal_aut</code>, <code>weak_aut</code>,
<code>strong_aut</code> columns with Boolean values (still only if option
<code>--strength</code> is passed).  Only one of these should contain <code>1</code>.  We
usually prefer terminal automata over weak automata, and weak automata
over strong automata, because the emptiness check of terminal (and
weak) automata is easier.  When working with alternating automata, all
those strength-related columns will be empty, because the routines
used to compute those statistic do not yet support universal edges.
</p>

<p>
<code>nondetstates</code> counts the number of non-deterministic states in the
automaton.  <code>nondeterministic</code> is a Boolean value indicating if the
automaton is not deterministic.  For instance in the previous picture
showing two automata for <code>a U b</code>, the first automaton is deterministic
(these two fields will contain 0), while the second automaton contain
a nondeterministic state (state A2 has two possible successors for the
assignment \(ab\)) and is therefore not deterministic.
</p>

<p>
If option <code>--aumbiguous</code> was passed to <code>ltlcross</code>, the column
<code>ambiguous_aut</code> holds a Boolean indicating whether the automaton is
ambiguous, i.e., if there exists a word that can be accepted by at
least two different runs.  (This information is not yet available for
alternating automata.)
</p>

<p>
<code>complete_aut</code> is a Boolean indicating whether the automaton is
complete.
</p>

<p>
Columns <code>product_states</code>, <code>product_transitions</code>, and <code>product_scc</code>
count the number of state, transitions and strongly-connect components
in the product that has been built between the translated automaton
and a random model.  For a given formula, the same random model is of
course used against the automata translated by all tools.  Comparing
the size of these product might give another indication of the
"conciseness" of a translated automaton.
</p>

<p>
There is of course a certain "luck factor" in the size of the product.
Maybe some translator built a very dumb automaton, with many useless
states, in which just a very tiny part is translated concisely.  By
luck, the random model generated might synchronize with this tiny part
only, and ignore the part with all the useless states.  A way to
lessen this luck factor is to increase the number of products
performed against the translated automaton.  If option <code>--products=N</code>
is used, <code>N</code> products are builds instead of one, and the fields
<code>product_states</code>, <code>product_transitions</code>, and <code>product_scc</code> contain
average values.
</p>

<p>
If the option <code>--products=+N</code> is used (with a <code>+</code> in front of the
number), then no average value is computed.  Instead, three columns
<code>product_states</code>, <code>product_transitions</code>, and <code>product_scc</code> are output
for each individual product (i.e., \(3\times N\) columns are output).
This might be useful if you want to compute different kind of
statistic (e.g., a median instead of a mean) or if you want to build
scatter plots of all these products.
</p>

<p>
Finally, if the <code>--automata</code> option was passed to <code>ltlcross</code>, the CSV
or JSON output will contain a column named <code>automaton</code> encoding each
produced automaton in the HOA format.
</p>
</div>
</div>

<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3">Changing the name of the translators</h3>
<div class="outline-text-3" id="text-3-3">
<p>
By default, the names used in the CSV and JSON output to designate the
translators are the command specified on the command line.
</p>

<p>
For instance in the following, <code>ltl2tgba</code> is run in two
configurations, and the strings <code>ltl2tgba -s --small %f &gt;%O</code> and
<code>ltl2tgba -s --deter %f &gt;%O</code> appear verbatim in the output:
</p>

<div class="org-src-container">

<pre class="src src-sh">ltlcross -f a -f Ga <span class="org-string">'ltl2tgba -s --small %f &gt;%O'</span> <span class="org-string">'ltl2tgba -s --deter %f &gt;%O'</span> --csv
</pre>
</div>
<pre class="example">
"formula","tool","exit_status","exit_code","time","states","edges","transitions","acc","scc","nondet_states","nondet_aut","complete_aut","product_states","product_transitions","product_scc"
"a","ltl2tgba -s --small %f &gt;%O","ok",0,0.0121034,2,2,3,1,2,0,0,0,201,4144,2
"a","ltl2tgba -s --deter %f &gt;%O","ok",0,0.0103523,2,2,3,1,2,0,0,0,201,4144,2
"!(a)","ltl2tgba -s --small %f &gt;%O","ok",0,0.0107823,2,2,3,1,2,0,0,0,201,4149,2
"!(a)","ltl2tgba -s --deter %f &gt;%O","ok",0,0.011203,2,2,3,1,2,0,0,0,201,4149,2
"G(a)","ltl2tgba -s --small %f &gt;%O","ok",0,0.0116035,1,1,1,1,1,0,0,0,200,2059,1
"G(a)","ltl2tgba -s --deter %f &gt;%O","ok",0,0.0109578,1,1,1,1,1,0,0,0,200,2059,1
"!(G(a))","ltl2tgba -s --small %f &gt;%O","ok",0,0.0108189,2,3,4,1,2,0,0,1,400,8264,2
"!(G(a))","ltl2tgba -s --deter %f &gt;%O","ok",0,0.0112786,2,3,4,1,2,0,0,1,400,8264,2
</pre>

<p>
To present these results graphically, or even when analyzing these
data, it might be convenient to give each configured tool a shorter
name.  <code>ltlcross</code> supports the specification of such short names by
looking whether the command specification for a translator has the
form "<code>{short name}actual command</code>".
</p>

<p>
For instance:
</p>
<div class="org-src-container">

<pre class="src src-sh">ltlcross -f a -f Ga <span class="org-string">'{small} ltl2tgba -s --small %f &gt;%O'</span> <span class="org-string">'{deter} ltl2tgba -s --deter %f &gt;%O'</span> --csv
</pre>
</div>
<pre class="example">
"formula","tool","exit_status","exit_code","time","states","edges","transitions","acc","scc","nondet_states","nondet_aut","complete_aut","product_states","product_transitions","product_scc"
"a","small","ok",0,0.0116398,2,2,3,1,2,0,0,0,201,4144,2
"a","deter","ok",0,0.0110265,2,2,3,1,2,0,0,0,201,4144,2
"!(a)","small","ok",0,0.010495,2,2,3,1,2,0,0,0,201,4149,2
"!(a)","deter","ok",0,0.0108326,2,2,3,1,2,0,0,0,201,4149,2
"G(a)","small","ok",0,0.0109243,1,1,1,1,1,0,0,0,200,2059,1
"G(a)","deter","ok",0,0.0108448,1,1,1,1,1,0,0,0,200,2059,1
"!(G(a))","small","ok",0,0.0110369,2,3,4,1,2,0,0,1,400,8264,2
"!(G(a))","deter","ok",0,0.0113772,2,3,4,1,2,0,0,1,400,8264,2
</pre>
</div>
</div>
</div>

<div id="outline-container-checks" class="outline-2">
<h2 id="checks"><a id="sec-4" name="sec-4"></a>Detecting problems</h2>
<div class="outline-text-2" id="text-checks">

<p>
If a translator exits with a non-zero status code, or fails to output
an automaton <code>ltlcross</code> can read, and error will be displayed and the
result of the translation will be discarded.
</p>

<p>
Otherwise <code>ltlcross</code> performs the following checks on all translated
formulas (\(P_i\) and \(N_i\) designate respectively the translation of
positive and negative formulas by the ith translator).
</p>

<ul class="org-ul">
<li>Intersection check: \(P_i\otimes N_j\) must be empty for all
pairs of \((i,j)\).

<p>
A single failing translator might generate a lot of lines of
the form:
</p>

<pre class="example">
error: P0*N1 is nonempty; both automata accept the infinite word:
       cycle{p0 &amp; !p1}
error: P1*N0 is nonempty; both automata accept the infinite word:
       p0; !p1; cycle{p0 &amp; p1}
error: P1*N1 is nonempty; both automata accept the infinite word:
       p0; cycle{!p1 &amp; !p0}
error: P1*N2 is nonempty; both automata accept the infinite word:
       p0; !p1; cycle{p0 &amp; p1}
error: P1*N3 is nonempty; both automata accept the infinite word:
       p0; !p1; cycle{p0 &amp; p1}
error: P1*N4 is nonempty; both automata accept the infinite word:
       p0; cycle{!p1 &amp; !p0}
error: P2*N1 is nonempty; both automata accept the infinite word:
       p0; !p1; !p0; cycle{!p1 &amp; !p0; p0 &amp; !p1; !p1; !p1; p0 &amp; !p1}
error: P3*N1 is nonempty; both automata accept the infinite word:
       p0; !p1; !p1 &amp; !p0; cycle{p0 &amp; !p1}
error: P4*N1 is nonempty; both automata accept the infinite word:
       p0; !p1; !p1 &amp; !p0; cycle{p0 &amp; !p1}
</pre>

<p>
In this example, translator number <code>1</code> looks clearly faulty
(at least the other 4 translators do not contradict each other).
</p>

<p>
Examples of infinite words that are accepted by both automata
always have the form of a lasso: a (possibly empty) finite prefix
followed by a cycle that should be repeated infinitely often.
The cycle part is denoted by <code>cycle{...}</code>.
</p>
</li>

<li>Complemented intersection check.  If \(P_i\) and \(N_i\) are
deterministic, <code>ltlcross</code> builds their complements, \(Comp(P_i)\)
and \(Comp(N_i)\), and then ensures that \(Comp(P_i)\otimes
    Comp(N_i)\) is empty.  If only one of them is deterministic, for
instance \(P_i\), we check that \(P_j\otimes Comp(P_i)\) for all \(j
    \ne i\); likewise if it's \(N_i\) that is deterministic.

<p>
By default this check is only done for deterministic automata,
because complementation is relatively cheap is that case (at least
it is cheap for simple acceptance conditions).  Using option
<code>--determinize</code>, <code>ltlcross</code> can be instructed to perform
complementation of non-deterministic automata as well, ensuring
precise equivalence checks between all automata.  However be aware
that this determinization + complementation may generate large
automata.
</p>

<p>
When validating a translator with <code>ltlcross</code> without using the
<code>--determinize</code> option we highly recommend to include a translator
with good deterministic output to augment test coverage.  Using
'<code>ltl2tgba -lD %f &gt;%O</code>' will produce deterministic automata for
all obligation properties and many recurrence properties.  Using
'<code>ltl2dstar --ltl2nba=spin:pathto/ltl2tgba@-Ds %L %O</code>' will
systematically produce a deterministic Rabin automaton (that
<code>ltlcross</code> can complement easily).
</p>
</li>

<li>Cross-comparison checks: for some state-space \(S\),
all \(P_i\otimes S\) are either all empty, or all non-empty.
Similarly all \(N_i\otimes S\) are either all empty, or all non-empty.

<p>
A cross-comparison failure could be displayed as:
</p>

<pre class="example">
error: {P0,P2} disagree with {P1} when evaluating the state-space
       the following word(s) are not accepted by {P1}:
 P0 accepts: p0 &amp; !p1 &amp; !p2 &amp; p3; p0 &amp; p1 &amp; !p2 &amp; p3; p0 &amp; p1 &amp; p2 &amp; p3; cycle{p0 &amp; p1 &amp; p2 &amp; p3; p0 &amp; p1 &amp; !p2 &amp; !p3; p0 &amp; p1 &amp; p2 &amp; !p3; p0 &amp; p1 &amp; !p2 &amp; !p3}
 P2 accepts: p0 &amp; !p1 &amp; !p2 &amp; p3; cycle{p0 &amp; p1 &amp; !p2 &amp; !p3; p0 &amp; p1 &amp; p2 &amp; p3; p0 &amp; p1 &amp; !p2 &amp; p3}
</pre>

<p>
If <code>--products=N</code> is used with <code>N</code> greater than one, the number of
the state-space is also printed.  This number is of no use by
itself, except to explain why you may get multiple disagreement
between the same sets of automata.
</p>

<p>
These products tests may sometime catch errors that were not
captured by the first two tests if one non-deterministic automaton
recognize less words than what it should.  If the input automata
are deterministic or the <code>--determinize</code> option is used, this test
is redundant and can be disabled.  (In fact, the <code>--determinize</code>
option implies option <code>--product=0</code> to do so.)
</p>
</li>

<li>Consistency check:

<p>
For each \(i\), the products \(P_i\otimes S\) and \(N_i\otimes S\)
actually cover all states of \(S\).  Because \(S\) does not have any
deadlock, any of its infinite path must be accepted by \(P_i\) or
\(N_i\) (or both).
</p>

<p>
An error in that case is displayed as
</p>

<pre class="example">
error: inconsistency between P1 and N1
</pre>

<p>
If <code>--products=N</code> is used with <code>N</code> greater than one, the number of
the state-space in which the inconsistency was detected is also
printed.
</p>

<p>
This test may catch errors that were not captured by the first two
tests if one non-deterministic automaton recognize less words than
what it should.  If the input automata are deterministic or the
<code>--determinize</code> option is used, this test is redundant and can be
disabled.  (In fact, the <code>--determinize</code> option implies option
<code>--product=0</code> to do so.)
</p>
</li>
</ul>

<p>
The above checks are similar to those that are performed by <a href="http://www.tcs.hut.fi/Software/lbtt/">LBTT</a>,
except for the complemented intersection check, which is only done in
<code>ltlcross</code>.
</p>

<p>
If any problem was reported during the translation of one of the
formulas, <code>ltlcheck</code> will exit with an exit status of <code>1</code>.  Statistics
(if requested) are output nonetheless, and include any faulty
automaton as well.
</p>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">Miscellaneous options</h2>
<div class="outline-text-2" id="text-5">
</div><div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1"><code>--stop-on-error</code></h3>
<div class="outline-text-3" id="text-5-1">
<p>
The <code>--stop-on-error</code> option will cause <code>ltlcross</code> to abort on the
first detected error.  This include failure to start some translator,
read its output, or failure to passe the sanity checks.  Timeouts are
allowed unless <code>--fail-on-time</code> is also given.
</p>

<p>
One use for this option is when <code>ltlcross</code> is used in combination with
<code>randltl</code> to check translators on an infinite stream of formulas.
</p>

<p>
For instance the following will cross-compare <code>ltl2tgba</code> against
<code>ltl3ba</code> until it finds an error, or your interrupt the command, or it
runs out of memory (the hash tables used by <code>randltl</code> and <code>ltlcross</code>
to remove duplicate formulas will keep growing).
</p>

<div class="org-src-container">

<pre class="src src-sh">randltl -n -1 --tree-size 10..25 a b c | ltlcross --stop-on-error <span class="org-string">'ltl2tgba --lbtt %f &gt;%O'</span> <span class="org-string">'ltl3ba -f %s &gt;%O'</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2"><code>--save-bogus=FILENAME</code></h3>
<div class="outline-text-3" id="text-5-2">
<p>
The <code>--save-bogus=FILENAME</code> will save any formula for which an error
was detected (either some translation failed, or some problem was
detected using the resulting automata) in <code>FILENAME</code>.  Again, timeouts
are not considered to be errors and therefore not reported in this
file, unless <code>--fail-on-timeout</code> is given.
</p>

<p>
The main use for this feature is in conjunction with <code>randltl</code>'s
generation of random formulas.  For instance the following command
will run the translators on an infinite number of formulas, saving
any problematic formula in <code>bugs.ltl</code>.
</p>

<div class="org-src-container">

<pre class="src src-sh">randltl -n -1 --tree-size 10..25 a b c | ltlcross --save-bogus=bugs.ltl <span class="org-string">'ltl2tgba --lbtt %f &gt;%O'</span> <span class="org-string">'ltl3ba -f %s &gt;%O'</span>
</pre>
</div>

<p>
You can periodically check the contents of <code>bugs.ltl</code>, and then run
<code>ltlcross</code> only on those formulas to look at the problems:
</p>

<div class="org-src-container">

<pre class="src src-sh">ltlcross -F bugs.ltl <span class="org-string">'ltl2tgba --lbtt %f &gt;%O'</span> <span class="org-string">'ltl3ba -f %s &gt;%O'</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-3" class="outline-3">
<h3 id="sec-5-3"><code>--grind=FILENAME</code></h3>
<div class="outline-text-3" id="text-5-3">
<p>
This option tells <code>ltlcross</code> that, when a problem is detected, it
should try to find a smaller formula that still exhibits the
problem.
</p>

<p>
Here is the procedure used:
</p>
<ul class="org-ul">
<li>internally list the mutations of the bogus formula and sort
them by length (as <a href="ltlgrind.html"><code>ltlgrind --sort</code></a> would do)
</li>
<li>process every mutation until one is found that exhibit the bug
</li>
<li>repeat the process with this new formula, and again until a formula
is found for which no mutation exhibit the bug
</li>
<li>output that last formula in <code>FILENAME</code>
</li>
</ul>

<p>
If <code>--save-bogus=OTHERFILENAME</code> is provided, every bogus formula found
during the process will be saved in <code>OTHERFILENAME</code>.
</p>

<p>
Example:
</p>
<div class="org-src-container">

<pre class="src src-sh">ltlcross -f <span class="org-string">'(G!b &amp; (!c | F!a)) | (c &amp; Ga &amp; Fb)'</span> <span class="org-string">"modella %L %O"</span> <span class="org-sh-escaped-newline">\</span>
  --save-bogus=bogus <span class="org-sh-escaped-newline">\</span>
  --grind=bogus-grind
</pre>
</div>
<pre class="example">
| &amp; G ! p0 | ! p1 F ! p2 &amp; &amp; p1 G p2 F p0
Running [P0]: modella 'lcr-i0-jQHqRA' 'lcr-o0-xX0E6e'
Running [N0]: modella 'lcr-i0-LsgemT' 'lcr-o0-bEMNBx'
Performing sanity checks and gathering statistics...
error: P0*N0 is nonempty; both automata accept the infinite word:
       cycle{!p0 &amp; !p1}

Trying to find a bogus mutation of (G!b &amp; (!c | F!a)) | (c &amp; Ga &amp; Fb)...
Mutation 1/22: &amp; &amp; p0 G p1 F p2
Running [P0]: modella 'lcr-i1-zrvATb' 'lcr-o0-VCKnbQ'
Running [N0]: modella 'lcr-i1-km5ltu' 'lcr-o0-UVEkL8'
Performing sanity checks and gathering statistics...

Mutation 2/22: &amp; G ! p0 | ! p1 F ! p2
Running [P0]: modella 'lcr-i2-gOw93M' 'lcr-o0-ZESYmr'
Running [N0]: modella 'lcr-i2-cY8XF5' 'lcr-o0-4VCXYJ'
Performing sanity checks and gathering statistics...

Mutation 3/22: | G ! p0 &amp; &amp; p1 G p2 F p0
Running [P0]: modella 'lcr-i3-p3jKio' 'lcr-o0-lxuxC2'
Running [N0]: modella 'lcr-i3-SpUvWG' 'lcr-o0-Wpxugl'
Performing sanity checks and gathering statistics...
error: P0*N0 is nonempty; both automata accept the infinite word:
       cycle{!p0 &amp; !p1}

Trying to find a bogus mutation of G!b | (c &amp; Ga &amp; Fb)...
Mutation 1/16: t
Running [P0]: modella 'lcr-i4-lVBXBZ' 'lcr-o0-mPurXD'
Running [N0]: modella 'lcr-i4-rxU4ii' 'lcr-o0-3nCIEW'
Performing sanity checks and gathering statistics...

Mutation 2/16: G ! p0
Running [P0]: modella 'lcr-i5-ecsD0A' 'lcr-o0-JaZymf'
Running [N0]: modella 'lcr-i5-d77CIT' 'lcr-o0-lazH4x'
Performing sanity checks and gathering statistics...

Mutation 3/16: &amp; &amp; p0 G p1 F p2
warning: This formula or its negation has already been checked.
         Use --allow-dups if it should not be ignored.

Mutation 4/16: | G ! p0 &amp; p1 F p0
Running [P0]: modella 'lcr-i6-Su7jrc' 'lcr-o0-aYZWNQ'
Running [N0]: modella 'lcr-i6-SGJJav' 'lcr-o0-bMLwx9'
Performing sanity checks and gathering statistics...
error: P0*N0 is nonempty; both automata accept the infinite word:
       cycle{!p0 &amp; !p1}

Trying to find a bogus mutation of G!b | (c &amp; Fb)...
Mutation 1/10: t
warning: This formula or its negation has already been checked.
         Use --allow-dups if it should not be ignored.

Mutation 2/10: G ! p0
warning: This formula or its negation has already been checked.
         Use --allow-dups if it should not be ignored.

Mutation 3/10: &amp; p0 F p1
Running [P0]: modella 'lcr-i7-4OxfVN' 'lcr-o0-HzMYis'
Running [N0]: modella 'lcr-i7-gM4RG6' 'lcr-o0-t7AL4K'
Performing sanity checks and gathering statistics...

Mutation 4/10: | p0 G ! p1
Running [P0]: modella 'lcr-i8-Pgkltp' 'lcr-o0-0VKVR3'
Running [N0]: modella 'lcr-i8-Nm8EgI' 'lcr-o0-yMNoFm'
Performing sanity checks and gathering statistics...

Mutation 5/10: | G ! p0 F p0
Running [P0]: modella 'lcr-i9-CxKP40' 'lcr-o0-IEahuF'
Running [N0]: modella 'lcr-i9-sZgRTj' 'lcr-o0-aIArjY'
Performing sanity checks and gathering statistics...

Mutation 6/10: | ! p0 &amp; p1 F p0
Running [P0]: modella 'lcr-i10-2CgmJC' 'lcr-o0-tBqh9g'
Running [N0]: modella 'lcr-i10-s6bmzV' 'lcr-o0-kyfrZz'
Performing sanity checks and gathering statistics...

Mutation 7/10: | &amp; p1 F p0 G p0
Running [P0]: modella 'lcr-i11-Ge7Vpe' 'lcr-o0-QxGrQS'
Running [N0]: modella 'lcr-i11-Aga6gx' 'lcr-o0-QfUKHb'
Performing sanity checks and gathering statistics...

Mutation 8/10: | &amp; p0 p1 G ! p0
Running [P0]: modella 'lcr-i12-hWul9P' 'lcr-o0-NGLWAu'
Running [N0]: modella 'lcr-i12-UDEG28' 'lcr-o0-u6OquN'
Performing sanity checks and gathering statistics...

Mutation 9/10: | G ! p0 &amp; p0 F p0
Running [P0]: modella 'lcr-i13-O7dRWr' 'lcr-o0-YEAip6'
Running [N0]: modella 'lcr-i13-U59SRK' 'lcr-o0-CDWtkp'
Performing sanity checks and gathering statistics...
error: P0*N0 is nonempty; both automata accept the infinite word:
       cycle{!p0}

Trying to find a bogus mutation of G!c | (c &amp; Fc)...
Mutation 1/7: t
warning: This formula or its negation has already been checked.
         Use --allow-dups if it should not be ignored.

Mutation 2/7: G ! p0
warning: This formula or its negation has already been checked.
         Use --allow-dups if it should not be ignored.

Mutation 3/7: &amp; p0 F p0
Running [P0]: modella 'lcr-i14-pa2JN3' 'lcr-o0-RHA0gI'
Running [N0]: modella 'lcr-i14-mZqpKm' 'lcr-o0-qWyOd1'
Performing sanity checks and gathering statistics...

Mutation 4/7: | p0 G ! p0
Running [P0]: modella 'lcr-i15-uxfEHF' 'lcr-o0-R2Dubk'
Running [N0]: modella 'lcr-i15-wf2tFY' 'lcr-o0-3EHt9C'
Performing sanity checks and gathering statistics...

Mutation 5/7: | G ! p0 F p0
warning: This formula or its negation has already been checked.
         Use --allow-dups if it should not be ignored.

Mutation 6/7: | ! p0 &amp; p0 F p0
Running [P0]: modella 'lcr-i16-km46Dh' 'lcr-o0-KKTK8V'
Running [N0]: modella 'lcr-i16-nXoxDA' 'lcr-o0-bWbk8e'
Performing sanity checks and gathering statistics...

Mutation 7/7: | G p0 &amp; p0 F p0
Running [P0]: modella 'lcr-i17-DgOqDT' 'lcr-o0-gx4x8x'
Running [N0]: modella 'lcr-i17-K1AODc' 'lcr-o0-9vk58Q'
Performing sanity checks and gathering statistics...

Smallest bogus mutation found for (G!b &amp; (!c | F!a)) | (c &amp; Ga &amp; Fb) is G!c | (c &amp; Fc).

error: some error was detected during the above runs.
       Check file bogus for problematic formulas.
</pre>

<div class="org-src-container">

<pre class="src src-sh">cat bogus
</pre>
</div>

<pre class="example">
(G!b &amp; (!c | F!a)) | (c &amp; Ga &amp; Fb)
G!b | (c &amp; Ga &amp; Fb)
G!b | (c &amp; Fb)
G!c | (c &amp; Fc)
</pre>

<div class="org-src-container">

<pre class="src src-sh">cat bogus-grind
</pre>
</div>

<pre class="example">
G!c | (c &amp; Fc)
</pre>
</div>
</div>

<div id="outline-container-sec-5-4" class="outline-3">
<h3 id="sec-5-4"><code>--no-check</code></h3>
<div class="outline-text-3" id="text-5-4">
<p>
The <code>--no-check</code> option disables all sanity checks, and only use the supplied
formulas in their positive form.
</p>

<p>
When checks are enabled, the negated formulas are intermixed with the
positives ones in the results.  Therefore the <code>--no-check</code> option can
be used to gather statistics about a specific set of formulas.
</p>
</div>
</div>
<div id="outline-container-verbose" class="outline-3">
<h3 id="verbose"><a id="sec-5-5" name="sec-5-5"></a><code>--verbose</code></h3>
<div class="outline-text-3" id="text-verbose">

<p>
The verbose option can be useful to troubleshoot problems or simply
follow the list of transformations and tests performed by <code>ltlcross</code>.
</p>

<p>
For instance here is what happens if we try to cross check <code>ltl2tgba</code>
and <code>ltl3ba -H1</code> on the formula <code>FGa</code>.  Note that <code>ltl2tgba</code> will
produce transition-based generalized BÃ¼chi automata, while <code>ltl3ba
-H1</code> produces co-BÃ¼chi alternating automata.
</p>

<div class="org-src-container">

<pre class="src src-sh">ltlcross -f <span class="org-string">'FGa'</span> ltl2tgba <span class="org-string">'ltl3ba -H1'</span> --determinize --verbose
</pre>
</div>

<pre class="example">
F(G(a))
Running [P0]: ltl2tgba -H 'F(G(a))'&gt;'lcr-o0-LUNQtM'
Running [P1]: ltl3ba -H1 -f '&lt;&gt;([](a))'&gt;'lcr-o1-9wCDjr'
Running [N0]: ltl2tgba -H '!(F(G(a)))'&gt;'lcr-o0-Agu095'
Running [N1]: ltl3ba -H1 -f '!(&lt;&gt;([](a)))'&gt;'lcr-o1-frBn2K'
info: collected automata:
info:   P0	(2 st.,3 ed.,1 sets)
info:   N0	(1 st.,2 ed.,1 sets) deterministic complete
info:   P1	(2 st.,3 ed.,1 sets)
info:   N1	(3 st.,5 ed.,1 sets) univ-edges complete
Performing sanity checks and gathering statistics...
info: getting rid of universal edges...
info:   N1	(3 st.,5 ed.,1 sets) -&gt; (2 st.,4 ed.,1 sets)
info: complementing non-deterministic automata via determinization...
info:   P0	(2 st.,3 ed.,1 sets) -&gt; (2 st.,4 ed.,2 sets)	Comp(P0)
info:   P1	(2 st.,3 ed.,1 sets) -&gt; (2 st.,4 ed.,2 sets)	Comp(P1)
info: getting rid of any Fin acceptance...
info:	Comp(P0)	(2 st.,4 ed.,2 sets) -&gt; (2 st.,4 ed.,1 sets)
info:	Comp(N0)	(1 st.,2 ed.,1 sets) -&gt; (2 st.,3 ed.,1 sets)
info:	     P1 	(2 st.,3 ed.,1 sets) -&gt; (2 st.,3 ed.,1 sets)
info:	Comp(P1)	(2 st.,4 ed.,2 sets) -&gt; (2 st.,4 ed.,1 sets)
info:	Comp(N1)	(2 st.,4 ed.,1 sets) -&gt; (3 st.,6 ed.,1 sets)
info: check_empty P0*N0
info: check_empty Comp(N0)*Comp(P0)
info: check_empty P0*N1
info: check_empty P1*N0
info: check_empty P1*N1
info: check_empty Comp(N1)*Comp(P1)

No problem detected.
</pre>

<p>
First <code>FGa</code> and its negations <code>!FGa</code> are translated with the two
tools, resulting in four automata: two positive automata <code>P0</code> and <code>P1</code>
for <code>FGa</code>, and two negative automata <code>N0</code> and <code>N1</code>.
</p>

<p>
Some basic information about the collected automata are displayed.
For instance we can see that although <code>ltl3ba -H1</code> outputs co-BÃ¼chi
alternating automata, only automaton <code>N1</code> uses universal edges: the
automaton <code>P1</code> can be used like a non-alternating co-BÃ¼chi automaton.
</p>

<p>
<code>ltlcross</code> then proceeds to transform alternating automata (only weak
alternating automata are supported) into non-alternating automata.
Here only <code>N1</code> needs this transformation.
</p>

<p>
Then <code>ltlcross</code> computes the complement of these four
automata.  Since <code>P0</code> and <code>P1</code> are nondeterministic and the
<code>--determinize</code> option was given, a first pass determinize and
complete these two automata, creating <code>Comp(P0)</code> and <code>Comp(P1)</code>.
</p>

<p>
Apparently <code>N0</code> and <code>N1</code> are already deterministic, so their
complement could be obtained by just complementing their acceptance
condition (this is not written &#x2013; we only deduce so because they do
not appear in the list of automata that had to be determinized).
</p>

<p>
Now that <code>ltlcross</code> has four complemented automata, it has to make
sure they use only <code>Inf</code> acceptance because that is what our emptiness
check procedure can handle.  So there is a new pass over all automata,
rewriting them to get rid of any <code>Fin</code> acceptance.
</p>

<p>
After this preparatory work, it is time for actually comparing these
automata.  Together, the tests <code>P0*N0</code> and <code>Comp(N0)*Comp(P0)</code> ensure
that the automaton <code>N0</code> is really the complement of <code>P0</code>.  Similarly
<code>P1*N1</code> and <code>Comp(N1)*Comp(P1)</code> ensure that <code>N1</code> is the complement of
<code>P1</code>.  Finally <code>P0*N1</code> and <code>P1*N0</code> ensure that <code>P1</code> is equivalent to
<code>P0</code> and <code>N1</code> is equivalent to <code>N0</code>.
</p>

<p>
Note that if we had not used the <code>--determinize</code> option, the procedure
would look slightly more complex:
</p>

<div class="org-src-container">

<pre class="src src-sh">ltlcross -f <span class="org-string">'FGa'</span> ltl2tgba <span class="org-string">'ltl3ba -H1'</span> --verbose
</pre>
</div>

<pre class="example">
F(G(a))
Running [P0]: ltl2tgba -H 'F(G(a))'&gt;'lcr-o0-QvRMjU'
Running [P1]: ltl3ba -H1 -f '&lt;&gt;([](a))'&gt;'lcr-o1-TnH6mz'
Running [N0]: ltl2tgba -H '!(F(G(a)))'&gt;'lcr-o0-f1dZqe'
Running [N1]: ltl3ba -H1 -f '!(&lt;&gt;([](a)))'&gt;'lcr-o1-XmAZwT'
info: collected automata:
info:   P0	(2 st.,3 ed.,1 sets)
info:   N0	(1 st.,2 ed.,1 sets) deterministic complete
info:   P1	(2 st.,3 ed.,1 sets)
info:   N1	(3 st.,5 ed.,1 sets) univ-edges complete
Performing sanity checks and gathering statistics...
info: getting rid of universal edges...
info:   N1	(3 st.,5 ed.,1 sets) -&gt; (2 st.,4 ed.,1 sets)
info: getting rid of any Fin acceptance...
info:	Comp(N0)	(1 st.,2 ed.,1 sets) -&gt; (2 st.,3 ed.,1 sets)
info:	     P1 	(2 st.,3 ed.,1 sets) -&gt; (2 st.,3 ed.,1 sets)
info:	Comp(N1)	(2 st.,4 ed.,1 sets) -&gt; (3 st.,6 ed.,1 sets)
info: check_empty P0*N0
info: check_empty P0*N1
info: check_empty Comp(N0)*N1
info: check_empty P1*N0
info: check_empty Comp(N1)*N0
info: check_empty P1*N1
info: building state-space #0/1 of 200 states with seed 0
info: state-space has 4136 edges
info: building product between state-space and P0 (2 st., 3 ed.)
info:   product has 400 st., 8298 ed.
info:               2 SCCs
info: building product between state-space and P1 (2 st., 3 ed.)
info:   product has 400 st., 8298 ed.
info:               2 SCCs
info: building product between state-space and N0 (1 st., 2 ed.)
info:   product has 200 st., 4136 ed.
info:               1 SCCs
info: building product between state-space and N1 (2 st., 4 ed.)
info:   product has 400 st., 8272 ed.
info:               1 SCCs
info: cross_check {P0,P1}, state-space #0/1
info: cross_check {N0,N1}, state-space #0/1
info: consistency_check (P0,N0), state-space #0/1
info: consistency_check (P1,N1), state-space #0/1

No problem detected.
</pre>

<p>
In this case, <code>ltlcross</code> does not have any complement automaton for
<code>P0</code> and <code>P1</code>, so it cannot make sure that <code>P0</code> and <code>P1</code> are
equivalent.  If we imagine for instance that <code>P0</code> has an empty
language, we can see that the six <code>check_empty</code> tests would still
succeed.
</p>

<p>
So <code>ltlcross</code> builds a random state-space of 200 states, synchronize
it with the four automata, and then performs additional checks
(<code>cross_check</code> and <code>consistency_check</code>) on these products as described
<a href="#checks">earlier</a>.  While these additional checks do not make a proof that <code>P0</code>
and <code>P1</code> are equivalent, they can catch some problems, and would
easily catch the case of an automaton with an empty language by
mistake.
</p>

<p>
Here is the same example, if we declare that <code>ltl3ba</code> is a reference
implementation that should not be checked, and we just want to check
the output of <code>ltl2tgba</code> against this reference.  See how the number
of tests performed has been reduced.
</p>

<div class="org-src-container">

<pre class="src src-sh">ltlcross -f <span class="org-string">'FGa'</span> ltl2tgba --reference <span class="org-string">'ltl3ba -H1'</span> --verbose
</pre>
</div>

<pre class="example">
F(G(a))
Running [P0]: ltl3ba -H1 -f '&lt;&gt;([](a))'&gt;'lcr-o0-dfjt8Q'
Running [P1]: ltl2tgba -H 'F(G(a))'&gt;'lcr-o1-Py6apw'
Running [N0]: ltl3ba -H1 -f '!(&lt;&gt;([](a)))'&gt;'lcr-o0-6RiWHb'
Running [N1]: ltl2tgba -H '!(F(G(a)))'&gt;'lcr-o1-SWJe1Q'
info: collected automata:
info:   P0	(2 st.,3 ed.,1 sets)
info:   N0	(3 st.,5 ed.,1 sets) univ-edges complete
info:   P1	(2 st.,3 ed.,1 sets)
info:   N1	(1 st.,2 ed.,1 sets) deterministic complete
Performing sanity checks and gathering statistics...
info: getting rid of universal edges...
info:   N0	(3 st.,5 ed.,1 sets) -&gt; (2 st.,4 ed.,1 sets)
info: getting rid of any Fin acceptance...
info:	     P0 	(2 st.,3 ed.,1 sets) -&gt; (2 st.,3 ed.,1 sets)
info:	Comp(N1)	(1 st.,2 ed.,1 sets) -&gt; (2 st.,3 ed.,1 sets)
info: P0 and N0 assumed correct and used as references
info: check_empty P0*N1
info: check_empty P1*N0
info: check_empty Comp(N1)*N0
info: check_empty P1*N1
info: building state-space #0/1 of 200 states with seed 0
info: state-space has 4136 edges
info: building product between state-space and P0 (2 st., 3 ed.)
info:   product has 400 st., 8298 ed.
info:               2 SCCs
info: building product between state-space and P1 (2 st., 3 ed.)
info:   product has 400 st., 8298 ed.
info:               2 SCCs
info: building product between state-space and N0 (2 st., 4 ed.)
info:   product has 400 st., 8272 ed.
info:               1 SCCs
info: building product between state-space and N1 (1 st., 2 ed.)
info:   product has 200 st., 4136 ed.
info:               1 SCCs
info: cross_check {P0,P1}, state-space #0/1
info: cross_check {N0,N1}, state-space #0/1
info: consistency_check (P1,N1), state-space #0/1

No problem detected.
</pre>
</div>
</div>
</div>
</div>
</body>
</html>
