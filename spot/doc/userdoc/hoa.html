<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Support for the Hanoi Omega Automata (HOA) Format</title>
<!-- 2018-01-20 Sat 14:20 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="root" />
<meta  name="description" content="Details about support of the HOA format in Spot"
 />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" type="text/css" href="spot.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/javascript" src="http://orgmode.org/mathjax/MathJax.js"></script>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
    MathJax.Hub.Config({
        // Only one of the two following lines, depending on user settings
        // First allows browser-native MathML display, second forces HTML/CSS
        //  config: ["MMLorHTML.js"], jax: ["input/TeX"],
            jax: ["input/TeX", "output/HTML-CSS"],
        extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js",
                     "TeX/noUndefined.js"],
        tex2jax: {
            inlineMath: [ ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"], ["\\begin{displaymath}","\\end{displaymath}"] ],
            skipTags: ["script","noscript","style","textarea","pre","code"],
            ignoreClass: "tex2jax_ignore",
            processEscapes: false,
            processEnvironments: true,
            preview: "TeX"
        },
        showProcessingMessages: true,
        displayAlign: "center",
        displayIndent: "2em",

        "HTML-CSS": {
             scale: 100,
             availableFonts: ["STIX","TeX"],
             preferredFont: "TeX",
             webFont: "TeX",
             imageFont: "TeX",
             showMathMenu: true,
        },
        MMLorHTML: {
             prefer: {
                 MSIE:    "MML",
                 Firefox: "MML",
                 Opera:   "HTML",
                 other:   "HTML"
             }
        }
    });
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="tools.html"> UP </a>
 |
 <a accesskey="H" href="index.html"> HOME </a>
</div><div id="content">
<h1 class="title">Support for the Hanoi Omega Automata (HOA) Format</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Format, files, and TωA</a></li>
<li><a href="#restrictions">Features of the HOA format with no or limited support in Spot</a></li>
<li><a href="#sec-3">Internal representations of some features</a>
<ul>
<li><a href="#sec-3-1">State-based vs. transition-based acceptance</a></li>
<li><a href="#sec-3-2">Generic acceptance</a></li>
<li><a href="#sec-3-3">State-based vs. transition-based labels</a></li>
<li><a href="#property-bits">Property flags</a></li>
<li><a href="#named-properties">Named properties</a></li>
</ul>
</li>
<li><a href="#sec-4">Streaming support</a></li>
<li><a href="#sec-5">Error recovery</a></li>
<li><a href="#sec-6">Checked properties</a></li>
<li><a href="#extensions">Extensions</a></li>
</ul>
</div>
</div>
<p>
The <a href="http://adl.github.io/hoaf/">Hanoi Omega-Automa format</a> is a textual representation of
ω-automata labeled by Boolean formulas over a set of atomic
propositions, and using an arbitrary acceptance condition. The
typical acceptances conditions like Büchi, generalized-Büchi,
co-Büchi, Rabin, Streett, parity, &#x2026; are all supported, but the main
advantage of this format is that any arbitrary acceptance condition
can be defined.  The HOA format has support for many features such as
non-determinism, alternation, multiple initial states, transition or
state-based acceptance, named states, and a range of property flags
making it possible to store additional information about the
automaton.
</p>

<p>
The HOA format is already supported in <a href="http://adl.github.io/hoaf/support.html">several tools</a>.  The goal of
this page is to detail the support of this format in Spot.  It contains
some information that are useful to better understand the behavior
of the tools distributed by Spot, and it also look at some lower-level,
discussing details that are interesting when programming with Spot.
</p>

<p>
Spot can read files written using either version 1 or version 1.1 of
the HOA format.  It currently outputs version 1 by default, but
version 1.1 can be requested from the command-line using option
<code>-H1.1</code>.  Future version of Spot are likely to switch to version 1.1
of HOA by default, so version 1 can already be requested explicitly
using <code>-H1</code>.
</p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Format, files, and TωA</h2>
<div class="outline-text-2" id="text-1">
<p>
Some note about the abbreviation first.  We usually write "HOA format"
or occasionally HOAF to denote the format (as a specification), and
HOA or "HOA file" to denote an automaton in that format.  In most
examples involving HOA files, we use <code>*.hoa</code> as a filename extension
(even if the actual extension does not matter).
</p>

<p>
When an HOA file is loaded by Spot, it is stored into the
data-structure used by Spot to represent ω-Automata.  This structure
is called Transition-based ω-Automaton, henceforth abbreviated TωA.
Such a TωA can be saved back as an HOA file.  If you run a command
such as <code>autfilt input.hoa &gt;output.hoa</code> this is exactly what
happens: the file <code>input.hoa</code> is parsed to create a TωA, and this TωA
is then printed in the HOA format into <code>output.hoa</code>.
</p>

<p>
Since the TωA structure is not a perfect one-to-one representation of
the HOA format, the output may not be exactly the same as the input.
</p>
</div>
</div>

<div id="outline-container-restrictions" class="outline-2">
<h2 id="restrictions"><a id="sec-2" name="sec-2"></a>Features of the HOA format with no or limited support in Spot</h2>
<div class="outline-text-2" id="text-restrictions">

<ul class="org-ul">
<li>Automata using explicit alphabet (introduced in version 1.1 of the
format via <code>Alphabet:</code>) are not supported.
</li>

<li>The maximum number of acceptance sets used is (currently) limited
to 32.

<p>
This limit is not very hard to increase in the source code,
however we want to keep it until it becomes an actual problem.  So
please report to us if you suffer from it.  In the past, this
limitation has forced us to improve some of our algorithms to be
less wasteful and not introduce useless acceptance sets.
</p>
</li>

<li>Multiple (or missing) initial states are emulated.

<p>
The internal TωA representation used by Spot supports only a single
initial state.  When an HOA with multiple initial states is read, it
is transformed into an equivalent TωA by merging the initial states
into a single one.  The merged state can either be one of the
original initial states (if one of those has no incoming edge) or a
new state introduced for that purpose.
</p>

<p>
Similarly, when an automaton with no initial state is loaded (this
includes the case where the automaton has no state), a disconnected
initial state is added.  As a consequence, Spot's HOA output always
contains at least one state, even when the input had no state.
</p>
</li>

<li><code>Fin(!x)</code> and <code>Inf(!x)</code> are rewritten away.

<p>
Internally Spot only deals with acceptance conditions involving the
primitives <code>Fin(x)</code> or <code>Inf(x)</code>.  When the parser encounters the
variants <code>Fin(!x)</code> or <code>Inf(!x)</code>, it automatically complements the
set <code>x</code> so that the resulting acceptance uses only <code>Fin(x)</code> and
<code>Inf(x)</code>.  For instance <code>Fin(0)&amp;Inf(!1)</code> gets rewritten into
<code>Fin(0)&amp;Inf(1)</code> and the membership of all transitions to the set <code>1</code>
is reversed.
</p>

<p>
If <code>x</code> was already used without complementation in another
primitive, then a new set has to be created.  For instance the
acceptance <code>Inf(0)&amp;Inf(!0)</code> can only be fixed by adding a new set,
<code>1</code>, that stores the complement of set <code>0</code>, and using
<code>Inf(0)&amp;Inf(1)</code>.
</p>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">Internal representations of some features</h2>
<div class="outline-text-2" id="text-3">
<p>
In this section we discuss features of the format that are fully
supported, but in a way that so people could find unexpected.  These
design choices do not affect the semantics of the HOA format in any
way.
</p>
</div>

<div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">State-based vs. transition-based acceptance</h3>
<div class="outline-text-3" id="text-3-1">
<p>
A Transition-based ω-Automaton (TωA), as its name implies, uses
transition-based acceptance sets.  Each edge is stored as a
quadruplet \((s,d,\ell,F)\) where \(s\) and \(d\) are the source and
destination state numbers, \(\ell\) is a Binary Decision Diagram (BDD)
representing the Boolean function labeling the edge, and \(F\) is a
bit-vector representing the membership of the transition to each
declared acceptance set.
</p>

<p>
States are just numbers, and may not belong to any accepting set.
When reading a HOA file that use state-based acceptance (or even
a mix of state-based and transitions-based acceptance), all the
acceptance are pushed onto the outgoing transitions.
</p>

<p>
So an automaton represented as an HOA file with this transition
structure:
</p>

<div class="org-src-container">

<pre class="src src-hoa"><span class="org-comment">/* state-based acceptance */</span>
<span class="org-hoa-header-uppercase">State:</span> 0 {<span class="org-hoa-acceptance-set">0 1</span>}
[<span class="org-hoa-ap-number">0</span>&amp;!<span class="org-hoa-ap-number">1</span>] 0
[<span class="org-hoa-ap-number">0</span>&amp;<span class="org-hoa-ap-number">1</span>] 1
[!<span class="org-hoa-ap-number">0</span>] 2
<span class="org-comment">/* mixed state- and transition-based acceptance */</span>
<span class="org-hoa-header-uppercase">State:</span> 1 {<span class="org-hoa-acceptance-set">0</span>}
[<span class="org-hoa-ap-number">0</span>] 1 {<span class="org-hoa-acceptance-set">1</span>}
[<span class="org-hoa-ap-number">0</span>&amp;<span class="org-hoa-ap-number">1</span>] 2
<span class="org-comment">/* transition-based acceptance */</span>
<span class="org-hoa-header-uppercase">State:</span> 2
[!<span class="org-hoa-ap-number">0</span>] 1 {<span class="org-hoa-acceptance-set">0</span>}
[<span class="org-hoa-ap-number">0</span>]  2 {<span class="org-hoa-acceptance-set">1</span>}
</pre>
</div>

<p>
will always be stored as a TωA with this transition structure:
</p>

<div class="org-src-container">

<pre class="src src-hoa"><span class="org-hoa-header-uppercase">State:</span> 0
[<span class="org-hoa-ap-number">0</span>&amp;!<span class="org-hoa-ap-number">1</span>] 0 {<span class="org-hoa-acceptance-set">0 1</span>}
[<span class="org-hoa-ap-number">0</span>&amp;<span class="org-hoa-ap-number">1</span>] 1 {<span class="org-hoa-acceptance-set">0 1</span>}
[!<span class="org-hoa-ap-number">0</span>] 2 {<span class="org-hoa-acceptance-set">0 1</span>}
<span class="org-hoa-header-uppercase">State:</span> 1
[<span class="org-hoa-ap-number">0</span>] 1 {<span class="org-hoa-acceptance-set">0 1</span>}
[<span class="org-hoa-ap-number">0</span>&amp;<span class="org-hoa-ap-number">1</span>] 2 {<span class="org-hoa-acceptance-set">0</span>}
<span class="org-hoa-header-uppercase">State:</span> 2
[!<span class="org-hoa-ap-number">0</span>] 1 {<span class="org-hoa-acceptance-set">0</span>}
[<span class="org-hoa-ap-number">0</span>] 2 {<span class="org-hoa-acceptance-set">1</span>}
</pre>
</div>

<p>
Even if an input HOA file uses only state-based acceptance, Spot
internally stores it using transition-based acceptance.  However in
that case the TωA will have a property flag indicating that it actually
represents an automaton with the "state-based acceptance" property:
this implies that transitions leaving one state all belong to the same
acceptance sets.  A couple of algorithms in Spot checks for this
property, and enable specialized treatments of state-based automata.
</p>

<p>
Furthermore, even if an automaton does not have the "state-based
acceptance" property flag set, the HOA output routine may detect that
the automaton satisfies this property.  In that case, it outputs the
automaton with state-based acceptance.
</p>

<p>
For instance in the following automaton, the outgoing transitions of
each states belong to the same sets:
</p>

<div class="org-src-container">

<pre class="src src-sh" id="state-based-example">cat &gt;sba.hoa &lt;&lt;EOF_HOA
<span class="org-sh-heredoc">HOA: v1</span>
<span class="org-sh-heredoc">States: 3</span>
<span class="org-sh-heredoc">Start: 0</span>
<span class="org-sh-heredoc">AP: 2 "a" "b"</span>
<span class="org-sh-heredoc">Acceptance: 2 Inf(0)&amp;Inf(1)</span>
<span class="org-sh-heredoc">--BODY--</span>
<span class="org-sh-heredoc">State: 0 {0}</span>
<span class="org-sh-heredoc">[0&amp;!1] 0</span>
<span class="org-sh-heredoc">[0&amp;1] 1</span>
<span class="org-sh-heredoc">[!0] 2</span>
<span class="org-sh-heredoc">State: 1</span>
<span class="org-sh-heredoc">[0] 1 {1}</span>
<span class="org-sh-heredoc">[0&amp;1] 2 {1}</span>
<span class="org-sh-heredoc">State: 2</span>
<span class="org-sh-heredoc">[!0] 1 {0 1}</span>
<span class="org-sh-heredoc">[0]  2 {0 1}</span>
<span class="org-sh-heredoc">--END--</span>
<span class="org-sh-heredoc">EOF_HOA</span>
autfilt sba.hoa
</pre>
</div>

<p>
so the HOA output of <code>autfilt</code> automatically uses state-based acceptance:
</p>

<div class="org-src-container">

<pre class="src src-hoa"><span class="org-hoa-header-uppercase">HOA:</span> v1
<span class="org-hoa-header-uppercase">States:</span> 3
<span class="org-hoa-header-uppercase">Start:</span> 0
<span class="org-hoa-header-uppercase">AP:</span> 2 <span class="org-string">"a"</span> <span class="org-string">"b"</span>
<span class="org-hoa-header-lowercase">acc-name:</span> generalized-Buchi 2
<span class="org-hoa-header-uppercase">Acceptance:</span> 2 <span class="org-hoa-builtin">Inf</span>(<span class="org-hoa-acceptance-set">0</span>)&amp;<span class="org-hoa-builtin">Inf</span>(<span class="org-hoa-acceptance-set">1</span>)
<span class="org-hoa-header-lowercase">properties:</span> trans-labels explicit-labels state-acc
<span class="org-hoa-keyword">--BODY--</span>
<span class="org-hoa-header-uppercase">State:</span> 0 {<span class="org-hoa-acceptance-set">0</span>}
[<span class="org-hoa-ap-number">0</span>&amp;!<span class="org-hoa-ap-number">1</span>] 0
[<span class="org-hoa-ap-number">0</span>&amp;<span class="org-hoa-ap-number">1</span>] 1
[!<span class="org-hoa-ap-number">0</span>] 2
<span class="org-hoa-header-uppercase">State:</span> 1 {<span class="org-hoa-acceptance-set">1</span>}
[<span class="org-hoa-ap-number">0</span>] 1
[<span class="org-hoa-ap-number">0</span>&amp;<span class="org-hoa-ap-number">1</span>] 2
<span class="org-hoa-header-uppercase">State:</span> 2 {<span class="org-hoa-acceptance-set">0 1</span>}
[!<span class="org-hoa-ap-number">0</span>] 1
[<span class="org-hoa-ap-number">0</span>] 2
<span class="org-hoa-keyword">--END--</span>
</pre>
</div>

<p>
The rational for this automatic switch to state-based acceptance is as follows:
</p>
<ul class="org-ul">
<li>Tools that support transition-based acceptance can easily see
state-based acceptance as syntactic sugar, so they should be
able to process state-based or transition-based acceptance
indifferently.
</li>
<li>Tools that support only state-based acceptance, cannot easily
process automata with transition-based acceptance.  So by using
state-based acceptance whenever possible, we are making these
automata compatible with a larger number of tools.
</li>
<li>Using state-based acceptance is slightly more space efficient,
because there is less redundancy in the output file.
</li>
</ul>

<p>
Nevertheless, should you really insist on having an output with
transition-based acceptance, you can do so by passing the option <code>t</code>
to the HOA printer:
</p>

<div class="org-src-container">

<pre class="src src-sh">autfilt -Ht sba.hoa
</pre>
</div>

<div class="org-src-container">

<pre class="src src-hoa"><span class="org-hoa-header-uppercase">HOA:</span> v1
<span class="org-hoa-header-uppercase">States:</span> 3
<span class="org-hoa-header-uppercase">Start:</span> 0
<span class="org-hoa-header-uppercase">AP:</span> 2 <span class="org-string">"a"</span> <span class="org-string">"b"</span>
<span class="org-hoa-header-lowercase">acc-name:</span> generalized-Buchi 2
<span class="org-hoa-header-uppercase">Acceptance:</span> 2 <span class="org-hoa-builtin">Inf</span>(<span class="org-hoa-acceptance-set">0</span>)&amp;<span class="org-hoa-builtin">Inf</span>(<span class="org-hoa-acceptance-set">1</span>)
<span class="org-hoa-header-lowercase">properties:</span> trans-labels explicit-labels trans-acc
<span class="org-hoa-keyword">--BODY--</span>
<span class="org-hoa-header-uppercase">State:</span> 0
[<span class="org-hoa-ap-number">0</span>&amp;!<span class="org-hoa-ap-number">1</span>] 0 {<span class="org-hoa-acceptance-set">0</span>}
[<span class="org-hoa-ap-number">0</span>&amp;<span class="org-hoa-ap-number">1</span>] 1 {<span class="org-hoa-acceptance-set">0</span>}
[!<span class="org-hoa-ap-number">0</span>] 2 {<span class="org-hoa-acceptance-set">0</span>}
<span class="org-hoa-header-uppercase">State:</span> 1
[<span class="org-hoa-ap-number">0</span>] 1 {<span class="org-hoa-acceptance-set">1</span>}
[<span class="org-hoa-ap-number">0</span>&amp;<span class="org-hoa-ap-number">1</span>] 2 {<span class="org-hoa-acceptance-set">1</span>}
<span class="org-hoa-header-uppercase">State:</span> 2
[!<span class="org-hoa-ap-number">0</span>] 1 {<span class="org-hoa-acceptance-set">0 1</span>}
[<span class="org-hoa-ap-number">0</span>] 2 {<span class="org-hoa-acceptance-set">0 1</span>}
<span class="org-hoa-keyword">--END--</span>
</pre>
</div>

<p>
By default, the output uses either state-based acceptance, or
transition-based acceptance.  However there is no restriction in the
format to prevents mixing the two: if you use <code>-Hm</code>, the decision of
using state or transition-based acceptance will be made for each state
separately.  For instance:
</p>

<div class="org-src-container">

<pre class="src src-sh">ltl2tgba -Hm <span class="org-string">'GFa | Fb'</span>
</pre>
</div>

<div class="org-src-container">

<pre class="src src-hoa"><span class="org-hoa-header-uppercase">HOA:</span> v1
<span class="org-hoa-header-lowercase">name:</span> <span class="org-string">"F(b | GFa)"</span>
<span class="org-hoa-header-uppercase">States:</span> 3
<span class="org-hoa-header-uppercase">Start:</span> 0
<span class="org-hoa-header-uppercase">AP:</span> 2 <span class="org-string">"b"</span> <span class="org-string">"a"</span>
<span class="org-hoa-header-lowercase">acc-name:</span> Buchi
<span class="org-hoa-header-uppercase">Acceptance:</span> 1 <span class="org-hoa-builtin">Inf</span>(<span class="org-hoa-acceptance-set">0</span>)
<span class="org-hoa-header-lowercase">properties:</span> trans-labels explicit-labels complete stutter-invariant
<span class="org-hoa-keyword">--BODY--</span>
<span class="org-hoa-header-uppercase">State:</span> 0
[!<span class="org-hoa-ap-number">0</span>] 0
[<span class="org-hoa-ap-number">0</span>] 1
[!<span class="org-hoa-ap-number">0</span>&amp;<span class="org-hoa-ap-number">1</span>] 2
<span class="org-hoa-header-uppercase">State:</span> 1 {<span class="org-hoa-acceptance-set">0</span>}
[<span class="org-hoa-builtin">t</span>] 1
<span class="org-hoa-header-uppercase">State:</span> 2
[!<span class="org-hoa-ap-number">1</span>] 2
[<span class="org-hoa-ap-number">1</span>] 2 {<span class="org-hoa-acceptance-set">0</span>}
<span class="org-hoa-keyword">--END--</span>
</pre>
</div>


<p>
So far we have discussed transforming state-based acceptance into
transition-based acceptance (this can be seen as removing syntactic
sugar), and representing transition-based acceptance into state-based
acceptance when this is possible (adding syntactic sugar) to do so
without adding states.
</p>

<p>
It is also possible to transform automata with transition-based
acceptance into automata with state-based acceptance, adding states
when necessary.  Most tools have a <code>-S</code> option (or
<code>--state-based-acceptance</code>) for this purpose.  Compare the following
output with the previous one.
</p>

<div class="org-src-container">

<pre class="src src-sh">ltl2tgba -S -Hm <span class="org-string">'GFa | Fb'</span>
</pre>
</div>

<div class="org-src-container">

<pre class="src src-hoa"><span class="org-hoa-header-uppercase">HOA:</span> v1
<span class="org-hoa-header-lowercase">name:</span> <span class="org-string">"F(b | GFa)"</span>
<span class="org-hoa-header-uppercase">States:</span> 4
<span class="org-hoa-header-uppercase">Start:</span> 0
<span class="org-hoa-header-uppercase">AP:</span> 2 <span class="org-string">"b"</span> <span class="org-string">"a"</span>
<span class="org-hoa-header-lowercase">acc-name:</span> Buchi
<span class="org-hoa-header-uppercase">Acceptance:</span> 1 <span class="org-hoa-builtin">Inf</span>(<span class="org-hoa-acceptance-set">0</span>)
<span class="org-hoa-header-lowercase">properties:</span> trans-labels explicit-labels complete stutter-invariant
<span class="org-hoa-keyword">--BODY--</span>
<span class="org-hoa-header-uppercase">State:</span> 0
[!<span class="org-hoa-ap-number">0</span>] 0
[<span class="org-hoa-ap-number">0</span>] 1
[!<span class="org-hoa-ap-number">0</span>&amp;<span class="org-hoa-ap-number">1</span>] 2
<span class="org-hoa-header-uppercase">State:</span> 1 {<span class="org-hoa-acceptance-set">0</span>}
[<span class="org-hoa-builtin">t</span>] 1
<span class="org-hoa-header-uppercase">State:</span> 2 {<span class="org-hoa-acceptance-set">0</span>}
[<span class="org-hoa-ap-number">1</span>] 2
[!<span class="org-hoa-ap-number">1</span>] 3
<span class="org-hoa-header-uppercase">State:</span> 3
[<span class="org-hoa-ap-number">1</span>] 2
[!<span class="org-hoa-ap-number">1</span>] 3
<span class="org-hoa-keyword">--END--</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2">Generic acceptance</h3>
<div class="outline-text-3" id="text-3-2">
<p>
Currently, Spot's parser for HOA ignores the optional <code>acc-name:</code>
line, and only uses the mandatory <code>Acceptance:</code> line.  As explained
earlier, if this line contains primitives of the form <code>Inf(!x)</code> or
<code>Fin(!x)</code> these are rewritten away, because internally Spot only works
with primitives of the form <code>Inf(x)</code> or <code>Fin(x)</code>.  This also means
that Spot will never produce an acceptance condition containing
<code>Fin(!x)</code> or <code>Inf(!x)</code>.
</p>

<p>
Whenever an HOA file is output, Spot attempts to recognize the
acceptance condition to give it a suitable <code>acc-name:</code> (even if Spot
does not use this line, it is useful to tools only deal with one
specific acceptance condition and that do not want to parse the
<code>Acceptance:</code> line).  However the HOA output routine has no idea of
what type of automata you are trying to output: it is only looking at
the acceptance condition and trying to name it as precisely as
possible.  This could be a problem when a given condition accepts
multiple names.
</p>

<p>
For instance according to the <a href="http://adl.github.io/hoaf/#canonical-acceptance-specifications-for-classical-conditions">canonical encodings specified by the HOA
format</a> the condition <code>Inf(0)</code> could be called <code>Buchi</code>, or
<code>generalized-Buchi 1</code>, or (why not?) <code>parity min even 1</code> or <code>parity
max even 1</code>.  Spot will always call this acceptance condition <code>Buchi</code>.
</p>

<p>
Similarly the acceptance condition <code>t</code> is always called <code>all</code> (not
<code>generalized-Buchi 0</code> or <code>Rabin 0</code>, etc.), and while <code>f</code> is always
named <code>none</code>.
</p>


<p>
One of the consequence is that when you run <code>ltl2tgba</code> with its
default settings (which are to produce automata with transition-based
generalized Büchi acceptance) you actually obtain an output that:
</p>
<ul class="org-ul">
<li>has an <code>Acceptance:</code> line that is a conjunction of <code>Inf(x)</code> primitives (or <code>t</code>), because
that is what generalized Büchi is;
</li>
<li>has an <code>acc-name:</code> line that can be either <code>generalized-Buchi n</code>
  (for \(n>1\)) or <code>Buchi</code> (corresponding to \(n=1\)) or <code>all</code> (corresponding to \(n=0\)).
</li>
</ul>

<p>
The use of <code>Buchi</code> or <code>all</code> instead of <code>generalized-Buchi n</code> follow
the same idea as our use of state-based acceptance whenever possible.
By using the name of these inferior acceptance conditions, we hope
that the resulting automaton can be easier to use with tools that only
deal with such inferior acceptance conditions.  However, unlike for
state vs. transition-based acceptance, there is currently no means to
request another acceptance name to be used.
</p>

<p>
The <a href="http://adl.github.io/hoaf/#canonical-acceptance-specifications-for-classical-conditions">canonical encodings for acceptance conditions</a> are specified quite
strictly in the HOA format.  For instance <code>generalized-Buchi 2</code>
corresponds to <code>Inf(0)&amp;Inf(1)</code>, not to <code>Inf(1)&amp;Inf(0)</code>, even though
the two formulas are equivalent.  Spot's HOA output routine contains
some limited form of equivalence check (based mostly on associativity
and commutativity of the Boolean operators), so that if it detects
such a simple inversion, it will output it in the order required to be
allowed to name the acceptance condition.
</p>

<p>
In the following example, you can see <code>autfilt</code> removing the duplicate
Rabin pair, and reordering the remaining pair to fit the syntax
corresponding to <code>Rabin 1</code>.
</p>

<div class="org-src-container">

<pre class="src src-sh">autfilt &lt;&lt;EOF
<span class="org-sh-heredoc">HOA: v1</span>
<span class="org-sh-heredoc">States: 3</span>
<span class="org-sh-heredoc">Start: 0</span>
<span class="org-sh-heredoc">AP: 2 "a" "b"</span>
<span class="org-sh-heredoc">Acceptance: 2 (Inf(1) &amp; Fin(0)) | (Inf(1) &amp; Fin(0))</span>
<span class="org-sh-heredoc">--BODY--</span>
<span class="org-sh-heredoc">State: 0 {0}</span>
<span class="org-sh-heredoc">[0&amp;!1] 0</span>
<span class="org-sh-heredoc">[0&amp;1] 1</span>
<span class="org-sh-heredoc">[!0] 2</span>
<span class="org-sh-heredoc">State: 1</span>
<span class="org-sh-heredoc">[0] 1 {1}</span>
<span class="org-sh-heredoc">[0&amp;1] 2 {1}</span>
<span class="org-sh-heredoc">State: 2</span>
<span class="org-sh-heredoc">[!0] 1 {0 1}</span>
<span class="org-sh-heredoc">[0]  2 {0 1}</span>
<span class="org-sh-heredoc">--END--</span>
<span class="org-sh-heredoc">EOF</span>
</pre>
</div>

<div class="org-src-container">

<pre class="src src-hoa"><span class="org-hoa-header-uppercase">HOA:</span> v1
<span class="org-hoa-header-uppercase">States:</span> 3
<span class="org-hoa-header-uppercase">Start:</span> 0
<span class="org-hoa-header-uppercase">AP:</span> 2 <span class="org-string">"a"</span> <span class="org-string">"b"</span>
<span class="org-hoa-header-lowercase">acc-name:</span> Rabin 1
<span class="org-hoa-header-uppercase">Acceptance:</span> 2 <span class="org-hoa-builtin">Fin</span>(<span class="org-hoa-acceptance-set">0</span>) &amp; <span class="org-hoa-builtin">Inf</span>(<span class="org-hoa-acceptance-set">1</span>)
<span class="org-hoa-header-lowercase">properties:</span> trans-labels explicit-labels state-acc
<span class="org-hoa-keyword">--BODY--</span>
<span class="org-hoa-header-uppercase">State:</span> 0 {<span class="org-hoa-acceptance-set">0</span>}
[<span class="org-hoa-ap-number">0</span>&amp;!<span class="org-hoa-ap-number">1</span>] 0
[<span class="org-hoa-ap-number">0</span>&amp;<span class="org-hoa-ap-number">1</span>] 1
[!<span class="org-hoa-ap-number">0</span>] 2
<span class="org-hoa-header-uppercase">State:</span> 1 {<span class="org-hoa-acceptance-set">1</span>}
[<span class="org-hoa-ap-number">0</span>] 1
[<span class="org-hoa-ap-number">0</span>&amp;<span class="org-hoa-ap-number">1</span>] 2
<span class="org-hoa-header-uppercase">State:</span> 2 {<span class="org-hoa-acceptance-set">0 1</span>}
[!<span class="org-hoa-ap-number">0</span>] 1
[<span class="org-hoa-ap-number">0</span>] 2
<span class="org-hoa-keyword">--END--</span>
</pre>
</div>

<p>
Internally, the acceptance condition is stored as an array in reverse
polish notation, and the primitives <code>Inf</code> and <code>Fin</code> are actually
parametered by bitsets representing multiple sets numbers.  For
instance the generalized Büchi acceptance
<code>Inf(0)&amp;Inf(1)&amp;Inf(2)&amp;Inf(3)</code> is actually stored as a single term
<code>Inf({0,1,2,3})</code>.  Similarly, <code>Fin({1,3,5})</code> is our internal encoding
for <code>Fin(1)|Fin(3)|Fin(5)</code>.
</p>

<p>
A more complex acceptance condition, such as
<code>(Fin(0)&amp;Inf(1))|(Fin(2)&amp;Inf(3)&amp;Inf(4))|Fin(5)</code> (a generalized-Rabin
acceptance), would be encoded as the following 8-element array.
</p>

<pre class="example">
Fin({5}) Inf({3,4}) Fin({2}) 2&amp; Inf({1}) Fin(0) 2&amp; 3|
</pre>

<p>
This has to be read as a <a href="http://en.wikipedia.org/wiki/Reverse_Polish_notation">reverse Polish notation</a> where the numbers in
front of the operators <code>&amp;</code> and <code>|</code> indicate the number of arguments
they consume (these operators are n-ary).
</p>

<p>
When you look at an acceptance condition output by Spot, you can
actually spot the terms that have been grouped together internally by
looking at the spacing around operators <code>&amp;</code> and <code>|</code>.  For instance:
</p>

<div class="org-src-container">

<pre class="src src-sh">randaut -A<span class="org-string">"Fin(0)|Fin(1)|Fin(2)&amp;Fin(3)&amp;Inf(4)&amp;Inf(5)"</span> 0 | grep Acceptance:
</pre>
</div>

<div class="org-src-container">

<pre class="src src-hoa"><span class="org-hoa-header-uppercase">Acceptance:</span> 6 (<span class="org-hoa-builtin">Fin</span>(<span class="org-hoa-acceptance-set">0</span>)|<span class="org-hoa-builtin">Fin</span>(<span class="org-hoa-acceptance-set">1</span>)) | (<span class="org-hoa-builtin">Fin</span>(<span class="org-hoa-acceptance-set">2</span>) &amp; <span class="org-hoa-builtin">Fin</span>(<span class="org-hoa-acceptance-set">3</span>) &amp; (<span class="org-hoa-builtin">Inf</span>(<span class="org-hoa-acceptance-set">4</span>)&amp;<span class="org-hoa-builtin">Inf</span>(<span class="org-hoa-acceptance-set">5</span>)))
</pre>
</div>

<p>
Here <code>Fin(0)|Fin(1)</code> is actually a single internal term <code>Fin({0,1})</code>,
and likewise for <code>Inf(4)&amp;Inf(5)</code>.
</p>
</div>
</div>

<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3">State-based vs. transition-based labels</h3>
<div class="outline-text-3" id="text-3-3">
<p>
State labels are handled in the same way as state-based acceptance:
Spot store labels on transitions internally, so if an input automaton
has state labels, those are pushed to all outgoing transitions.
</p>

<p>
For instance an automaton declared in some HOA file with this body:
</p>

<div class="org-src-container">

<pre class="src src-hoa"><span class="org-hoa-header-uppercase">State:</span> [<span class="org-hoa-ap-number">0</span>&amp;<span class="org-hoa-ap-number">1</span>] 0
0 1 2
<span class="org-hoa-header-uppercase">State:</span> [!<span class="org-hoa-ap-number">0</span>&amp;<span class="org-hoa-ap-number">1</span>] 1 {<span class="org-hoa-acceptance-set">0</span>}
0 1
<span class="org-hoa-header-uppercase">State:</span> [!<span class="org-hoa-ap-number">1</span>] 2
2 1
</pre>
</div>

<p>
will always be stored as an automaton with the following transition
structure
</p>


<div class="org-src-container">

<pre class="src src-hoa"><span class="org-hoa-header-uppercase">State:</span> 0
[<span class="org-hoa-ap-number">0</span>&amp;<span class="org-hoa-ap-number">1</span>] 0
[<span class="org-hoa-ap-number">0</span>&amp;<span class="org-hoa-ap-number">1</span>] 1
[<span class="org-hoa-ap-number">0</span>&amp;<span class="org-hoa-ap-number">1</span>] 2
<span class="org-hoa-header-uppercase">State:</span> 1
[!<span class="org-hoa-ap-number">0</span>&amp;<span class="org-hoa-ap-number">1</span>] 0 {<span class="org-hoa-acceptance-set">0</span>}
[!<span class="org-hoa-ap-number">0</span>&amp;<span class="org-hoa-ap-number">1</span>] 1 {<span class="org-hoa-acceptance-set">0</span>}
<span class="org-hoa-header-uppercase">State:</span> 2
[!<span class="org-hoa-ap-number">1</span>] 2
[!<span class="org-hoa-ap-number">1</span>] 1
</pre>
</div>

<p>
The HOA printer has an option to output automata using state-based
labels whenever that is possible.  The option is named <code>k</code> (i.e., use
<code>-Hk</code> with command-line tools) because it is useful when the HOA file
is used to describe a Kripke structure.
</p>
</div>
</div>

<div id="outline-container-property-bits" class="outline-3">
<h3 id="property-bits"><a id="sec-3-4" name="sec-3-4"></a>Property flags</h3>
<div class="outline-text-3" id="text-property-bits">

<p>
The <code>HOA</code> format supports a number of optional <code>property:</code> tokens.
These properties can be useful to speedup certain algorithms: for
instance it is easier to complement a deterministic automaton that is
known to be inherently weak.
</p>

<p>
Spot stores the properties that matters to its algorithms as
<a href="concepts.html#property-flags">additional bits attached to each automaton</a>.  Currently the HOA parser
ignores all the properties that are unused by Spot.
</p>

<p>
Some of the supported properties are double-checked when the automaton
is parsed; this is for instance the case of <code>deterministic</code>,
<code>state-based</code>.  The parser will in fact infer these properties from the
body of the file, and then return and error if what has been declared
does not correspond to the reality.
</p>

<p>
Some supported properties (like <code>weak</code>, <code>inherently-weak</code>,
<code>very-weak</code>, <code>terminal</code>, <code>unambiguous</code>, <code>semi-deterministic</code>, or
<code>stutter-invariant</code>) are not double-checked, because that would
require more operations.  Command-line tools that read HOA files all
take a <code>--trust-hoa=no</code> option to ignore properties that are not
double-checked by the parser.
</p>

<p>
It should be noted that each property can take three values: true,
false, or maybe.  So actually two bits are used per property.  For
instance if in some algorithm you want to know whether an automaton is
complete (the equivalent of calling <code>autfilt -q
--is-complete aut.hoa</code> from the command-line), you should not
call the method <code>aut-&gt;prop_complete()</code> because that only checks
the property bits, and it might return <code>maybe</code> even if <code>aut</code> is
deterministic.  Instead, call the function <code>is_complete(aut)</code>.
This function will first test the property bits, and do the actual
check in case it is unknown.
</p>

<p>
Algorithms that update a TωA should call the method <code>prop_keep()</code> and
use the argument to specify which of the properties they preserve.
Algorithms that input a TωA and output a new one may call the method
<code>prop_copy()</code> to copy over the subset of properties they preserve.
Using these two functions ensure that in the future, whenever a new
property is added to the TωA class, we cannot forget to update all the
calls <code>prop_copy()</code> or <code>prop_keep()</code> (because these functions will
take a new argument).
</p>

<p>
The <code>HOA</code> printer also tries to not bloat the output with many
redundant and useless properties.  For instance <code>deterministic</code>
automata are necessarily <code>unambiguous</code>, and people interested in
unambiguous automata know that, so Spot only outputs the <code>unambiguous</code>
property if an unambiguous automaton is non-deterministic.  Similarly,
while Spot may output alternating automata, it does not output
the <code>no-univ-branch</code> property because we cannot think of a situation
where this would be useful.  This decision can be overridden by
passing the <code>-Hv</code> (or <code>--hoa=v</code>) option to the command-line tools:
this requests "verbose" properties.
</p>

<p>
The following table summarizes how supported properties are handled.  In
particular:
</p>
<ul class="org-ul">
<li>For the parser, <code>checked</code> means that the property is always inferred
and checked against any declaration (if present), <code>trusted</code> means
that the property will be stored without being checked (unless
<code>--trust-hoa=no</code> is specified).
</li>
<li>Stored properties are those represented as bits in the automaton.
</li>
<li>The printer will sometime check some properties when it can do
it as part of its initial "survey scan" of the automaton; in that
case the stored property is not used.  This makes it possible
to detect deterministic automata that have been output by algorithms
that do not try to output deterministic automata.
</li>
</ul>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">property</th>
<th scope="col" class="left">parser</th>
<th scope="col" class="left">stored</th>
<th scope="col" class="left">printer</th>
<th scope="col" class="left">notes</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left"><code>state-labels</code></td>
<td class="left">checked</td>
<td class="left">no</td>
<td class="left">checked if <code>-Hk</code></td>
<td class="left">state labels are converted to transition labels when reading TωA</td>
</tr>

<tr>
<td class="left"><code>trans-labels</code></td>
<td class="left">checked</td>
<td class="left">no</td>
<td class="left">always, unless <code>-Hi</code> or <code>-Hk</code></td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left"><code>implicit-labels</code></td>
<td class="left">checked</td>
<td class="left">no</td>
<td class="left">if <code>-Hi</code></td>
<td class="left"><code>-Hi</code> only works for deterministic automata</td>
</tr>

<tr>
<td class="left"><code>explicit-labels</code></td>
<td class="left">checked</td>
<td class="left">no</td>
<td class="left">always, unless <code>-Hi</code></td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left"><code>state-acc</code></td>
<td class="left">checked</td>
<td class="left">yes</td>
<td class="left">checked, unless <code>-Ht</code> or <code>-Hm</code></td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left"><code>trans-acc</code></td>
<td class="left">checked</td>
<td class="left">no</td>
<td class="left">if not <code>state-acc</code> and not <code>-Hm</code></td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left"><code>no-univ-branch</code></td>
<td class="left">ignored</td>
<td class="left">no</td>
<td class="left">only if <code>-Hv</code></td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left"><code>univ-branch</code></td>
<td class="left">checked</td>
<td class="left">no</td>
<td class="left">checked</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left"><code>deterministic</code></td>
<td class="left">checked</td>
<td class="left">yes</td>
<td class="left">checked</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left"><code>complete</code></td>
<td class="left">checked</td>
<td class="left">yes</td>
<td class="left">checked</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left"><code>unambiguous</code></td>
<td class="left">trusted</td>
<td class="left">yes</td>
<td class="left">as stored if (<code>-Hv</code> or not <code>deterministic</code>)</td>
<td class="left">can be checked with <code>--check=unambiguous</code></td>
</tr>

<tr>
<td class="left"><code>semi-deterministic</code></td>
<td class="left">trusted</td>
<td class="left">yes</td>
<td class="left">as stored if (<code>-Hv</code> or not <code>deterministic</code>)</td>
<td class="left">can be checked with <code>--check=semi-deterministic</code></td>
</tr>

<tr>
<td class="left"><code>stutter-invariant</code></td>
<td class="left">trusted</td>
<td class="left">yes</td>
<td class="left">as stored</td>
<td class="left">can be checked with <code>--check=stuttering</code></td>
</tr>

<tr>
<td class="left"><code>stutter-sensitive</code></td>
<td class="left">trusted</td>
<td class="left">yes</td>
<td class="left">as stored (opposite of <code>stutter-invariant</code>)</td>
<td class="left">can be checked with <code>--check=stuttering</code></td>
</tr>

<tr>
<td class="left"><code>terminal</code></td>
<td class="left">trusted</td>
<td class="left">yes</td>
<td class="left">as stored</td>
<td class="left">can be checked with <code>--check=strength</code></td>
</tr>

<tr>
<td class="left"><code>very-weak</code></td>
<td class="left">trusted</td>
<td class="left">yes</td>
<td class="left">as stored if (<code>-Hv</code> or not <code>terminal</code>)</td>
<td class="left">can be checked with <code>--check=strength</code></td>
</tr>

<tr>
<td class="left"><code>weak</code></td>
<td class="left">trusted</td>
<td class="left">yes</td>
<td class="left">as stored if (<code>-Hv</code> or not (<code>terminal</code> or <code>very-weak</code>))</td>
<td class="left">can be checked with <code>--check=strength</code></td>
</tr>

<tr>
<td class="left"><code>inherently-weak</code></td>
<td class="left">trusted</td>
<td class="left">yes</td>
<td class="left">as stored if (<code>-Hv</code> or not <code>weak</code>)</td>
<td class="left">can be checked with <code>--check=strength</code></td>
</tr>

<tr>
<td class="left"><code>colored</code></td>
<td class="left">ignored</td>
<td class="left">no</td>
<td class="left">checked</td>
<td class="left">&#xa0;</td>
</tr>
</tbody>
</table>

<p>
The above table is for version 1 of the format.  When version 1.1 is
selected (using <code>-H1.1</code>), some negated properties may be output.  In
particular, <code>stutter-sensitive</code> is replaced by <code>!stutter-invariant</code>.
The logic of not cluttering the output with all of <code>!terminal</code>,
<code>!weak</code>, and <code>!inhenrently-weak</code> is similar to the positive versions:
<code>!inherently-weak</code> implies <code>!weak</code> which in turn implies <code>!terminal</code>,
so only one of those is emitted unless <code>-Hv</code> is used.
</p>
</div>
</div>

<div id="outline-container-named-properties" class="outline-3">
<h3 id="named-properties"><a id="sec-3-5" name="sec-3-5"></a>Named properties</h3>
<div class="outline-text-3" id="text-named-properties">

<p>
In addition to the bit properties discussed above, a TωA can carry
named properties of any type.  When attaching a property to a TωA, you
only supply a name for the property, a pointer, and an optional
destructor function.
</p>

<p>
They are currently two <a href="concepts.html#named-properties">named properties</a> related to the HOA format.
</p>

<dl class="org-dl">
<dt> <code>automaton-name</code> </dt><dd>Is a string that stores the name of the automaton (the one given after <code>name:</code> in the HOA format)
</dd>
<dt> <code>state-names</code> </dt><dd>is a vector of strings that stores the name of the states (in case states are named in the HOA format)
</dd>
</dl>

<p>
You can see these properties being preserved when an automaton is read and then immediately output:
</p>

<div class="org-src-container">

<pre class="src src-sh" id="hello-world">cat &gt;hw.hoa &lt;&lt;EOF
<span class="org-sh-heredoc">HOA: v1</span>
<span class="org-sh-heredoc">name: "hello world!"</span>
<span class="org-sh-heredoc">States: 3</span>
<span class="org-sh-heredoc">Start: 0</span>
<span class="org-sh-heredoc">AP: 2 "a" "b"</span>
<span class="org-sh-heredoc">Acceptance: 2 Inf(0)&amp;Inf(1)</span>
<span class="org-sh-heredoc">--BODY--</span>
<span class="org-sh-heredoc">State: 0 {0}</span>
<span class="org-sh-heredoc">[0&amp;!1] 0</span>
<span class="org-sh-heredoc">[0&amp;1] 1</span>
<span class="org-sh-heredoc">[!0] 2</span>
<span class="org-sh-heredoc">State: 1 "I am a state"</span>
<span class="org-sh-heredoc">[0] 1 {1}</span>
<span class="org-sh-heredoc">[0&amp;1] 2 {1}</span>
<span class="org-sh-heredoc">State: 2 "so am I"</span>
<span class="org-sh-heredoc">[!0] 1 {0 1}</span>
<span class="org-sh-heredoc">[0]  2 {0 1}</span>
<span class="org-sh-heredoc">--END--</span>
<span class="org-sh-heredoc">EOF</span>
autfilt hw.hoa
</pre>
</div>

<div class="org-src-container">

<pre class="src src-hoa"><span class="org-hoa-header-uppercase">HOA:</span> v1
<span class="org-hoa-header-lowercase">name:</span> <span class="org-string">"hello world!"</span>
<span class="org-hoa-header-uppercase">States:</span> 3
<span class="org-hoa-header-uppercase">Start:</span> 0
<span class="org-hoa-header-uppercase">AP:</span> 2 <span class="org-string">"a"</span> <span class="org-string">"b"</span>
<span class="org-hoa-header-lowercase">acc-name:</span> generalized-Buchi 2
<span class="org-hoa-header-uppercase">Acceptance:</span> 2 <span class="org-hoa-builtin">Inf</span>(<span class="org-hoa-acceptance-set">0</span>)&amp;<span class="org-hoa-builtin">Inf</span>(<span class="org-hoa-acceptance-set">1</span>)
<span class="org-hoa-header-lowercase">properties:</span> trans-labels explicit-labels state-acc
<span class="org-hoa-keyword">--BODY--</span>
<span class="org-hoa-header-uppercase">State:</span> 0 {<span class="org-hoa-acceptance-set">0</span>}
[<span class="org-hoa-ap-number">0</span>&amp;!<span class="org-hoa-ap-number">1</span>] 0
[<span class="org-hoa-ap-number">0</span>&amp;<span class="org-hoa-ap-number">1</span>] 1
[!<span class="org-hoa-ap-number">0</span>] 2
<span class="org-hoa-header-uppercase">State:</span> 1 <span class="org-string">"I am a state"</span> {<span class="org-hoa-acceptance-set">1</span>}
[<span class="org-hoa-ap-number">0</span>] 1
[<span class="org-hoa-ap-number">0</span>&amp;<span class="org-hoa-ap-number">1</span>] 2
<span class="org-hoa-header-uppercase">State:</span> 2 <span class="org-string">"so am I"</span> {<span class="org-hoa-acceptance-set">0 1</span>}
[!<span class="org-hoa-ap-number">0</span>] 1
[<span class="org-hoa-ap-number">0</span>] 2
<span class="org-hoa-keyword">--END--</span>
</pre>
</div>

<p>
However if <code>autfilt</code> performs some transformation, and actually has to
construct a new automaton, those properties will not be quarried over
to the new automaton.  First because it is not obvious that the new
automaton should have the same name, and second because if a new
automaton is created, there might not be clear correspondence between
the old states and the new ones.
</p>


<p>
Here is for instance the result when <code>autfilt</code> is instructed to
simplify the automaton:
</p>

<div class="org-src-container">

<pre class="src src-sh">autfilt --small hw.hoa
</pre>
</div>

<div class="org-src-container">

<pre class="src src-hoa"><span class="org-hoa-header-uppercase">HOA:</span> v1
<span class="org-hoa-header-uppercase">States:</span> 3
<span class="org-hoa-header-uppercase">Start:</span> 0
<span class="org-hoa-header-uppercase">AP:</span> 2 <span class="org-string">"a"</span> <span class="org-string">"b"</span>
<span class="org-hoa-header-lowercase">acc-name:</span> Buchi
<span class="org-hoa-header-uppercase">Acceptance:</span> 1 <span class="org-hoa-builtin">Inf</span>(<span class="org-hoa-acceptance-set">0</span>)
<span class="org-hoa-header-lowercase">properties:</span> trans-labels explicit-labels state-acc deterministic
<span class="org-hoa-keyword">--BODY--</span>
<span class="org-hoa-header-uppercase">State:</span> 0
[<span class="org-hoa-ap-number">0</span>&amp;!<span class="org-hoa-ap-number">1</span>] 0
[<span class="org-hoa-ap-number">0</span>&amp;<span class="org-hoa-ap-number">1</span>] 1
[!<span class="org-hoa-ap-number">0</span>] 2
<span class="org-hoa-header-uppercase">State:</span> 1
[<span class="org-hoa-ap-number">0</span>&amp;!<span class="org-hoa-ap-number">1</span>] 1
[<span class="org-hoa-ap-number">0</span>&amp;<span class="org-hoa-ap-number">1</span>] 2
<span class="org-hoa-header-uppercase">State:</span> 2 {<span class="org-hoa-acceptance-set">0</span>}
[!<span class="org-hoa-ap-number">0</span>] 1
[<span class="org-hoa-ap-number">0</span>] 2
<span class="org-hoa-keyword">--END--</span>
</pre>
</div>


<p>
Note that if the name of the automaton is important to you, it can be
fixed via the <code>--name</code> option.  For instance <code>--name=%M</code> will
construct the new name by simply copying the one of the original
automaton.
</p>

<div class="org-src-container">

<pre class="src src-sh">autfilt --small hw.hoa --name=%M
</pre>
</div>

<div class="org-src-container">

<pre class="src src-hoa"><span class="org-hoa-header-uppercase">HOA:</span> v1
<span class="org-hoa-header-lowercase">name:</span> <span class="org-string">"hello world!"</span>
<span class="org-hoa-header-uppercase">States:</span> 3
<span class="org-hoa-header-uppercase">Start:</span> 0
<span class="org-hoa-header-uppercase">AP:</span> 2 <span class="org-string">"a"</span> <span class="org-string">"b"</span>
<span class="org-hoa-header-lowercase">acc-name:</span> Buchi
<span class="org-hoa-header-uppercase">Acceptance:</span> 1 <span class="org-hoa-builtin">Inf</span>(<span class="org-hoa-acceptance-set">0</span>)
<span class="org-hoa-header-lowercase">properties:</span> trans-labels explicit-labels state-acc deterministic
<span class="org-hoa-keyword">--BODY--</span>
<span class="org-hoa-header-uppercase">State:</span> 0
[<span class="org-hoa-ap-number">0</span>&amp;!<span class="org-hoa-ap-number">1</span>] 0
[<span class="org-hoa-ap-number">0</span>&amp;<span class="org-hoa-ap-number">1</span>] 1
[!<span class="org-hoa-ap-number">0</span>] 2
<span class="org-hoa-header-uppercase">State:</span> 1
[<span class="org-hoa-ap-number">0</span>&amp;!<span class="org-hoa-ap-number">1</span>] 1
[<span class="org-hoa-ap-number">0</span>&amp;<span class="org-hoa-ap-number">1</span>] 2
<span class="org-hoa-header-uppercase">State:</span> 2 {<span class="org-hoa-acceptance-set">0</span>}
[!<span class="org-hoa-ap-number">0</span>] 1
[<span class="org-hoa-ap-number">0</span>] 2
<span class="org-hoa-keyword">--END--</span>
</pre>
</div>

<p>
The page about <a href="oaut.html">common output option for automata</a> has a section showing
how <code>--name</code> can be used to construct complex pipelines with automata that
preserve their equivalent LTL formula in the <code>name:</code> field.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">Streaming support</h2>
<div class="outline-text-2" id="text-4">
<p>
The HOA format has been designed to easily allow multiple automata to
be concatenated together (in the same file, or in a pipe) and
processed in batch.  Spot's parser supports this scenario and can be
called repeatedly to read the next automaton from the input stream.
</p>

<p>
For instance the following creates 3 formulas of the form \(\bigwedge_i
\mathsf{G}\mathsf{F} p_i\), translates those into Büchi automata output
in the HOA format, and then read those automata with <code>autfilt</code> to
randomize the order of their transitions and states before printing
them in HOA format.
</p>

<div class="org-src-container">

<pre class="src src-sh">genltl --and-gf=1..3 | ltl2tgba -B -F- | autfilt --randomize
</pre>
</div>

<div class="org-src-container">

<pre class="src src-hoa"><span class="org-hoa-header-uppercase">HOA:</span> v1
<span class="org-hoa-header-lowercase">name:</span> <span class="org-string">"GFp1"</span>
<span class="org-hoa-header-uppercase">States:</span> 2
<span class="org-hoa-header-uppercase">Start:</span> 1
<span class="org-hoa-header-uppercase">AP:</span> 1 <span class="org-string">"p1"</span>
<span class="org-hoa-header-lowercase">acc-name:</span> Buchi
<span class="org-hoa-header-uppercase">Acceptance:</span> 1 <span class="org-hoa-builtin">Inf</span>(<span class="org-hoa-acceptance-set">0</span>)
<span class="org-hoa-header-lowercase">properties:</span> trans-labels explicit-labels state-acc complete
<span class="org-hoa-header-lowercase">properties:</span> deterministic stutter-invariant
<span class="org-hoa-keyword">--BODY--</span>
<span class="org-hoa-header-uppercase">State:</span> 0
[<span class="org-hoa-ap-number">0</span>] 1
[!<span class="org-hoa-ap-number">0</span>] 0
<span class="org-hoa-header-uppercase">State:</span> 1 {<span class="org-hoa-acceptance-set">0</span>}
[!<span class="org-hoa-ap-number">0</span>] 0
[<span class="org-hoa-ap-number">0</span>] 1
<span class="org-hoa-keyword">--END--</span>
<span class="org-hoa-header-uppercase">HOA:</span> v1
<span class="org-hoa-header-lowercase">name:</span> <span class="org-string">"G(Fp1 &amp; Fp2)"</span>
<span class="org-hoa-header-uppercase">States:</span> 3
<span class="org-hoa-header-uppercase">Start:</span> 1
<span class="org-hoa-header-uppercase">AP:</span> 2 <span class="org-string">"p1"</span> <span class="org-string">"p2"</span>
<span class="org-hoa-header-lowercase">acc-name:</span> Buchi
<span class="org-hoa-header-uppercase">Acceptance:</span> 1 <span class="org-hoa-builtin">Inf</span>(<span class="org-hoa-acceptance-set">0</span>)
<span class="org-hoa-header-lowercase">properties:</span> trans-labels explicit-labels state-acc complete
<span class="org-hoa-header-lowercase">properties:</span> deterministic stutter-invariant
<span class="org-hoa-keyword">--BODY--</span>
<span class="org-hoa-header-uppercase">State:</span> 0
[<span class="org-hoa-ap-number">0</span>] 1
[!<span class="org-hoa-ap-number">0</span>] 0
<span class="org-hoa-header-uppercase">State:</span> 1 {<span class="org-hoa-acceptance-set">0</span>}
[<span class="org-hoa-ap-number">0</span>&amp;<span class="org-hoa-ap-number">1</span>] 1
[!<span class="org-hoa-ap-number">1</span>] 2
[!<span class="org-hoa-ap-number">0</span>&amp;<span class="org-hoa-ap-number">1</span>] 0
<span class="org-hoa-header-uppercase">State:</span> 2
[!<span class="org-hoa-ap-number">1</span>] 2
[<span class="org-hoa-ap-number">0</span>&amp;<span class="org-hoa-ap-number">1</span>] 1
[!<span class="org-hoa-ap-number">0</span>&amp;<span class="org-hoa-ap-number">1</span>] 0
<span class="org-hoa-keyword">--END--</span>
<span class="org-hoa-header-uppercase">HOA:</span> v1
<span class="org-hoa-header-lowercase">name:</span> <span class="org-string">"G(Fp1 &amp; Fp2 &amp; Fp3)"</span>
<span class="org-hoa-header-uppercase">States:</span> 4
<span class="org-hoa-header-uppercase">Start:</span> 1
<span class="org-hoa-header-uppercase">AP:</span> 3 <span class="org-string">"p1"</span> <span class="org-string">"p2"</span> <span class="org-string">"p3"</span>
<span class="org-hoa-header-lowercase">acc-name:</span> Buchi
<span class="org-hoa-header-uppercase">Acceptance:</span> 1 <span class="org-hoa-builtin">Inf</span>(<span class="org-hoa-acceptance-set">0</span>)
<span class="org-hoa-header-lowercase">properties:</span> trans-labels explicit-labels state-acc complete
<span class="org-hoa-header-lowercase">properties:</span> deterministic stutter-invariant
<span class="org-hoa-keyword">--BODY--</span>
<span class="org-hoa-header-uppercase">State:</span> 0
[!<span class="org-hoa-ap-number">0</span>] 0
[<span class="org-hoa-ap-number">0</span>] 1
<span class="org-hoa-header-uppercase">State:</span> 1 {<span class="org-hoa-acceptance-set">0</span>}
[!<span class="org-hoa-ap-number">2</span>] 3
[!<span class="org-hoa-ap-number">1</span>&amp;<span class="org-hoa-ap-number">2</span>] 2
[<span class="org-hoa-ap-number">0</span>&amp;<span class="org-hoa-ap-number">1</span>&amp;<span class="org-hoa-ap-number">2</span>] 1
[!<span class="org-hoa-ap-number">0</span>&amp;<span class="org-hoa-ap-number">1</span>&amp;<span class="org-hoa-ap-number">2</span>] 0
<span class="org-hoa-header-uppercase">State:</span> 2
[!<span class="org-hoa-ap-number">1</span>] 2
[!<span class="org-hoa-ap-number">0</span>&amp;<span class="org-hoa-ap-number">1</span>] 0
[<span class="org-hoa-ap-number">0</span>&amp;<span class="org-hoa-ap-number">1</span>] 1
<span class="org-hoa-header-uppercase">State:</span> 3
[<span class="org-hoa-ap-number">0</span>&amp;<span class="org-hoa-ap-number">1</span>&amp;<span class="org-hoa-ap-number">2</span>] 1
[!<span class="org-hoa-ap-number">1</span>&amp;<span class="org-hoa-ap-number">2</span>] 2
[!<span class="org-hoa-ap-number">0</span>&amp;<span class="org-hoa-ap-number">1</span>&amp;<span class="org-hoa-ap-number">2</span>] 0
[!<span class="org-hoa-ap-number">2</span>] 3
<span class="org-hoa-keyword">--END--</span>
</pre>
</div>


<p>
It should be noted that the HOA parser is less efficient when it reads
from a pipe than when it reads from a file.  The reason is that if two
commands <code>A | B</code> exchange automata via a pipe, the command <code>A</code> may
require some time between the output of two automata, so if <code>B</code> does a
block read on its input to fill the parser's buffer, it might not be
able to process any automaton before <code>A</code> has produced enough automata
to fill the buffer.  To avoid this delay, whenever <code>B</code> detects that
the input is a pipe (or a terminal), it switches to an interactive
mode, where the input is read one character at a time.  This way an
automaton can be processed by <code>B</code> as soon as its <code>--END--</code> has been
received.
</p>

<p>
The HOA format has support for a <code>--ABORT--</code> token, that can be used
by tools that produce automata in a stream to cancel the current one.
This makes sense for instance when the automaton is constructed
on-the-fly, while it is being output.  This scenario does not occur in
Spot (automata are constructed before they are output), so it does not
emit <code>--ABORT--</code>.  However the input parser is fully aware of this
token.  Tools like <code>autfilt</code> will diagnose aborted automata in the
input, and continue processing with the next automaton.  The Python
bindings for the HOA parser can be configured in two modes: skip
aborted automata, or flag them as errors.
</p>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">Error recovery</h2>
<div class="outline-text-2" id="text-5">
<p>
The HOA parser does a fair amount of error recovery.  It is important
that when parsing a stream of automata, a syntax error in one
automaton does not invalidate the following automata (the parser
should at least be able to ignore everything up to <code>--END--</code> if it
cannot recover before).
</p>

<p>
Another scenario where syntax errors are more frequent is when an HOA
file is hand-edited.  For instance one could edit an HOA file to add a
few states and transitions, and forget to update the total number of
states in the format.  In that case the parser will diagnose the problem,
and fix the number of states.
</p>
</div>
</div>

<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6">Checked properties</h2>
<div class="outline-text-2" id="text-6">
<p>
When an automaton is output in HOA format, the <code>property:</code> lines
includes property registered into the automaton (see the Property
bits section above), and property that are trivial to compute.
</p>

<p>
Command-line tools with a HOA output all have a <code>--check</code> option that
can be used to request additional checks such as testing whether the
automaton is stutter-invariant, unambiguous, (inherently) weak, and
terminal.
</p>
</div>
</div>
<div id="outline-container-extensions" class="outline-2">
<h2 id="extensions"><a id="sec-7" name="sec-7"></a>Extensions</h2>
<div class="outline-text-2" id="text-extensions">

<p>
Spot supports two additional headers that are not part of the standard
HOA format.  These are <code>spot.highlight.states</code> and
<code>spot.highlight.edges</code>.  These are used to <a href="autfilt.html#decoration">decorate states and edges</a>
with colors.
</p>

<div class="org-src-container">

<pre class="src src-sh" id="decorate">cat &gt;decorate.hoa &lt;&lt;EOF
<span class="org-sh-heredoc">HOA: v1.1</span>
<span class="org-sh-heredoc">States: 3</span>
<span class="org-sh-heredoc">Start: 1</span>
<span class="org-sh-heredoc">AP: 2 "a" "b"</span>
<span class="org-sh-heredoc">Acceptance: 0 t</span>
<span class="org-sh-heredoc">spot.highlight.states: 1 0 2 3</span>
<span class="org-sh-heredoc">spot.highlight.edges: 1 1 2 2</span>
<span class="org-sh-heredoc">--BODY--</span>
<span class="org-sh-heredoc">State: 0</span>
<span class="org-sh-heredoc">[t] 0         /* edge #1 */</span>
<span class="org-sh-heredoc">State: 1</span>
<span class="org-sh-heredoc">[t] 2         /* edge #2 */</span>
<span class="org-sh-heredoc">State: 2</span>
<span class="org-sh-heredoc">[1] 0         /* edge #3 */</span>
<span class="org-sh-heredoc">[0&amp;!1] 2      /* edge #4 */</span>
<span class="org-sh-heredoc">--END--</span>
<span class="org-sh-heredoc">EOF</span>

autfilt decorate.hoa -d<span class="org-string">'.#'</span>
</pre>
</div>


<div class="figure">
<p><img src="decorate.svg" alt="decorate.svg" />
</p>
</div>


<p>
On the above example, we call <code>autfilt</code> with option <code>-d#</code> to display
edges numbers, which helps identifying the edges to highlight.  The
headers <code>spot.highlight.states:</code> and <code>spot.highlight.edges:</code> gives a
list of alternating state/edges numbers and color numbers.
</p>

<p>
So in the above file,
</p>
<div class="org-src-container">

<pre class="src src-hoa"><span class="org-hoa-header-lowercase">spot.highlight.states:</span> 1 0 2 3
<span class="org-hoa-header-lowercase">spot.highlight.edges:</span> 1 1 2 2
</pre>
</div>
<p>
specifies that states <code>#1</code> should have color <code>0</code>, state <code>#2</code> should have
color <code>3</code>, edge <code>#1</code> should have color <code>1</code>, and edge <code>#2</code> should have
color <code>2</code>.
</p>

<p>
State numbers obviously correspond to the state numbers used in the
HOA file, and are 0-based.  Edge numbers are 1-based (because that is
how they are actually stored in Spot), and numbered in the order they
appear in the HOA file.
</p>

<p>
The color palette is currently the same that is used for coloring
acceptance sets.  This might change in the future.
</p>

<p>
The automaton parser will not complain if these headers are used in
the <code>HOA: v1</code> file, even if <code>v1</code> disallows dots in header names.
However the automaton printer is more rigorous and will only output
these lines when version 1.1 is selected.
</p>

<p>
Compare:
</p>

<div class="org-src-container">

<pre class="src src-sh">autfilt -H1 decorate.hoa; <span class="org-builtin">echo</span>
autfilt -H1.1 decorate.hoa
</pre>
</div>
<div class="org-src-container">

<pre class="src src-hoa"><span class="org-hoa-header-uppercase">HOA:</span> v1
<span class="org-hoa-header-uppercase">States:</span> 3
<span class="org-hoa-header-uppercase">Start:</span> 1
<span class="org-hoa-header-uppercase">AP:</span> 2 <span class="org-string">"a"</span> <span class="org-string">"b"</span>
<span class="org-hoa-header-lowercase">acc-name:</span> all
<span class="org-hoa-header-uppercase">Acceptance:</span> 0 <span class="org-hoa-builtin">t</span>
<span class="org-hoa-header-lowercase">properties:</span> trans-labels explicit-labels state-acc deterministic
<span class="org-hoa-keyword">--BODY--</span>
<span class="org-hoa-header-uppercase">State:</span> 0
[<span class="org-hoa-builtin">t</span>] 0
<span class="org-hoa-header-uppercase">State:</span> 1
[<span class="org-hoa-builtin">t</span>] 2
<span class="org-hoa-header-uppercase">State:</span> 2
[<span class="org-hoa-ap-number">1</span>] 0
[<span class="org-hoa-ap-number">0</span>&amp;!<span class="org-hoa-ap-number">1</span>] 2
<span class="org-hoa-keyword">--END--</span>

<span class="org-hoa-header-uppercase">HOA:</span> v1.1
<span class="org-hoa-header-uppercase">States:</span> 3
<span class="org-hoa-header-uppercase">Start:</span> 1
<span class="org-hoa-header-uppercase">AP:</span> 2 <span class="org-string">"a"</span> <span class="org-string">"b"</span>
<span class="org-hoa-header-lowercase">acc-name:</span> all
<span class="org-hoa-header-uppercase">Acceptance:</span> 0 <span class="org-hoa-builtin">t</span>
<span class="org-hoa-header-lowercase">properties:</span> trans-labels explicit-labels state-acc !complete
<span class="org-hoa-header-lowercase">properties:</span> deterministic
<span class="org-hoa-header-lowercase">spot.highlight.states:</span> 1 0 2 3
<span class="org-hoa-header-lowercase">spot.highlight.edges:</span> 1 1 2 2
<span class="org-hoa-keyword">--BODY--</span>
<span class="org-hoa-header-uppercase">State:</span> 0
[<span class="org-hoa-builtin">t</span>] 0
<span class="org-hoa-header-uppercase">State:</span> 1
[<span class="org-hoa-builtin">t</span>] 2
<span class="org-hoa-header-uppercase">State:</span> 2
[<span class="org-hoa-ap-number">1</span>] 0
[<span class="org-hoa-ap-number">0</span>&amp;!<span class="org-hoa-ap-number">1</span>] 2
<span class="org-hoa-keyword">--END--</span>
</pre>
</div>
</div>
</div>
</div>
</body>
</html>
